{"version":3,"file":"static/js/204.1ce84878.chunk.js","mappings":"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B,CACtC,SACA,OACA,QACA,cACA,UACA,SACA,UACA,UACA,WACA,SACA,OACA,QACA,QACA,OACA,OACA,SACA,QACA,QACA,QACA,OACA,kBACA,QACA,gBACA,gBACA,SACA,OACA,YACA,cACA,OACA,OACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,UACA,YACA,QACA,WACA,QACA,YACA,OACA,UACA,SACA,UACA,SACA,QACA,UACA,SACA,WAwBWC,GAtBqB,UAC7BD,EAD6B,CAEhC,aAoB0B,CAC1B,gBACA,cACA,kBACA,mBAE2B,UACxBA,EACAC,GAG6B,UAC7BD,EAxBwB,CAC3B,iBACA,eACA,mBACA,mBAE2B,CAC3B,iBACA,eACA,mBACA,oBA0LwB,UAvKQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,sBACA,mBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,yBACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,eACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,q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","sources":["Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","Formula/expandPoly.ts","Formula/solveLP_simplex.ts","Formula/linearUpperBound.ts","Formula/addedUtils.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/subproblemUtil.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/DefaultSplitWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T, i: number) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Record<K, Exclude<V, undefined>>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap(d => b.map(e => [d, [e]].flat())), [[]] as T[][])\n}\n\nexport function partition<T>(q: T[], length: number): T[][] {\n  let rest = q.length % length\n  let size = Math.floor(q.length / length)\n  let j = 0;\n  return Array.from({ length }, (_, i) => q.slice(j, j += size + (i < rest ? 1 : 0)));\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze(obj: any, layers: number = 5) {\n  if (layers === 0) return\n  if (typeof obj === \"object\")\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\n}\n\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\n  return arr\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { OptNode } from \"./optimization\"\nimport type { ComputeNode, ConstantNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, StrPrioNode, SubscriptNode, ThresholdNode } from \"./type\"\n\ntype Opt = number | OptNode\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype N_S = Num | Str\ntype AnyNode = NumNode | StrNode\n\nexport const todo: OptNode = constant(NaN, { name: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\nexport const none = constant(\"none\")\n\nexport function constant(value: number, info?: Info): ConstantNode<number>\nexport function constant(value: string | undefined, info?: Info): ConstantNode<string | undefined>\nexport function constant(value: number | string | undefined, info?: Info): ConstantNode<number> | ConstantNode<string | undefined>\nexport function constant(value: number | string | undefined, info?: Info): ConstantNode<number | string | undefined> {\n  return typeof value === \"number\"\n    ? { operation: \"const\", operands: [], type: \"number\", value, info }\n    : { operation: \"const\", operands: [], type: \"string\", value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): ConstantNode<number> {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { unit: \"%\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: OptNode, info: Info): OptNode\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): LookupNode<NumNode>\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): LookupNode<StrNode>\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: N_S | \"none\", info?: Info): LookupNode<AnyNode> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function min(...values: Num[]): ComputeNode\nexport function min(...values: Num[]): ComputeNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function max(...values: Num[]): ComputeNode\nexport function max(...values: Num[]): ComputeNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function sum(...values: Num[]): ComputeNode\nexport function sum(...values: Num[]): ComputeNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\nexport function prod(...values: Num[]): ComputeNode\nexport function prod(...values: Num[]): ComputeNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\nexport function frac(x: Num, c: Num): ComputeNode\nexport function frac(x: Num, c: Num): ComputeNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\nexport function res(base: Num): ComputeNode\nexport function res(base: Num): ComputeNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(v1: Num, v2: Num, eq: Num, neq: Num, info?: Info): MatchNode<NumNode>\nexport function compareEq(v1: Num, v2: Num, eq: Str, neq: Str, info?: Info): MatchNode<StrNode>\nexport function compareEq(v1: Str, v2: Str, eq: Num, neq: Num, info?: Info): MatchNode<NumNode>\nexport function compareEq(v1: Str, v2: Str, eq: Str, neq: Str, info?: Info): MatchNode<StrNode>\nexport function compareEq(v1: N_S, v2: N_S, eq: N_S, neq: N_S, info?: Info): MatchNode<AnyNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)], info }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode>\nexport function equal(v1: N_S, v2: N_S, pass: Num, info?: Info): MatchNode<NumNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode>\nexport function equalStr(v1: N_S, v2: N_S, pass: Str, info?: Info): MatchNode<StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode>\nexport function unequal(v1: N_S, v2: N_S, pass: Num, info?: Info): MatchNode<NumNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode>\nexport function unequalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode>\nexport function unequalStr(v1: N_S, v2: N_S, pass: Str, info?: Info): MatchNode<StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(undefined), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Opt, v2: Opt, pass: Opt, info?: Info): ThresholdNode<OptNode, OptNode, OptNode>\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode>\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode> {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): ThresholdNode<StrNode> {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Opt, v2: Opt, pass: Opt, info?: Info): ThresholdNode<OptNode, OptNode, OptNode>\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode>\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode> {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n/** v1 >= v2 ? ge : le */\nexport function threshold(v1: Opt, v2: Opt, ge: Opt, le: Opt, info?: Info): OptNode\nexport function threshold(v1: Num, v2: Num, ge: Num, le: Num, info?: Info): NumNode\nexport function threshold(v1: Num, v2: Num, ge: Num, le: Num, info?: Info): NumNode {\n  return { operation: \"threshold\", operands: intoOps([v1, v2, ge, le]) as any, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<NumNode> | DataNode<StrNode> {\n  return { operation: \"data\", operands: [base as any], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): DataNode<NumNode>\nexport function resetData(base: StrNode, data: Data, info?: Info): DataNode<StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<AnyNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrPrioNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: N_S[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: N_S): AnyNode\nfunction intoV(value: N_S): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, `equalStr`, or `compareEq` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode>\nexport function matchFull(v1: N_S, v2: N_S, match: N_S, unmatch: N_S, info?: Info): MatchNode<AnyNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n\nexport function cmpNode(a: NumNode, b: NumNode): boolean {\n  if (a.operation !== b.operation) return false;\n  if (a.operands.length !== b.operands.length) return false;\n\n  switch (a.operation) {\n    case 'read':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.path.every((ai, i) => ai === b.path[i])\n    case 'const':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.value === b.value\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      let used = [] as number[]\n      return a.operands.every((ai, i) => b.operands.some((bj, j) => {\n        if (used.includes(j)) return false\n        if (cmpNode(ai, bj)) {\n          used.push(j)\n          return true\n        }\n        return false\n      }))\n    default:\n      return a.operands.every((ai, i) => cmpNode(ai as NumNode, b.operands[i] as NumNode))\n  }\n}\n\n// Hash function pulled from StackOverflow\n//   https://stackoverflow.com/a/52171480\nconst cyrb53 = function (str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n\n// I made these numbers up; we might get better performance with different choice.\nexport function hashNode(n: NumNode): number {\n  let hsh = Math.imul(cyrb53(n.operation), 5234543537);\n  switch (n.operation) {\n    case 'const':\n      return hsh ^ cyrb53(n.value.toString(2))\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      return n.operands.reduce((hsh, ni) => hsh ^ hashNode(ni), hsh)\n    default:\n      return (n.operands as NumNode[]).reduce((hsh, ni) => Math.imul(hsh ^ hashNode(ni), 9923429423), hsh)\n  }\n}\n","import { crawlObject, deepClone, objPathValue } from \"../Util/Util\"\nimport { AnyNode, Base, NodeData, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function deepNodeClone<T extends NodeData<NumNode | StrNode | undefined>>(data: T): T {\n  const result = deepClone(data)\n  // Restore `Info`\n  crawlObject(result, [], n => n.operation, (node, path) =>\n    node.info = { ...objPathValue(data, path).info })\n  return result\n}\n\nexport function forEachNodes<T extends Base<T> = AnyNode>(formulas: T[], topDown: (formula: T) => void, bottomUp: (formula: T) => void): void {\n  const visiting = new Set<T>(), visited = new Set<T>()\n\n  function traverse(formula: T) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas<Input extends Base<Input> = AnyNode, Interim extends Base<Interim> = Input, Output extends Base<Output> = Interim>(formulas: Input[], topDownMap: (formula: Input | Interim) => Interim, bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output): Output[] {\n  const visiting = new Set<Input | Interim>()\n  const topDownMapped = new Map<Input | Interim, Output>()\n  const bottomUpMapped = new Map<Interim, Output>()\n\n  function check(formula: Input | Interim): Output {\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN) as any\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: Interim): Interim | Output {\n    const operands = formula.operands.map(check)\n    return arrayEqual<Interim | Output>(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual<Input | Output>(result, formulas) ? formulas as any : result\n}\n\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(formulas: Input[], context: Context, map: (formula: Input, context: Context, map: (node: Input, context: Context) => Output) => Output): Output[] {\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\n  function internalMap(formula: Input, context: Context): Output {\n    let current = contextMapping.get(context)\n    if (!current) contextMapping.set(context, current = [new Set(), new Map()])\n    const [visiting, mapping] = current\n\n    const old = mapping.get(formula)\n    if (old) return old\n\n    if (visiting.has(formula))\n      throw new Error(\"Found cyclical dependency during formula mapping\")\n\n    visiting.add(formula)\n    const newFormula = map(formula, context, internalMap)\n    mapping.set(formula, newFormula)\n    visiting.delete(formula)\n\n    return newFormula\n  }\n  return formulas.map(formula => internalMap(formula, context))\n}\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { customMapFormula, forEachNodes, mapFormulas } from \"./internal\"\nimport { AnyNode, CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode, ThresholdNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport type OptNode = ComputeNode<OptNode, OptNode> | ThresholdNode<OptNode, OptNode, OptNode> |\n  ReadNode<number> | ConstantNode<number>\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): OptNode[] {\n  let opts = constantFold(formulas, topLevelData, shouldFold)\n  opts = flatten(opts)\n  return deduplicate(opts)\n}\nexport function precompute(formulas: OptNode[], initial: ArtifactBuildData[\"values\"], binding: (readNode: ReadNode<number> | ReadNode<string | undefined>) => string, slotCount: number): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n};\nconst x0=0`; // making sure `const` has at least one entry\n\n  let i = 1;\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation, operands } = f, name = `x${i++}`, operandNames = operands.map((x: OptNode) => names.get(x)!)\n    names.set(f, name)\n    switch (operation) {\n      case \"read\": {\n        const key = binding(f)\n        let arr = new Array(slotCount).fill(null).map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n        if (initial[key] && initial[key] !== 0) {\n          arr = [initial[key].toString(), ...arr]\n        }\n        body += `,${name}=${arr.join('+')}`\n        break\n      }\n      case \"const\": names.set(f, `(${f.value})`); break\n      case \"add\": case \"mul\": body += `,${name}=${operandNames.join(operation === \"add\" ? \"+\" : \"*\")}`; break\n      case \"min\": case \"max\": body += `,${name}=Math.${operation}(${operandNames})`; break\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandNames\n        body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n        break\n      }\n      case \"res\": body += `,${name}=res(${operandNames[0]})`; break\n      case \"sum_frac\": body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`; break\n\n      default: assertUnreachable(operation)\n    }\n  })\n  body += `;\\nreturn [${formulas.map(f => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: OptNode[]): OptNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\n      const formula = _formula as ComputeNode<OptNode>\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<OptNode, number>(),\n      formulas: new Set<OptNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode<OptNode> = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode<OptNode>, Map<OptNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula)) {\n        const formula = _formula as ComputeNode<OptNode>\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode<OptNode>\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<OptNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<OptNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): OptNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, OptNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(formulas, context, (formula, context, map) => {\n    const { operation } = formula, fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\n    const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\n    let result: OptNode | StrNode\n    switch (operation) {\n      case \"const\": result = formula; break\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: OptNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = foldStr(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = map(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = foldStr(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? foldStr(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = foldStr(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => map(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => map(x, context) as OptNode)\n        if (pass.operation === \"const\" && fail.operation === \"const\" && pass.value === fail.value)\n          result = pass\n        else if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation !== \"const\")\n          throw new Error(\"Found non-constant subscript node while folding\")\n        result = constant(formula.list[index.value])\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = map(operands[operands.length - 1], context)\n        else\n          result = map({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\": {\n        if (formula.reset) context = origin\n        const nextMap = nextContextMap.get(context)!\n        let nextContext = nextMap.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          nextMap.set(formula.data, nextContext)\n        }\n        result = map(formula.operands[0], nextContext)\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n\n    if (result.info) {\n      result = { ...result }\n      delete result.info\n    }\n    return result\n  }) as OptNode[]\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allAmpReactions = [\"vaporize\", \"melt\",] as const\nexport const allAdditiveReactions = [\"spread\", \"aggravate\"] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allInfusionAuraElements = [\"pyro\", 'cryo', 'hydro'] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allRollColorKeys = ['roll1', 'roll2', 'roll3', 'roll4', 'roll5', 'roll6'] as const\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = [\"max\", \"mid\", \"min\"] as const\nexport const genderKeys = [\"F\", \"M\"] as const\nexport type Gender = typeof genderKeys[number]\n\n\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  \"DeepwoodMemories\",\n  \"DefendersWill\",\n  \"EchoesOfAnOffering\",\n  \"EmblemOfSeveredFate\",\n  \"Gambler\",\n  \"GildedDreams\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  \"HuskOfOpulentDreams\",\n  \"Instructor\",\n  \"Lavawalker\",\n  \"LuckyDog\",\n  \"MaidenBeloved\",\n  \"MartialArtist\",\n  \"NoblesseOblige\",\n  \"OceanHuedClam\",\n  \"PaleFlame\",\n  \"PrayersForDestiny\",\n  \"PrayersForIllumination\",\n  \"PrayersForWisdom\",\n  \"PrayersToSpringtime\",\n  \"ResolutionOfSojourner\",\n  \"RetracingBolide\",\n  \"Scholar\",\n  \"ShimenawasReminiscence\",\n  \"TenacityOfTheMillelith\",\n  \"TheExile\",\n  \"ThunderingFury\",\n  \"Thundersoother\",\n  \"TinyMiracle\",\n  \"TravelingDoctor\",\n  \"VermillionHereafter\",\n  \"ViridescentVenerer\",\n  \"WanderersTroupe\",\n] as const\nexport const nonTravelerCharacterKeys = [\n  \"Albedo\",\n  \"Aloy\",\n  \"Amber\",\n  \"AratakiItto\",\n  \"Barbara\",\n  \"Beidou\",\n  \"Bennett\",\n  \"Candace\",\n  \"Chongyun\",\n  \"Collei\",\n  \"Cyno\",\n  \"Diluc\",\n  \"Diona\",\n  \"Dori\",\n  \"Eula\",\n  \"Fischl\",\n  \"Ganyu\",\n  \"Gorou\",\n  \"HuTao\",\n  \"Jean\",\n  \"KaedeharaKazuha\",\n  \"Kaeya\",\n  \"KamisatoAyaka\",\n  \"KamisatoAyato\",\n  \"Keqing\",\n  \"Klee\",\n  \"KujouSara\",\n  \"KukiShinobu\",\n  \"Lisa\",\n  \"Mona\",\n  \"Nilou\",\n  \"Ningguang\",\n  \"Noelle\",\n  \"Qiqi\",\n  \"RaidenShogun\",\n  \"Razor\",\n  \"Rosaria\",\n  \"SangonomiyaKokomi\",\n  \"Sayu\",\n  \"Shenhe\",\n  \"ShikanoinHeizou\",\n  \"Sucrose\",\n  \"Tartaglia\",\n  \"Thoma\",\n  \"Tighnari\",\n  \"Venti\",\n  \"Xiangling\",\n  \"Xiao\",\n  \"Xingqiu\",\n  \"Xinyan\",\n  \"YaeMiko\",\n  \"Yanfei\",\n  \"Yelan\",\n  \"Yoimiya\",\n  \"YunJin\",\n  \"Zhongli\",\n] as const\nexport const locationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  \"Traveler\",\n] as const\nexport const travelerElements = [\n  \"anemo\",\n  \"geo\",\n  \"electro\",\n  \"dendro\"\n] as const\nexport const travelerFKeys = [\n  \"TravelerAnemoF\",\n  \"TravelerGeoF\",\n  \"TravelerElectroF\",\n  \"TravelerDendroF\",\n] as const\nexport const travelerMKeys = [\n  \"TravelerAnemoM\",\n  \"TravelerGeoM\",\n  \"TravelerElectroM\",\n  \"TravelerDendroM\",\n] as const\nexport const travelerKeys = [\n  \"TravelerAnemo\",\n  \"TravelerGeo\",\n  \"TravelerElectro\",\n  \"TravelerDendro\",\n] as const\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\nexport const allWeaponSwordKeys = [\n  \"AmenomaKageuchi\",\n  \"AquilaFavonia\",\n  \"BlackcliffLongsword\",\n  \"CinnabarSpindle\",\n  \"CoolSteel\",\n  \"KagotsurubeIsshin\",\n  \"DarkIronSword\",\n  \"DullBlade\",\n  \"FavoniusSword\",\n  \"FesteringDesire\",\n  \"FilletBlade\",\n  \"FreedomSworn\",\n  \"HaranGeppakuFutsu\",\n  \"HarbingerOfDawn\",\n  \"IronSting\",\n  \"KeyOfKhajNisut\",\n  \"LionsRoar\",\n  \"MistsplitterReforged\",\n  \"PrimordialJadeCutter\",\n  \"PrototypeRancour\",\n  \"RoyalLongsword\",\n  \"SacrificialSword\",\n  \"SapwoodBlade\",\n  \"SilverSword\",\n  \"SkyriderSword\",\n  \"SkywardBlade\",\n  \"SummitShaper\",\n  \"SwordOfDescension\",\n  \"TheAlleyFlash\",\n  \"TheBlackSword\",\n  \"TheFlute\",\n  \"TravelersHandySword\",\n  \"XiphosMoonlight\",\n] as const\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\n\nexport const allWeaponClaymoreKeys = [\n  \"Akuoumaru\",\n  \"BlackcliffSlasher\",\n  \"BloodtaintedGreatsword\",\n  \"DebateClub\",\n  \"FavoniusGreatsword\",\n  \"FerrousShadow\",\n  \"ForestRegalia\",\n  \"KatsuragikiriNagamasa\",\n  \"LithicBlade\",\n  \"LuxuriousSeaLord\",\n  \"MakhairaAquamarine\",\n  \"OldMercsPal\",\n  \"PrototypeArchaic\",\n  \"Rainslasher\",\n  \"RedhornStonethresher\",\n  \"RoyalGreatsword\",\n  \"SacrificialGreatsword\",\n  \"SerpentSpine\",\n  \"SkyriderGreatsword\",\n  \"SkywardPride\",\n  \"SnowTombedStarsilver\",\n  \"SongOfBrokenPines\",\n  \"TheBell\",\n  \"TheUnforged\",\n  \"WasterGreatsword\",\n  \"Whiteblind\",\n  \"WhiteIronGreatsword\",\n  \"WolfsGravestone\",\n] as const\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\n\nexport const allWeaponPolearmKeys = [\n  \"BeginnersProtector\",\n  \"BlackcliffPole\",\n  \"BlackTassel\",\n  \"CalamityQueller\",\n  \"CrescentPike\",\n  \"Deathmatch\",\n  \"DragonsBane\",\n  \"DragonspineSpear\",\n  \"EngulfingLightning\",\n  \"FavoniusLance\",\n  \"Halberd\",\n  \"IronPoint\",\n  \"KitainCrossSpear\",\n  \"LithicSpear\",\n  \"MissiveWindspear\",\n  \"Moonpiercer\",\n  \"PrimordialJadeWingedSpear\",\n  \"PrototypeStarglitter\",\n  \"RoyalSpear\",\n  \"SkywardSpine\",\n  \"StaffOfHoma\",\n  \"StaffOfTheScarletSands\",\n  \"TheCatch\",\n  \"VortexVanquisher\",\n  \"WavebreakersFin\",\n  \"WhiteTassel\",\n] as const\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\n\nexport const allWeaponBowKeys = [\n  \"AlleyHunter\",\n  \"AmosBow\",\n  \"AquaSimulacra\",\n  \"BlackcliffWarbow\",\n  \"CompoundBow\",\n  \"ElegyForTheEnd\",\n  \"EndOfTheLine\",\n  \"FadingTwilight\",\n  \"FavoniusWarbow\",\n  \"Hamayumi\",\n  \"HuntersBow\",\n  \"HuntersPath\",\n  \"KingsSquire\",\n  \"Messenger\",\n  \"MitternachtsWaltz\",\n  \"MouunsMoon\",\n  \"PolarStar\",\n  \"Predator\",\n  \"PrototypeCrescent\",\n  \"RavenBow\",\n  \"RecurveBow\",\n  \"RoyalBow\",\n  \"Rust\",\n  \"SacrificialBow\",\n  \"SeasonedHuntersBow\",\n  \"SharpshootersOath\",\n  \"SkywardHarp\",\n  \"Slingshot\",\n  \"TheStringless\",\n  \"TheViridescentHunt\",\n  \"ThunderingPulse\",\n  \"WindblumeOde\",\n] as const\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\n\nexport const allWeaponCatalystKeys = [\n  \"ApprenticesNotes\",\n  \"BlackcliffAgate\",\n  \"DodocoTales\",\n  \"EmeraldOrb\",\n  \"EverlastingMoonglow\",\n  \"EyeOfPerception\",\n  \"FavoniusCodex\",\n  \"Frostbearer\",\n  \"FruitOfFulfillment\",\n  \"HakushinRing\",\n  \"KagurasVerity\",\n  \"LostPrayerToTheSacredWinds\",\n  \"MagicGuide\",\n  \"MappaMare\",\n  \"MemoryOfDust\",\n  \"OathswornEye\",\n  \"OtherworldlyStory\",\n  \"PocketGrimoire\",\n  \"PrototypeAmber\",\n  \"RoyalGrimoire\",\n  \"SacrificialFragments\",\n  \"SkywardAtlas\",\n  \"SolarPearl\",\n  \"TheWidsith\",\n  \"ThrillingTalesOfDragonSlayers\",\n  \"TwinNephrite\",\n  \"WanderingEvenstar\",\n  \"WineAndSong\",\n] as const\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"dendro_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type AmpReactionKey = typeof allAmpReactions[number]\nexport type AdditiveReactionKey = typeof allAdditiveReactions[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type InfusionAuraElements = typeof allInfusionAuraElements[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type NonTravelerCharacterKey = typeof nonTravelerCharacterKeys[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type CharacterSheetKey = typeof allCharacterSheetKeys[number]\nexport type LocationCharacterKey = typeof locationCharacterKeys[number]\nexport type TravelerKey = typeof travelerKeys[number]\nexport type TravelerElementKey = typeof travelerElements[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type RollColorKey = typeof allRollColorKeys[number]\nexport type Ascension = typeof allAscension[number]\nexport type Refinement = typeof allRefinement[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: [\"vaporize\", \"melt\"],\n  hydro: [\"vaporize\"],\n  cryo: [\"melt\"],\n  anemo: [\"vaporize\", \"melt\"],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> = {\n  dendro: [\"spread\"],\n  electro: [\"aggravate\"],\n  anemo: [\"aggravate\"],\n}\n\nexport type SubstatType = typeof substatType[number]\n\nexport function charKeyToLocCharKey(charKey: CharacterKey): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return \"Traveler\"\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(key: TravelerKey, element: TravelerElementKey): TravelerKey {\n  return \"Traveler\" + element.toUpperCase().slice(0, 1) + element.slice(1) as TravelerKey\n}\n\nexport type LocationKey = LocationCharacterKey | \"\"\n\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\n  return ck.startsWith(\"Traveler\") ? \"Traveler\" + gender : ck\n}\n","import { ArtSetExclusion } from \"../../../../Database/DataManagers/BuildsettingData\";\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\nimport { allOperations, constantFold, OptNode } from \"../../../../Formula/optimization\";\nimport { ConstantNode } from \"../../../../Formula/type\";\nimport { constant, customRead, max, min, threshold } from \"../../../../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: OptNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: OptNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function pruneExclusion(nodes: OptNode[], exclusion: ArtSetExclusion): OptNode[] {\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\n  for (const [key, e] of Object.entries(exclusion)) {\n    if (!e.includes(4)) continue\n    maxValues[key] = e.includes(2) ? 1 : 3\n  }\n  return mapFormulas(nodes, f => f, f => {\n    if (f.operation !== \"threshold\") return f\n\n    const [v, t, pass, fail] = f.operands\n    if (v.operation === \"read\" && t.operation === \"const\") {\n      const key = v.path[v.path.length - 1], thres = t.value\n      if (key in maxValues) {\n        const max: number = maxValues[key]\n        if (max < thres) return fail\n        if (thres === 2 && exclusion[key]!.includes(2))\n          return threshold(v, 4, pass, fail)\n      }\n    }\n    return f\n  })\n}\n\nexport function reaffine(nodes: OptNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: OptNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<OptNode>(), topLevelAffine = new Set<OptNode>()\n\n  function visit(node: OptNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(op => affineNodes.has(op) && topLevelAffine.add(op))\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\": visit(f, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\n    Object.keys(arts.base).length === dynKeys.size)\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nfunction pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\n  let progress = false\n  const noRainbow = !exclusion.rainbow?.length\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: OptNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    {\n      const { min, max } = nodeRange.get(f)!\n      if (min === max) return constant(min)\n    }\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return f.operands[3]\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter(key => arts.every(art => art.values[key]))\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  return addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n}\nexport function computeNodeRange(nodes: OptNode[], reads: DynMinMax): Map<OptNode, MinMax> {\n  const range = new Map<OptNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = operands[3]\n        else current = computeMinMax([], [operands[2], operands[3]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\nexport function filterArtsVec(arts: ArtifactsBySlotVec, filters: RequestFilter): ArtifactsBySlotVec {\n  return {\n    keys: arts.keys, base: arts.base, baseBuffer: arts.baseBuffer,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\nexport function filterArts2(arts: ArtifactsBySlot, filterVec: StrictDict<SlotKey, number[]>): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filterIxs = filterVec[slot]\n      const slotVals = arts.values[slot]\n      return filterIxs.map(ix => slotVals[ix])\n    })\n  }\n}\nexport function filterArtsVec2(arts: ArtifactsBySlotVec, filterVec: StrictDict<SlotKey, number[]>): ArtifactsBySlotVec {\n  return {\n    keys: arts.keys, base: arts.base, baseBuffer: arts.baseBuffer,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filterIxs = filterVec[slot]\n      const slotVals = arts.values[slot]\n      return filterIxs.map(ix => slotVals[ix])\n    })\n  }\n}\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n\n\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\n        case \"id\": break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\n  return new Set(exclusion?.includes(2)\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length))\n        shapes.push(current)\n      return\n    }\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\n      return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\n        shape[replacing] = 5\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\n\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set()\n    let groupped: number[][] = [], rainbows: number[] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length)\n        return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set], count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find(x => x > count)! - count\n          missing.push(set)\n        }\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport const emptyfilter: RequestFilter = objectKeyMap(allSlotKeys, _ => ({ kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }));\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\n\n\nexport type ArtifactBuildDataVecDense = {\n  id: string\n  set?: ArtifactSetKey\n  values: number[]\n  buffer: number[]\n}\n// I dont *think* its worth it to implement sparse vectors n shit\n// export type ArtifactBuildDataVecSparse = {\n//   id: string\n//   set?: ArtifactSetKey\n//   values: number[][]\n// }\nexport type ArtifactsBySlotVec = { keys: string[], base: number[], values: StrictDict<SlotKey, ArtifactBuildDataVecDense[]>, baseBuffer: number[] }\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n\nexport type DynMinMax = { [key in string]: MinMax }\nexport type MinMax = { min: number, max: number }\n","import { sum, prod, hashNode, cmpNode } from \"./utils\"\nimport { ConstantNode, NumNode } from \"./type\"\nimport { allArtifactSets } from \"../Types/consts\"\nimport { cartesian } from '../Util/Util'\nimport { forEachNodes } from \"./internal\"\nimport { makeid } from \"./optimize2\"\nimport { DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { OptNode } from \"./optimization\"\n\nfunction countSlotUsage(node: NumNode): DynStat {\n  if (node.operation === 'add') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => {\n      Object.entries(b).forEach(([slotKey, n]) => a[slotKey] = Math.min(n, a[slotKey] ?? 0))\n      return a\n    }, {})\n  }\n  else if (node.operation === 'mul') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => {\n      Object.entries(b).forEach(([slotKey, n]) => a[slotKey] = Math.max(n, a[slotKey] ?? 0))\n      return a\n    }, {})\n  }\n  else if (node.operation === 'threshold') {\n    const branch = node.operands[0]\n    if (branch.operation === 'read' && (allArtifactSets as readonly string[]).includes(branch.path[1])) {\n      let con = node.operands[1] as ConstantNode<number>\n      return { [branch.path[1]]: con.value }\n    }\n  }\n  return {}\n}\n\nfunction filterProductPossible({ terms, nodes }: ExpandedPolynomial, slotsLeft = 5) {\n  let sCount = Object.fromEntries(Object.entries(nodes).map(([tag, n]) => [tag, countSlotUsage(n)]))\n\n  terms = terms.filter(({ terms }) => {\n    const slotUsage = terms.reduce((tot, s) => {\n      Object.entries(sCount[s]).forEach(([slotKey, n]) => tot[slotKey] = Math.max(n, tot[slotKey] ?? 0))\n      return tot\n    }, {} as DynStat)\n    return Object.values(slotUsage).reduce((a, b) => a + b, 0) <= slotsLeft\n  })\n  return { terms, nodes }\n}\n\nexport type Monomial = {\n  coeff: number,\n  terms: string[]\n}\nexport type ExpandedPolynomial = {\n  terms: Monomial[],\n  nodes: Dict<string, OptNode>,\n}\n\nexport function sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nexport function prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map(monos => monos.reduce((ret, nxt) => {\n    ret.coeff *= nxt.coeff\n    ret.terms.push(...nxt.terms)\n    return ret\n  }, { coeff: 1, terms: [] }))\n}\nexport function constantM(v: number): Monomial[] {\n  return [{ coeff: v, terms: [] }]\n}\nexport function readM(tag: string): Monomial[] {\n  return [{ coeff: 1, terms: [tag] }]\n}\n\nexport function foldLikeTerms(mono: Monomial[]): Monomial[] {\n  let mon = [...mono]\n  mon.forEach(m => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : 1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    let a = mon[i].terms\n    let b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].coeff = (mon[i].coeff ?? 0) + (mon[i + 1].coeff ?? 0)\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\n\n/**\n * Factors damage formula into sums of monomials in each variable.\n * For example:  (1700 * atk_ + atk) * (1 + cr * cd) * (1 + sum_frac(EM))\n *   -> 1700 * atk_ + 1700 * atk_ * cr * cd + 1700 * atk_ * sum_frac(EM) + 1700 * atk_ * cr * cd * sum_frac(EM)\n *            + atk +         atk * cr * cd +         atk * sum_frac(EM) +         atk * cr * cd * sum_frac(EM)\n *\n * For a total of 8 terms, since there are 3 pairs of additions, for 2^3 sum-of-product terms.\n *\n * isVar() is used to check whether any node should be considered a variable on its own.\n */\ntype NodeLinkedList = { n: NumNode, tag: string, next: NodeLinkedList | undefined }\nexport function expandPoly(node: OptNode, inheritTags?: string[]): ExpandedPolynomial {\n  let varMap = {} as Dict<number, NodeLinkedList> // my shitty hashmap\n  let tagMap = {} as Dict<string, OptNode>\n  const varTags = inheritTags ?? []\n  function lookup(n: OptNode) {\n    let hsh = hashNode(n)\n    let z = varMap[hsh]\n    while (z !== undefined) {\n      if (cmpNode(z.n, n)) return z.tag\n      z = z.next\n    }\n    const newTag = makeid(10, varTags)\n    varMap[hsh] = { n, tag: newTag, next: varMap[hsh] }\n    tagMap[newTag] = n\n    varTags.push(newTag)\n    return newTag\n  }\n\n  let stat2tag = {} as Dict<string, string>\n  forEachNodes([node], _ => { }, n => {\n    if (n.operation === 'read') stat2tag[n.path[1]] = lookup(n)\n  })\n\n  function toSOP(n: OptNode): Monomial[] {\n    switch (n.operation) {\n      case 'add':\n        return sumM(...n.operands.map(toSOP))\n      case 'mul':\n        return prodM(...n.operands.map(toSOP))\n      case 'const':\n        return constantM(n.value)\n      default:\n        return readM(lookup(n))\n    }\n  }\n\n  // let sop = toSOP(node)\n  let sop = foldLikeTerms(toSOP(node))\n  return filterProductPossible({\n    terms: sop,\n    nodes: tagMap,\n  })\n}\n\n// Really should avoid using this function ever\nexport function toNumNode({ nodes, terms }: ExpandedPolynomial) {\n  return sum(...terms.map(({ coeff, terms }) => prod(coeff, ...terms.map(t => nodes[t]!))))\n}\n","function pivotInplace(A: number[][], { i, j }: { i: number, j: number }) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= A[i][k] * A[h][j] / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\nfunction findPiv1(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= 0) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > 1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\nfunction findPiv2(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= 0) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\nfunction backtrack(tableau: number[][], ijTrack: { i: number, j: number }[], targ: number) {\n  let side = 1;  // 0 left, 1 right\n  ijTrack.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    }\n    else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to:\n *   https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* a problem for GO's use\n *   case. This algorithm is fairly numerically unstable though, use with care & always\n *   try to verify the solution. It's also a fair bit slower than it needs to be.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        the optimal solution x\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  let rows = Ab.length + 1\n  let cols = Ab[0].length\n\n  let tableau = Array(rows).fill(0).map(_ => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => tableau[i][j] = Aij))\n  // b.forEach((bi, i) => tableau[i][cols - 1] = bi)\n  c.forEach((cj, j) => tableau[rows - 1][j] = cj)\n  // console.log('tab', tableau)\n\n  let ijTrack: { i: number, j: number }[] = []\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < 0)) {\n    const ij = findPiv2(tableau)\n    ijTrack.push(ij)\n    // tableau = pivot(tableau, ij)\n    pivotInplace(tableau, ij)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < 0)) {\n    const ij = findPiv1(tableau)\n    ijTrack.push(ij)\n    // tableau = pivot(tableau, ij)\n    pivotInplace(tableau, ij)\n  }\n\n  return c.map((_, i) => backtrack(tableau, ijTrack, i))\n}\n","import { ArtifactsBySlot, ArtifactsBySlotVec, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { constant, sum, prod, threshold } from \"./utils\"\nimport { ExpandedPolynomial, Monomial, sumM, prodM, constantM, readM, foldLikeTerms } from './expandPoly'\nimport { precompute, allOperations, OptNode } from \"./optimization\"\nimport { solveLP } from './solveLP_simplex'\nimport { cartesian } from '../Util/Util'\n\nexport type LinearForm = {\n  w: DynStat,\n  c: number,\n  err: number\n}\nexport type LinearFormVec = {\n  w: number[],\n  c: number,\n  err: number\n}\n\nfunction minMax(node: OptNode, lower: DynStat, upper: DynStat) {\n  const compute = precompute([node], {}, n => n.path[1], 1)\n  const minval = compute([{ id: '', values: lower }])[0]\n  const maxval = compute([{ id: '', values: upper }])[0]\n  return [minval, maxval]\n}\n\n/**\n * `res` is the ONE place where negative arguments & negative slopes are allowed.\n * @param node\n */\nfunction handleResArg(node: OptNode, lower: DynStat, upper: DynStat) {\n  function flipOps(n: OptNode): OptNode {\n    switch (n.operation) {\n      case 'add':\n        return sum(...n.operands.map(n => flipOps(n)))\n      case 'const':\n        return constant(-n.value)\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (ge.operation === 'const' && lt.operation === 'const') {\n          if (ge.value <= lt.value) {\n            return threshold(branch, bval, -ge.value, -lt.value)\n          }\n        }\n        console.log(n)\n        throw Error('(res neg slope): threshold. Something went wrong.')\n      default:\n        console.log(n)\n        throw Error('(res neg slope) Havent written logic to handle this')\n    }\n  }\n\n  const flippedResOp = flipOps(node.operands[0]!)\n\n  let [a, b] = minMax(flippedResOp, lower, upper)\n  let resf = allOperations['res']\n  let [c, d] = [resf([-a]), resf([-b])]\n\n  if (b > 0 && a > -1.75) {\n    // 1 + x / 2\n    return sum(1, prod(.5, flippedResOp))\n  }\n\n  const intercept = (b * c - a * d) / (b - a)\n  const slope = (c - d) / (b - a)\n  return sum(intercept, prod(slope, flippedResOp))\n}\n\n/**\n * First converts a product of variables (including max, min, sum_frac, threshold, etc.) to\n *   a pure product form consisting of only `read` and `const` nodes, guaranteeing the\n *   product form is an upper bound.\n *\n * Then on the product form, create a linear upper bound using `lub` and return it.\n *\n * @param node The formula to expand\n * @param lower Stat lower bounds\n * @param upper Stat upper bounds\n * @returns\n */\nexport function toLinearUpperBound({ nodes, terms }: ExpandedPolynomial, lower: DynStat, upper: DynStat): LinearForm {\n  let stat2tag = {} as Dict<string, string>\n  Object.entries(nodes).forEach(([tag, n]) => {\n    if (n.operation === 'read') stat2tag[n.path[1]] = tag\n  })\n\n  let linerr = 0\n  function toPureRead(n: OptNode): Monomial[] {\n    switch (n.operation) {\n      case 'const':\n        return constantM(n.value)\n      case 'read':\n        return readM(stat2tag[n.path[1]]!)\n      case 'add':\n        return sumM(...n.operands.map(toPureRead))\n      case 'mul':\n        return prodM(...n.operands.map(toPureRead))\n\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (branch.operation === 'read' && bval.operation === 'const'\n          && lt.operation === 'const' && ge.operation === 'const') {\n          if (ge.value < lt.value) {\n            console.log(n)\n            throw Error('Not Implemented (threshold must be increasing)')\n          }\n\n          let key = branch.path[1]\n          if (lower[key] >= bval.value) return constantM(ge.value)\n          if (upper[key] < bval.value) return constantM(lt.value)\n\n          const slope = (ge.value - lt.value) / (bval.value - lower[key])\n          const mon1 = prodM(constantM(slope), readM(stat2tag[branch.path[1]]!))\n\n          const intercept = lt.value - slope * lower[key]\n          if (intercept === 0) return mon1\n          return sumM(constantM(intercept), mon1)\n          // if (lt.value === 0) return mon1\n          // return sumM(constantM(lt.value), mon1)\n        }\n        console.log(n)\n        throw Error('Not Implemented (threshold must branch between constants)')\n      case 'res':\n        let op = handleResArg(n, lower, upper)\n        return toPureRead(op)\n\n      case 'min': case 'max':\n        let [rop, cop] = n.operands\n        if (cop.operation !== 'const')\n          [rop, cop] = [cop, rop]  // Assume min(const, read)\n        if (n.operation === 'min') return toPureRead(rop)\n\n        if (cop.operation === 'const') {\n          const thresh = cop.value\n          const [minVal, maxVal] = minMax(rop, lower, upper)\n          if (minVal > thresh) return toPureRead(rop)\n          if (thresh > maxVal) return constantM(thresh)\n\n          // rescale `rop` to be above thresh, since max(f, 0) is a convex function\n          const m = (maxVal - thresh) / (maxVal - minVal)\n          const b = thresh - m * minVal\n          return sumM(constantM(b), prodM(constantM(m), toPureRead(rop)))\n        }\n        console.log(n)\n        throw Error('Not Implemented (max between two non-constants)')\n\n      case 'sum_frac':\n        const [em, denom] = n.operands\n        if (denom.operation !== 'const') throw Error('Not Implemented (non-constant sum_frac denominator)')\n\n        const [minEM, maxEM] = minMax(em, lower, upper)\n        const k = denom.value\n        // The sum_frac form is concave, so any Taylor expansion of EM / (EM + k) gives an upper bound.\n        // We can solve for the best Taylor approximation location with the following formula.\n        let loc = Math.sqrt((minEM + k) * (maxEM + k)) - k\n        let below = (k + loc) * (k + loc)\n        let slope = k / below\n        let c = loc * loc / below\n\n        // TODO: update linerr\n        return sumM(constantM(c), prodM(constantM(slope), toPureRead(em)))\n\n      default:\n        console.log(n)\n        throw Error('Not Implemented')\n    }\n  }\n\n  // 1. Turn all nodes into linear upper bounds\n  const nodesToMap = Object.fromEntries(Object.entries(nodes).filter(([tag, n]) => n.operation !== 'read').map(([tag, n]) => [tag, toPureRead(n)]))\n\n  // 2. substitute into `terms` and construct a new SOPForm whose nodes are all pure read nodes\n  let t2 = terms.flatMap(({ coeff, terms }) => prodM(constantM(coeff), ...terms.map(t => nodesToMap[t] ?? readM(t))))\n  t2 = foldLikeTerms(t2)\n\n  // 2.5 Re-name all the tags to their read node version\n  t2 = t2.map(({ coeff, terms }) => {\n    terms = terms.map(t => {\n      const nt = nodes[t]\n      if (!nt || nt.operation !== 'read') throw Error('MUST be a read node.')\n      return nt.path[1]\n    })\n    return { coeff, terms }\n  })\n\n  // 3. call lub() on each term\n  const lins = t2.map(({ coeff, terms }) => {\n    if (terms.length === 0) return { w: {}, c: coeff, err: 0 }\n    if (terms.length === 1) return { w: { [terms[0]]: coeff }, c: 0, err: 0 }\n    const { w, c, err } = lub(terms.map(k => ({ lower: lower[k], upper: upper[k] })))\n    const retw = w.reduce((ret, wi, i) => {\n      ret[terms[i]] = wi * coeff + (ret[terms[i]] ?? 0)\n      return ret\n    }, {} as DynStat)\n    return { w: retw, c: coeff * c, err: coeff * err + linerr }\n  })\n\n  return lins.reduce((lin, l) => {\n    lin.c += l.c; lin.err += l.err\n    Object.entries(l.w).forEach(([k, v]) => lin.w[k] = v + (lin.w[k] ?? 0))\n    return lin\n  }, { w: {}, c: 0, err: 0 })\n}\n\n/**\n * Constructs an upper bounding linear form for a function x_1 * x_2 * ... * x_n\n * @param bounds upper and lower bounds for each x_i\n * @returns { w, c, err } with\n */\nfunction lub(bounds: { lower: number, upper: number }[]): { w: number[], c: number, err: number } {\n  if (bounds.length === 0) return { w: [], c: 0, err: 0 }\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ upper }) => upper)\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ lower, upper }) => ({ lower: lower / upper, upper: 1 }))\n\n  // Setting up the linear program in terms of constraints.\n  // cartesian(bounds) loops 2^n times\n  let cons = cartesian(...bounds.map(({ lower, upper }) => [lower, upper])).flatMap((coords) => {\n    const prod = coords.reduce((prod, v) => prod * v, 1)\n    return [\n      [...coords.map(v => -v), 1, 0, -prod],\n      [...coords, -1, -1, prod],\n    ]\n  })\n\n  // Force equality at upper & lower corners?\n  // cons.push([...bounds.map(lu => lu.lower), -1, 0, bounds.reduce((prod, { lower }) => prod * lower, 1)])\n  // cons.push([...bounds.map(lu => lu.upper), -1, 0, bounds.reduce((prod, { upper }) => prod * upper, 1)])\n\n  let soln: any\n  const objective = [...bounds.map(_ => 0), 0, 1]\n  try {\n    // TODO: verify solution\n    soln = solveLP(objective, cons)\n  }\n  catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    throw e\n  }\n  return {\n    w: soln.slice(0, nVar).map((wi, i) => wi * scaleProd / boundScale[i]),\n    c: -scaleProd * soln[nVar],\n    err: scaleProd * soln[nVar + 1]\n  }\n}\n\nexport function maxWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmulMax([lin], [a.base])[0] + lin.c\n\n  return baseVal + Object.entries(a.values)\n    .reduce((maxTotVal, [slotKey, slotArts]) => maxTotVal + sparseMatmulMax([lin], slotArts.map(a => a.values))[0], 0)\n}\nexport function minWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmulMin([lin], [a.base])[0] + lin.c\n\n  return baseVal + Object.entries(a.values)\n    .reduce((minTotVal, [slotKey, slotArts]) => minTotVal + sparseMatmulMin([lin], slotArts.map(a => a.values))[0], 0)\n}\n\nexport function maxWeightVec(a: ArtifactsBySlotVec, lin: LinearForm) {\n  const ixs: number[] = []\n  const w: number[] = []\n  Object.entries(lin.w).forEach(([k, ww]) => {\n    ixs.push(a.keys.indexOf(k))\n    w.push(ww)\n  })\n\n  const baseVal = ixs.reduce((accum, ix, i) => accum + a.base[ix] * w[i], lin.c)\n  return Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.max(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n}\nexport function minMaxWeightVec(a: ArtifactsBySlotVec, lin: LinearForm) {\n  const ixs: number[] = []\n  const w: number[] = []\n  Object.entries(lin.w).forEach(([k, ww]) => {\n    ixs.push(a.keys.indexOf(k))\n    w.push(ww)\n  })\n\n  const baseVal = ixs.reduce((accum, ix, i) => accum + a.base[ix] * w[i], lin.c)\n  const maxw = Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.max(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n\n  const minw = Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.min(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n  return { minw, maxw }\n}\n\n\n\n// Implement matrix multiply between row-major w's of LinearForm and col-major DynStats that represent artifacts.\n/**\n * Implements sparse matrix multiplication between A and x\n * @param A A list of row-major w's of some LinearForm\n * @param x A list of col-major DynStats that represent some artifacts\n * @returns A col-major 2d array number[][] with shape (A.length, x.length).\n *          ret[0] is [A1 @ x1, A2 @ x1, ..., An @ x1]\n */\nexport function sparseMatmul(A: LinearForm[], x: DynStat[]) {\n  return x.map(dyn => A.map(({ w }) => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0)))\n}\n\n/**\n * Sparse matrix multiplication between A and x, followed by a max() along the rows.\n */\nexport function sparseMatmulMax(A: LinearForm[], x: DynStat[]) {\n  return A.map(({ w }) => Math.max(...x.map(dyn => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0))))\n}\n\n/**\n * Sparse matrix multiplication between A and x, followed by a min() along the rows.\n */\nexport function sparseMatmulMin(A: LinearForm[], x: DynStat[]) {\n  return A.map(({ w }) => Math.min(...x.map(dyn => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0))))\n}\n","import { constant, sum, prod, threshold } from \"./utils\"\nimport { allOperations } from \"./optimization\"\nimport { mapFormulas } from \"./internal\"\nimport { ArtifactBuildData, ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { LinearForm, maxWeight, toLinearUpperBound } from \"./linearUpperBound\"\nimport { foldLikeTerms, ExpandedPolynomial } from \"./expandPoly\"\nimport { ArtifactSetKey } from \"../Types/consts\"\nimport { OptNode } from \"./optimization\"\nimport { ArtSetExclusion } from \"../Database/DataManagers/BuildsettingData\"\n\nexport function foldSum(nodes: readonly OptNode[]) {\n  if (nodes.length === 1) return nodes[0]\n  nodes = nodes.flatMap(n => n.operation === 'add' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv + n.value : pv, 0)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 0) {\n    if (nodes.length === 1) return nodes[0]\n    return sum(...nodes)\n  }\n  return sum(...nodes, constant(constVal))\n}\n\nexport function foldProd(nodes: readonly OptNode[]) {\n  if (nodes.length === 1) return nodes[0]\n  nodes = nodes.flatMap(n => n.operation === 'mul' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv * n.value : pv, 1)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 1) return prod(...nodes)\n  return prod(...nodes, constant(constVal))\n}\n\nexport function slotUpperLower(a: ArtifactBuildData[]) {\n  if (a.length === 0) return { statsMin: {}, statsMax: {} }\n  // Assume keys are the same for all artifacts.\n  const keys = Object.keys(a[0].values)\n  let statsMin: DynStat = {}\n  let statsMax: DynStat = {}\n  let sets = new Set<ArtifactSetKey>()\n  keys.forEach(k => {\n    statsMin[k] = Infinity\n    statsMax[k] = -Infinity\n  })\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < keys.length; j++) {\n      const k = keys[j]\n      statsMin[k] = Math.min(a[i].values[k], statsMin[k])\n      statsMax[k] = Math.max(a[i].values[k], statsMax[k])\n    }\n    if (a[i].set) sets.add(a[i].set!)\n  }\n  sets.forEach(set => {\n    statsMax[set] = 1\n    statsMin[set] = 0\n  })\n  if (sets.size === 1) {\n    const [s] = sets\n    statsMin[s] = 1\n  }\n  return { statsMin, statsMax }\n}\n\nexport function statsUpperLower(a: ArtifactsBySlot) {\n  let statsMin: DynStat = { ...a.base }\n  let statsMax: DynStat = { ...a.base }\n  Object.entries(a.values).forEach(([slotKey, slotArts]) => {\n    const { statsMin: smin, statsMax: smax } = slotUpperLower(slotArts)\n    Object.keys(smin).forEach(sk => {\n      statsMin[sk] = smin[sk] + (statsMin[sk] ?? 0)\n      statsMax[sk] = smax[sk] + (statsMax[sk] ?? 0)\n    })\n  })\n  return { statsMin, statsMax }\n}\n\nexport function reduceFormula(f: OptNode[], lower: DynStat, upper: DynStat) {\n  const fixedStats = Object.keys(lower).filter(statKey => lower[statKey] === upper[statKey])\n  let f2 = mapFormulas(f, n => n, n => {\n    switch (n.operation) {\n      case 'add':\n        return foldSum(n.operands)\n      case 'mul':\n        return foldProd(n.operands)\n\n      case 'read':\n        if (fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n        return n\n      case 'threshold':\n        const [branch, branchVal, ge, lt] = n.operands\n        if (branch.operation === 'const' && branchVal.operation === 'const')\n          return branch.value >= branchVal.value ? ge : lt\n        if (branch.operation === 'read' && branchVal.operation === 'const') {\n          if (lower[branch.path[1]] >= branchVal.value) return ge\n          if (upper[branch.path[1]] < branchVal.value) return lt\n        }\n        return n\n      case 'min': case 'max':\n      case 'res': case 'sum_frac':\n        if (n.operands.every(ni => ni.operation === 'const')) {\n          const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n          return constant(out)\n        }\n        return n\n      default:\n        return n\n    }\n  })\n\n  return f2\n}\n\nexport function reducePolynomial(f: ExpandedPolynomial[], lower: DynStat, upper: DynStat): ExpandedPolynomial[] {\n  const fixedStats = Object.keys(lower).filter(statKey => Math.abs(lower[statKey] - upper[statKey]) < 1e-6)\n  return f.map(({ nodes, terms }) => {\n    // 1. Reduce nodes by substituting constants\n    const tagNodePairs = Object.entries(nodes)\n    const reducedNodes = mapFormulas(tagNodePairs.map(([k, v]) => v), n => n, n => {\n      switch (n.operation) {\n        case 'read':\n          if (fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n          return n\n        case 'threshold':\n          const [branch, branchVal, ge, lt] = n.operands\n          if (branch.operation === 'const' && branchVal.operation === 'const')\n            return branch.value >= branchVal.value ? ge : lt\n          if (branch.operation === 'read' && branchVal.operation === 'const') {\n            if (lower[branch.path[1]] >= branchVal.value) return ge\n            if (upper[branch.path[1]] < branchVal.value) return lt\n          }\n          else throw Error('Branch between non-read and non-const!!!')\n          return n\n        case 'add':\n          return foldSum(n.operands)\n        case 'mul':\n          return foldProd(n.operands)\n        case 'res': case 'sum_frac':\n          if (n.operands.every(ni => ni.operation === 'const')) {\n            const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n            return constant(out)\n          }\n          return n\n        case 'min': case 'max':\n          // TODO: reduce min & max\n          if (n.operands.every(ni => ni.operation === 'const')) {\n            const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n            return constant(out)\n          }\n          return n\n        default:\n          return n\n      }\n    })\n\n    // 2a. Find all the nodes that have been reduced to constants\n    let tagsToKill = {} as Dict<string, number>\n    reducedNodes.forEach((n, i) => {\n      if (n.operation !== 'const') return\n      const [tag] = tagNodePairs[i]\n      tagsToKill[tag] = n.value\n    })\n\n    // 2b. Substitute the constant nodes in where possible\n    let newTerms = terms.map(mon => {\n      let c = mon.coeff\n      const newTerms = mon.terms.filter(t => {\n        if (tagsToKill[t] !== undefined) {\n          c *= tagsToKill[t]!\n          return false\n        }\n        return true\n      })\n      if (c === 0) return { coeff: 0, terms: [] }\n      return { coeff: c, terms: newTerms }\n    })\n\n    // 3. Delete all the constant tags & add like terms together\n    let newNodes = Object.fromEntries(reducedNodes.map((n, i) => [tagNodePairs[i][0], n]))\n    Object.keys(tagsToKill).forEach(t => delete newNodes[t])\n    return { nodes: newNodes, terms: foldLikeTerms(newTerms) }\n  })\n}\n\n/**\n * Estimates maximum value across an array of formulas\n * @param f              Functions to maximize\n * @param a              Artifact set\n * @param cachedCompute  Optional Prior cached compute. If specified, will re-calculate `maxEst` assuming `lin, lower, upper` are correct.\n * @returns              CachedCompute\n */\ntype MaxEstQuery2 = { f: ExpandedPolynomial[], a: ArtifactsBySlot, cachedCompute: { lower: DynStat, upper: DynStat } }\n  | { f?: undefined, cachedCompute: { lin: LinearForm[], lower: DynStat, upper: DynStat }, a: ArtifactsBySlot }\nexport function estimateMaximum({ f, a, cachedCompute }: MaxEstQuery2) {\n  if (f === undefined) {\n    return { maxEst: cachedCompute.lin.map(l => maxWeight(a, l)), ...cachedCompute }\n  }\n\n  const { lower, upper } = cachedCompute\n  const est = f.map(fi => {\n    const lin = toLinearUpperBound(fi, lower, upper)\n    return { maxEst: maxWeight(a, lin), lin }\n  })\n\n  return {\n    maxEst: est.map(({ maxEst }) => maxEst),\n    lin: est.map(({ lin }) => lin),\n    lower, upper\n  }\n}\n\nexport function fillBuffer(stats: DynStat, mapping: Dict<string, number>, buffer: Float64Array) {\n  Object.entries(stats)\n    .filter(([k]) => mapping[k] !== undefined)\n    .forEach(([k, v]) => buffer[mapping[k]!] = v)\n}\n\nexport function thresholdExclusions(nodes: OptNode[], excl: ArtSetExclusion) {\n  nodes = mapFormulas(nodes, n => n, n => {\n    switch (n.operation) {\n      case 'threshold':\n        const [branch, branchVal, ge, lt] = n.operands\n        if (branch.operation === 'read' && branchVal.operation === 'const') {\n          const key = branch.path[1] as ArtifactSetKey\n          if (excl[key] !== undefined) {\n            const exc = excl[key] as (2 | 4)[]\n            // Based on exclusion, either return `lt` or shift `branchVal` to 4.\n            if (branchVal.value === 2 && exc.includes(2)) {\n              if (exc.includes(4)) return lt\n              return threshold(branch, 4, ge, lt)\n            }\n            if (branchVal.value === 4 && exc.includes(4))\n              return lt\n          }\n        }\n        return n\n      default:\n        return n\n    }\n  })\n  return nodes\n}\n","import { ArtSetExclusion } from \"../../../../Database/DataManagers/BuildsettingData\"\nimport { reducePolynomial } from \"../../../../Formula/addedUtils\"\nimport { ExpandedPolynomial, expandPoly, toNumNode } from \"../../../../Formula/expandPoly\"\nimport { LinearForm, minMaxWeightVec, toLinearUpperBound } from \"../../../../Formula/linearUpperBound\"\nimport { OptNode, precompute } from \"../../../../Formula/optimization\"\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\"\nimport { objectKeyMap, objectKeyValueMap, range } from \"../../../../Util/Util\"\nimport { ArtifactBuildDataVecDense, ArtifactsBySlot, ArtifactsBySlotVec, DynStat, filterArtsVec2, RequestFilter } from \"./common\"\n\nexport type UnionFilter = {\n  uType: true\n  filters: StrictDict<SlotKey, { kind: \"id\", ids: Set<string> }>[]\n} | (RequestFilter & { uType: false })\n\nexport type RequestFilter2 = {\n  // filter: StrictDict<SlotKey, { kind: \"id\", ids: Set<string> }>,\n  filterVec: StrictDict<SlotKey, number[]>,  // dict of list of indices (for some particular ArtifactsBySetVec)\n  lower: number[],  // length `k` list of lower bound stats\n  upper: number[],  // length `k` list of upper bound stats\n  minw: number[],   // length `l` list of minimum upper bound estimates\n  maxw: number[],   // length `l` list of maximum upper bound weights\n}\nexport type UnionFilter2 = RequestFilter2[]\nexport type ArtSetExclusionFull = Dict<Exclude<ArtifactSetKey, \"PrayersForDestiny\" | \"PrayersForIllumination\" | \"PrayersForWisdom\" | \"PrayersToSpringtime\"> | \"uniqueKey\", number[]>\n// export type SubProblem = SubProblemNC | SubProblemWC\nexport type SubProblem = SubProblemWC\nexport type SubProblemNC = {\n  cache: false,\n  optimizationTarget: ExpandedPolynomial,\n  constraints: { value: ExpandedPolynomial, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filters: UnionFilter2,\n  depth: number,\n}\nexport type SubProblemWC = {\n  cache: true,\n  optimizationTarget: ExpandedPolynomial,\n  constraints: { value: ExpandedPolynomial, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filters: UnionFilter2,\n  lin: LinearForm[],\n  // cachedCompute: CachedCompute,\n  depth: number,\n}\nexport type CachedCompute = {\n  maxEst: number[],\n  lin: LinearForm[],\n  lower: DynStat,\n  upper: DynStat\n}\n\nexport function countBuildsU(f: UnionFilter2): number {\n  return f.reduce((tot, { filterVec }) => tot + allSlotKeys.reduce((_count, slot) => _count * filterVec[slot].length, 1), 0)\n}\n\nexport function unionFilterUpperLower(f: UnionFilter2) {\n  const lower = [...f[0].lower]\n  const upper = [...f[0].upper]\n  const minw = [...f[0].minw]\n  const maxw = [...f[0].maxw]\n\n  for (let i = 1; i < f.length; i++) {\n    for (let j = 0; j < lower.length; j++) {\n      lower[j] = Math.min(lower[j], f[i].lower[j])\n      upper[j] = Math.max(upper[j], f[i].upper[j])\n    }\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], f[i].minw[j])\n      maxw[j] = Math.max(maxw[j], f[i].maxw[j])\n    }\n  }\n\n  return { lower, upper, minw, maxw }\n}\n\nexport function applyLinearForm(arts: ArtifactsBySlotVec, lin: LinearForm[]) {\n  const wixs: number[][] = []\n  const ws: number[][] = []\n  const baseC: number[] = []\n  lin.forEach(li => {\n    const ixs0: number[] = []\n    const w0: number[] = []\n    Object.entries(li.w).forEach(([k, w]) => {\n      ixs0.push(arts.keys.indexOf(k))\n      w0.push(w)\n    })\n    wixs.push(ixs0)\n    ws.push(w0)\n\n    baseC.push(ixs0.reduce((accum, ix, i) => accum + arts.base[ix] * w0[i], li.c))\n  })\n\n  arts.baseBuffer = baseC\n  allSlotKeys.forEach(slotKey => arts.values[slotKey].forEach(art =>\n    art.buffer = wixs.map((ixsi, i) => ixsi.reduce((accum, ix, j) => accum + art.values[ix] * ws[i][j], 0))\n  ))\n}\n\nexport function reduceSubProblem(arts: ArtifactsBySlotVec, threshold: number, subp: SubProblem): SubProblemWC | undefined {\n  const { optimizationTarget, constraints, artSetExclusion, depth } = subp\n  let { filters } = subp\n  let nodes = [...constraints.map(({ value }) => value), optimizationTarget]\n  const mins = constraints.map(({ min }) => min)\n\n  // 0. Check for never-feasible constraints\n  filters = filters.filter(({ maxw }) => {\n    if (mins.some((min, j) => maxw[j] < min)) return false\n    if (maxw[mins.length] < threshold) return false\n    return true\n  })\n  if (filters.length === 0) return undefined\n\n  // 0b. Calculate stat bounding box\n  const { lower, upper } = unionFilterUpperLower(filters)\n  const statsMin: DynStat = Object.fromEntries(arts.keys.map((k, i) => ([k, lower[i]])))\n  const statsMax: DynStat = Object.fromEntries(arts.keys.map((k, i) => ([k, upper[i]])))\n\n  nodes = reducePolynomial(nodes, statsMin, statsMax)\n\n  // 1. Check for always-feasible constraints.\n  const compute = precompute(constraints.map(({ value }) => toNumNode(value)), {}, n => n.path[1], 1)\n  const result = compute([{ id: '', values: statsMin }])\n\n  const active = mins.map((m, i) => m > result[i])\n\n  const newOptTarget = nodes.pop()!\n  const newConstraints = nodes.map((value, i) => ({ value, min: mins[i] })).filter((_, i) => active[i])\n  const newMins = newConstraints.map(({ min }) => min)\n\n  // 2. Check for never-active and always-active ArtSetExcl constraints.\n  const newArtExcl = {} as ArtSetExclusionFull\n  for (const [setKey, exclude] of Object.entries(artSetExclusion)) {\n    if (setKey === 'uniqueKey') {\n      // TODO: Check and exclude rainbow bullshit.\n      newArtExcl[setKey] = exclude\n      const feasibleKeys = allArtifactSets.filter(setKey => statsMax[setKey] > 0)\n      let feasible4sets = 0\n      let feasible2sets = 0\n      feasibleKeys.forEach(k => {\n        let allowedCnts = range(statsMin[k], statsMax[k])\n        if (artSetExclusion[k])\n          allowedCnts = allowedCnts.filter(cnt => !artSetExclusion[k].includes(cnt))\n\n        if (allowedCnts.includes(4) || allowedCnts.includes(5)) feasible4sets++\n        if (allowedCnts.includes(2) || allowedCnts.includes(3)) feasible2sets++\n      })\n\n      if (exclude.includes(5) && feasible4sets === 0) {\n        if (feasible2sets === 0) return; // No feasible 4sets or 2sets along with rainbow5 excluded is never satisfiable\n        if (exclude.includes(3) && feasible2sets < 2) return; // No 4sets, rainbow5 excluded, rainbow3 excluded means we need at least 2 2sets\n      }\n      continue\n    }\n    const reducedExcl = exclude.filter(n => statsMin[setKey] <= n && n <= statsMax[setKey])        // Cut away never-active\n    if (reducedExcl.includes(statsMin[setKey]) && reducedExcl.includes(statsMax[setKey])) return;  // Always active.\n    if (reducedExcl.length > 0) newArtExcl[setKey] = reducedExcl\n  }\n\n  // 3. Estimate Upper Bounds and re-check for never-feasible constraints\n  let f = [...newConstraints.map(({ value }) => value), newOptTarget]\n  const lin = f.map(fi => toLinearUpperBound(fi, statsMin, statsMax))\n  applyLinearForm(arts, lin)\n  const newFilters = filters\n    .map(filter => {\n      const { filterVec, lower, upper } = filter\n      const a = filterArtsVec2(arts, filter.filterVec)  // CANDIDATE for making this more efficient\n      const minww = [...a.baseBuffer]\n      const maxww = [...a.baseBuffer]\n      allSlotKeys.forEach(slotKey => {\n        const { minw, maxw } = slotUpperLowerVecW(a.values[slotKey])\n        for (let j = 0; j < minww.length; j++) {\n          minww[j] += minw[j]\n          maxww[j] += maxw[j]\n        }\n      })\n      return {\n        filterVec, lower, upper,\n        minw: minww, maxw: maxww,\n      }\n    })\n    .filter(({ maxw }) => {\n      if (newMins.some((min, j) => maxw[j] < min)) return false\n      if (maxw[mins.length] < threshold) return false\n      return true\n    })\n\n  return {\n    cache: true,\n    optimizationTarget: newOptTarget,\n    constraints: newConstraints,\n    artSetExclusion: newArtExcl,\n\n    depth, lin, filters: newFilters\n  }\n}\n\nexport function toArtifactBySlotVec(arts: ArtifactsBySlot): ArtifactsBySlotVec {\n  const allKeys = new Set(Object.keys(arts.base))\n  Object.values(arts.values).forEach(slotArts => {\n    slotArts.forEach(art => {\n      if (art.set) allKeys.add(art.set)\n      Object.keys(art.values).forEach(k => allKeys.add(k))\n    })\n  })\n\n  const allKeysList = [...allKeys]\n  const keys = [...allKeysList.filter(k => !(allArtifactSets as readonly string[]).includes(k)), ...allKeysList.filter(k => (allArtifactSets as readonly string[]).includes(k))]\n\n  return {\n    keys, baseBuffer: [],\n    base: keys.map(k => arts.base[k] ?? 0),\n    values: {\n      flower: arts.values.flower.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      plume: arts.values.plume.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      sands: arts.values.sands.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      goblet: arts.values.goblet.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      circlet: arts.values.circlet.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n    }\n  }\n}\n\ntype ProblemSetup = {\n  optimizationTargetNode: OptNode,\n  nodes: OptNode[],\n  minimum: number[],\n  artSetExclusion: ArtSetExclusion\n}\nexport function problemSetup(arts: ArtifactsBySlotVec, { optimizationTargetNode, nodes, minimum, artSetExclusion }: ProblemSetup): SubProblemWC {\n  const artSetExclFull = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n    if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n    return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n  })\n\n  const constraintsEP = nodes\n    .map((value, i) => ({ value: expandPoly(value), min: minimum[i] }))\n    .filter(x => x.min > -Infinity)\n  const opttargetEP = expandPoly(optimizationTargetNode)\n\n  const { lower, upper } = statsUpperLowerVec(arts)\n  const statsMin = Object.fromEntries(arts.keys.map((k, i) => [k, lower[i]]))\n  const statsMax = Object.fromEntries(arts.keys.map((k, i) => [k, upper[i]]))\n  let f = [...constraintsEP.map(({ value }) => value), opttargetEP]\n  const lin = f.map(fi => toLinearUpperBound(fi, statsMin, statsMax))\n  const minMaxEst = lin.map(li => minMaxWeightVec(arts, li))\n\n  console.log('-----------------------------------------------------------------------')\n  console.log('lin', lin)\n  console.log('-----------------------------------------------------------------------')\n\n  const filterVec = objectKeyMap(allSlotKeys, slotKey => {\n    return arts.values[slotKey].map((v, i) => i)\n  })\n\n  const initialProblem: SubProblemWC = {\n    cache: true,\n    optimizationTarget: opttargetEP,\n    constraints: constraintsEP,\n    artSetExclusion: artSetExclFull,\n\n    filters: [{\n      filterVec, lower, upper,\n      maxw: minMaxEst.map(({ maxw }) => maxw),\n      minw: minMaxEst.map(({ minw }) => minw),\n    }],\n    depth: 0,\n    lin,\n  }\n  const initialReducedProblem = reduceSubProblem(arts, -Infinity, initialProblem)\n  console.log(initialReducedProblem)\n\n  const statsBase = Object.fromEntries(arts.keys.map((k, i) => [k, arts.base[i]]))\n  evaluateExpandedPolynomial(opttargetEP, statsBase)\n\n  if (initialReducedProblem === undefined)\n    return initialProblem\n  return initialReducedProblem\n}\n\nexport function slotUpperLowerVec(arts: ArtifactBuildDataVecDense[]) {\n  const lower = [...arts[0].values]\n  const upper = [...arts[0].values]\n  const minw = [...arts[0].buffer]\n  const maxw = [...arts[0].buffer]\n  for (let i = 1; i < arts.length; i++) {\n    for (let j = 0; j < lower.length; j++) {\n      lower[j] = Math.min(lower[j], arts[i].values[j])\n      upper[j] = Math.max(upper[j], arts[i].values[j])\n    }\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], arts[i].buffer[j])\n      maxw[j] = Math.max(maxw[j], arts[i].buffer[j])\n    }\n  }\n  return { lower, upper, minw, maxw }\n}\nexport function slotUpperLowerVecW(arts: ArtifactBuildDataVecDense[]) {\n  const minw = [...arts[0].buffer]\n  const maxw = [...arts[0].buffer]\n  for (let i = 1; i < arts.length; i++) {\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], arts[i].buffer[j])\n      maxw[j] = Math.max(maxw[j], arts[i].buffer[j])\n    }\n  }\n  return { minw, maxw }\n}\nexport function statsUpperLowerVec(a: ArtifactsBySlotVec) {\n  const lower = [...a.base]\n  const upper = [...a.base]\n  const minw = [...a.baseBuffer]\n  const maxw = [...a.baseBuffer]\n  Object.values(a.values).forEach(slotArts => {\n    const slotUL = slotUpperLowerVec(slotArts)\n    for (let i = 0; i < lower.length; i++) {\n      lower[i] += slotUL.lower[i]\n      upper[i] += slotUL.upper[i]\n    }\n    for (let i = 0; i < minw.length; i++) {\n      minw[i] += slotUL.minw[i]\n      maxw[i] += slotUL.maxw[i]\n    }\n  })\n  return { lower, upper, minw, maxw }\n}\nexport function statsUpperLowerVecW(a: ArtifactsBySlotVec) {\n  const minw = [...a.baseBuffer]\n  const maxw = [...a.baseBuffer]\n  Object.values(a.values).forEach(slotArts => {\n    const slotUL = slotUpperLowerVecW(slotArts)\n    for (let i = 0; i < minw.length; i++) {\n      minw[i] += slotUL.minw[i]\n      maxw[i] += slotUL.maxw[i]\n    }\n  })\n  return { minw, maxw }\n}\nexport function evaluateExpandedPolynomial(poly: ExpandedPolynomial, x: DynStat) {\n  // 1. evaluate each component node\n  const nodeVals = Object.fromEntries(Object.entries(poly.nodes).map(([fk, f]) => {\n    const compute = precompute([f], {}, n => n.path[1], 1);\n    return [fk, compute([{ id: '', values: x }])[0]]\n  }))\n\n  const termVals = poly.terms.map(({ coeff, terms }) => coeff * terms.reduce((v, t) => v * nodeVals[t], 1))\n  console.log('Value of {poly(x)}: ', termVals.reduce((a, b) => a + b))\n}\n","import { reduceFormula } from '../../../../Formula/addedUtils';\nimport { optimize, OptNode, precompute } from '../../../../Formula/optimization';\nimport type { InterimResult, Setup } from './BackgroundWorker';\nimport { ArtifactBuildData, ArtifactsBySlot, ArtifactsBySlotVec, Build, DynStat, filterArts2, mergePlot, PlotData, reaffine } from './common';\nimport { ArtSetExclusionFull, countBuildsU, SubProblem, unionFilterUpperLower } from './subproblemUtil';\n\nfunction checkArtSetExclusion(setKeyCounts: DynStat, excl: ArtSetExclusionFull) {\n  let pass = Object.entries(setKeyCounts).every(([setKey, num]) => {\n    if (!excl[setKey]) return true\n    return !excl[setKey].includes(num)\n  })\n  if (!pass) return false\n\n  if (!excl['uniqueKey']) return true\n\n  const nRainbow = Object.values(setKeyCounts).reduce((a, b) => a + (b % 2), 0)\n  return !excl['uniqueKey'].includes(nRainbow)\n}\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] = []\n  plotData: PlotData | undefined\n  plotBase: OptNode | undefined\n  threshold: number = -Infinity\n  maxBuilds: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n  nodes: OptNode[]\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, artsVec, optimizationTarget, constraints: filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.artsVec = artsVec\n    this.min = filters.map(x => x.min)\n    this.maxBuilds = maxBuilds\n    this.callback = callback\n    this.nodes = filters.map(x => x.node)\n    this.nodes.push(optimizationTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.plotBase = plotBase\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, _ => false)\n  }\n\n  computeU(newThreshold: number, subproblem: SubProblem) {\n    if (this.threshold < newThreshold) this.threshold = newThreshold\n    const { filters, artSetExclusion } = subproblem\n    const self = this // `this` in nested functions means different things\n\n    const totalCount = countBuildsU(filters)\n    const { lower, upper, maxw } = unionFilterUpperLower(filters)\n    if (maxw[maxw.length - 1] < this.threshold) {\n      this.interimReport({ tested: 0, failed: 0, skipped: totalCount })\n      return\n    }\n\n    let nodes = [...this.nodes]\n    let min = [...this.min]\n    if (this.plotBase !== undefined) nodes.push(this.plotBase);\n    // let { statsMin, statsMax } = unionFilterUpperLower(this.arts, filter)\n    const statsMin: DynStat = Object.fromEntries(this.artsVec.keys.map((k, i) => ([k, lower[i]])))\n    const statsMax: DynStat = Object.fromEntries(this.artsVec.keys.map((k, i) => ([k, upper[i]])))\n    nodes = reduceFormula(nodes, statsMin, statsMax)\n    const reaff = reaffine(nodes, this.arts)\n    nodes = reaff.nodes\n    const preArts = reaff.arts\n\n    // const [compute, mapping, buffer] = precompute(nodes, f => f.path[1])\n    const unionArts = filters.map(filter => {\n      const a = filterArts2(preArts, filter.filterVec)\n      return Object.values(a.values)\n        .sort((a, b) => a.length - b.length)\n    })\n    const compute = precompute(nodes, preArts.base, f => f.path[1], 5)  // should p much always be 5\n    const buffer = Array<ArtifactBuildData>(5)\n    let count = { tested: 0, failed: 0, skipped: 0 }\n\n    function permute(i: number, j: number, setKeyCounts: DynStat) {\n      if (j < 0) {\n        const result = compute(buffer)\n        if (min.some((m, i) => m > result[i]) || !checkArtSetExclusion(setKeyCounts, artSetExclusion)) {\n          count.failed++\n          return\n        }\n\n        const value = result[min.length], { builds, buildValues, plotData, threshold } = self\n        let build: Build | undefined\n        if (value >= threshold) {\n          build = { value, artifactIds: buffer.map(x => x.id) }\n          builds.push(build)\n          buildValues.push(value)\n        }\n        if (plotData) {\n          const x = result[min.length + 1]\n          if (!plotData[x] || plotData[x]!.value < value) {\n            if (!build) build = { value, artifactIds: buffer.map(x => x.id) }\n            build.plot = x\n            plotData[x] = build\n          }\n        }\n        return\n      }\n\n      unionArts[i][j].forEach(art => {\n        buffer[j] = art\n\n        setKeyCounts[art.set ?? ''] = 1 + (setKeyCounts[art.set ?? ''] ?? 0)\n        permute(i, j - 1, setKeyCounts)\n        setKeyCounts[art.set ?? ''] -= 1\n        if (setKeyCounts[art.set ?? ''] === 0) delete setKeyCounts[art.set ?? '']\n      })\n\n      if (j === 0) count.tested += unionArts[i][j].length\n    }\n\n    // 4. Set up buffer with `preArts.base`\n    // for (const [key, value] of Object.entries(preArts.base)) {\n    //   const i = mapping[key]\n    //   if (i !== undefined) buffer[i] = value\n    // }\n\n    // 5. permute all combinations\n    for (let i = 0; i < unionArts.length; i++) {\n      buffer.fill({ id: '', values: {} })\n      permute(i, unionArts[i].length - 1, {})\n    }\n\n    this.interimReport(count)\n    return this.threshold\n  }\n\n  refresh(force: boolean): void {\n    const { maxBuilds } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    // I need frequent updating of threshold\n    if (true || this.builds.length >= 100000 || force) {\n      this.builds = this.builds\n        .sort((a, b) => b.value - a.value)\n        .slice(0, maxBuilds)\n    }\n  }\n  interimReport = (count: { tested: number, failed: number, skipped: number }, forced = false) => {\n    this.refresh(forced)\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\n    this.buildValues = []\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { ArtSetExclusion } from '../../../../Database/DataManagers/BuildsettingData'\nimport { OptNode } from '../../../../Formula/optimization'\nimport { assertUnreachable } from '../../../../Util/Util'\nimport { ArtifactsBySlot, ArtifactsBySlotVec, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\nimport { ComputeWorker } from \"./ComputeWorker\"\nimport { DefaultSplitWorker } from \"./DefaultSplitWorker\"\nimport { SubProblem } from './subproblemUtil'\n\nlet id: number, splitWorker: DefaultSplitWorker, computeWorker: ComputeWorker\n\nonmessage = ({ data }: { data: WorkerCommand }) => {\n  const { command } = data\n  let result: WorkerResult\n  switch (command) {\n    case \"setup\":\n      id = data.id\n      const splitID = `split${id}`, computeID = `compute${id}`\n      splitWorker = new DefaultSplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\n      computeWorker = new ComputeWorker(data, interim => postMessage({ id, source: computeID, ...interim }))\n      result = { command: \"iterate\" }\n      break\n    case \"split\":\n      result = { command: \"split\", subproblems: splitWorker.split(data), ready: splitWorker.subproblems.length === 0 }\n      break\n    case \"iterate\":\n      const { threshold, subproblem } = data\n      computeWorker.computeU(threshold, subproblem)\n      result = { command: \"iterate\" }\n      break\n    case \"finalize\":\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      result = { command: \"finalize\", builds, plotData }\n      break\n    case \"count\":\n      {\n        const { exclusion } = data, arts = computeWorker.arts\n        const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\n        let counts = data.arts.map(_ => 0)\n        for (const perm of setPerm)\n          data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\n        result = { command: \"count\", counts }\n        break\n      }\n    case \"share\":\n      const oo = splitWorker.popOne()\n      result = { command: 'share', subproblem: oo, sender: data.sender }\n      break\n    default: assertUnreachable(command)\n  }\n  postMessage({ id, ...result })\n}\n\nexport interface SplitWorker {\n  addFilter(filter: RequestFilter): void\n  split(newThreshold: number, minCount: number): RequestFilter | undefined\n}\n\n\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Share | Count\nexport type WorkerResult = SourcedInterimResult | SplitResult | IterateResult | FinalizeResult | ShareResult | CountResult\n\nexport interface Setup {\n  command: \"setup\"\n\n  id: number\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n\n  optimizationTarget: OptNode\n  constraints: { node: OptNode, min: number }[]\n  artSetExclusion: ArtSetExclusion\n  plotBase: OptNode | undefined,\n  maxBuilds: number\n}\nexport interface Split {\n  command: \"split\"\n  threshold: number\n  minCount: number\n  maxIter: number\n\n  subproblem?: SubProblem\n}\nexport interface Iterate {\n  command: \"iterate\"\n  threshold: number\n\n  subproblem: SubProblem\n}\nexport interface Finalize {\n  command: \"finalize\"\n}\nexport interface Share {\n  command: \"share\"\n  sender: number\n}\nexport interface Count {\n  command: \"count\"\n  arts: ArtifactsBySlot[]\n  exclusion: ArtSetExclusion\n}\n\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface IterateResult {\n  command: \"iterate\"\n}\nexport interface SplitResult {\n  command: \"split\"\n  ready: boolean\n  subproblems: SubProblem[]\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface ShareResult {\n  command: \"share\"\n  subproblem?: SubProblem\n  sender: number\n}\nexport interface CountResult {\n  command: \"count\"\n  counts: number[]\n}\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface SourcedInterimResult extends InterimResult {\n  /** the source of the message, must be unique for each source of `buildValues` */\n  source: string\n}\n","import type { NumNode } from '../../../../Formula/type';\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey, SlotKey } from '../../../../Types/consts';\nimport type { InterimResult, Setup, Split } from './BackgroundWorker';\nimport { ArtifactsBySlot, ArtifactsBySlotVec, filterArtsVec, filterArtsVec2 } from './common';\nimport { cartesian, objectKeyMap, objectKeyValueMap, partition } from '../../../../Util/Util';\nimport { LinearForm } from '../../../../Formula/linearUpperBound';\nimport { applyLinearForm, countBuildsU, reduceSubProblem, RequestFilter2, slotUpperLowerVec, slotUpperLowerVecW, statsUpperLowerVec, SubProblem, SubProblemWC, UnionFilter2, unionFilterUpperLower } from './subproblemUtil';\n\nexport class DefaultSplitWorker {\nmin: number[]\n\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n  nodes: NumNode[]\n  artSet: Dict<ArtifactSetKey | 'uniqueKey', number[]>\n\n  subproblems: { count: number, upperBound: number, subproblem: SubProblem }[] = []\n\n  splitcounter: number = 0\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, artsVec, optimizationTarget, constraints, artSetExclusion }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.artsVec = artsVec  // buffer is volatile, shared memory problems?\n    this.min = constraints.map(x => x.min)\n    this.nodes = constraints.map(x => x.node)\n    this.callback = callback\n\n    this.min.push(-Infinity)\n    this.nodes.push(optimizationTarget)\n\n    this.artSet = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n      if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n      return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n    })\n  }\n\n  addSubProblem(subproblem: SubProblem) {\n    const count = countBuildsU(subproblem.filters)\n    if (count === 0) return\n    const maxEst = Math.max(...subproblem.filters.map(({ maxw }) => maxw[maxw.length - 1]))\n    this.subproblems.push({ count, upperBound: maxEst, subproblem })\n  }\n\n  /**\n   * Iteratively splits the subproblem (depth-first) into smaller chunks until it is small enough,\n   *   as determined by `minCount`. Repeat up to `maxIter` times before returning control to the main thread.\n   * @param minCount\n   * @param maxIter\n   * @returns Either ONE [subproblem] of size `minCount` or ZERO [] subproblems.\n   */\n  split({ threshold, minCount, maxIter, subproblem }: Split): SubProblem[] {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n    const initialProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n\n    let n = 0\n    while (n < maxIter && this.subproblems.length) {\n      n += 1\n      const { count, subproblem } = this.subproblems.pop()!\n      if (count <= minCount) {\n        const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0) + count\n        this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n        return [subproblem]\n      }\n\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n      // console.log('work queue', this.subproblems)\n    }\n    const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n    this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n    return []\n  }\n\n  popOne() {\n    // Yield largest subproblem (requests => level-order / prio queue order)\n    if (this.subproblems.length === 0) return undefined\n    let ret = { i: -1, heur: -Infinity }\n    for (let i = 1; i < this.subproblems.length; i++) {\n      const { upperBound: heur } = this.subproblems[i]\n      if (heur > ret.heur) ret = { i, heur }\n    }\n    if (ret.i < 0) return undefined\n    return this.subproblems.splice(ret.i, 1)[0].subproblem\n  }\n\n  /**\n   * splitBNB takes a SubProblem and tries to perform Branch and Bound (BnB) pruning to solve for the\n   *   optimal damage value. As the name states, there are two main phases: Branching and Bounding.\n   *   The bounding is handled by an `estimateMaximum()` function call, and the branching is done by `pickBranch()`.\n   *\n   * @param threshold  Objective function lower bound threshold\n   * @param subproblem The subproblem to split\n   * @returns An array of up to 32 splits of the input subproblem.\n   */\n  splitBNB(threshold: number, subproblem: SubProblem) {\n    // 1. check threshold\n    subproblem.filters = subproblem.filters.filter(({ maxw }) => maxw[maxw.length - 1] > threshold)\n    if (subproblem.filters.length === 0) return []\n\n    // 2. Pick branching method\n    let branches0: SubProblem[] = []\n    const maxFilters = 50\n    if (subproblem.filters.length > maxFilters) {\n      // console.log('large problem detected', subproblem.filters.length)\n      // too many filters; just split them somehow I guess?\n      const filts = subproblem.filters.sort((a, b) => a.maxw[a.maxw.length - 1] - b.maxw[b.maxw.length - 1])\n      const nsplit = Math.ceil(filts.length / maxFilters)\n      const newFilts = partition(filts, nsplit)\n\n      branches0 = newFilts.map(filt => ({\n        ...subproblem,\n        filters: filt\n      }))\n    }\n    else {\n      const origBuilds = countBuildsU(subproblem.filters)\n      const pruned = performSingletonPrune(this.artsVec, threshold, subproblem)\n      const newBuilds = countBuildsU(subproblem.filters)\n      if (pruned && countBuildsU(subproblem.filters) === 0) return []\n      if (pruned && (origBuilds - newBuilds) > .3 * origBuilds) {\n        // if more than a third got pruned due to buillshit\n        branches0 = [subproblem]\n      }\n      else {\n        branches0 = this.makeBranches(threshold, subproblem)\n      }\n    }\n\n    // 3. Perform branching. Check bounding during the branching phase as well.\n    let branches = [] as { numBuilds: number, heur: number, subproblem: SubProblemWC }[]\n    branches0.forEach(branch => {\n      let numBuilds = countBuildsU(branch.filters)\n      if (numBuilds === 0) return;\n\n      let sub2 = reduceSubProblem(this.artsVec, threshold, branch)\n      if (sub2 === undefined) return;\n      sub2.depth += 1\n\n      const me = Math.max(...sub2.filters.map(({ maxw }) => maxw[maxw.length - 1]))\n      const li = sub2.lin\n      branches.push({\n        numBuilds, heur: me - li[li.length - 1].err,\n        subproblem: sub2\n      })\n    })\n    // branches.sort((a, b) => a.heur - b.heur)  // Alternative: sort by increasing maxEst - err\n    branches.sort((a, b) => b.numBuilds - a.numBuilds)  // Alternative: sort by decreasing num builds\n\n    // console.log('adding branches', branches)\n    return branches.map(({ subproblem }) => subproblem)\n  }\n\n  makeBranches(threshold: number, subproblem: SubProblemWC): SubProblemWC[] {\n    const { constraints, lin, artSetExclusion, filters } = subproblem\n    // 1a. Get min & max upper bound estimates for objective & constraints\n    const { minw, maxw, lower, upper } = unionFilterUpperLower(filters)\n\n    // console.log('splitting info', { nsp: this.splitcounter, nfilt: filters.length, cnt: countBuildsU(filters) }, { max: maxw[maxw.length - 1], min: minw[minw.length - 1] })\n    this.splitcounter += 1\n\n    // 1b. Take subset of relevant artifacts\n    const allIDs = {\n      flower: { kind: 'id', ids: new Set<string>() },\n      plume: { kind: 'id', ids: new Set<string>() },\n      sands: { kind: 'id', ids: new Set<string>() },\n      goblet: { kind: 'id', ids: new Set<string>() },\n      circlet: { kind: 'id', ids: new Set<string>() },\n    } as StrictDict<SlotKey, { kind: 'id', ids: Set<string> }>\n    filters.forEach(filt => {\n      allSlotKeys.forEach(slotKey => {\n        const setptr = allIDs[slotKey].ids\n        filt.filterVec[slotKey].forEach(ix => setptr.add(this.arts.values[slotKey][ix].id))\n      })\n    })\n    const aarts = filterArtsVec(this.artsVec, allIDs)\n\n    const thr = [...constraints.map(({ min }) => min), threshold]\n    const decisionHeur = thr.map((th, i) => (th - minw[i]) / (maxw[i] - minw[i]))\n    let argMax = -1\n    for (let i = decisionHeur.length - 1; i >= 0; i--) {\n      if (Object.keys(lin[i].w).length === 0) continue  // don't branch on an empty `lin`\n      if (argMax < 0) argMax = i                        // by default, pick optTarget to branch on\n      if (decisionHeur[argMax] < .5) continue           // Discard constraints with low probability of violation\n      if (decisionHeur[i] > decisionHeur[argMax]) argMax = i\n    }\n\n    // TODO: figure out a heuristic for when to branch on artSetExclusion instead. Currently doing so\n    //  when no other options available.\n    let branches: UnionFilter2[];\n    if (argMax < 0) {\n      // Split on set exclusion by just picking the most popular set key.\n      const feasibleKeys = allArtifactSets.filter(setKey => upper[setKey] > 0)\n\n      var branchOn = { k: undefined as ArtifactSetKey | undefined, cnt: -1 }\n      feasibleKeys.forEach(k => {\n        let cnt = upper[k]\n        if (artSetExclusion[k] && artSetExclusion[k].includes(cnt))\n          cnt = Math.min(...artSetExclusion[k]) - 1\n\n        if (cnt > branchOn.cnt) branchOn = { k, cnt }\n      })\n\n      const k = this.artsVec.keys.indexOf(branchOn.k!)\n      applyLinearForm(this.artsVec, lin)\n      branches = branchOnSetKey(k, this.artsVec, filters, lin)\n    }\n    else {\n      let linToConsider = lin[argMax]\n      let keysToConsider = Object.keys(linToConsider.w)\n\n      let shatterOn = { k: '', heur: -1 }\n      keysToConsider.forEach(k => {\n        const kix = this.artsVec.keys.indexOf(k)\n        const postShatterRangeReduction = Object.entries(aarts.values).reduce((rangeReduc, [slot, arts]) => {\n          const vals = arts.map(a => a.values[kix])\n          const minv = Math.min(...vals)\n          const maxv = Math.max(...vals)\n          if (minv === maxv) return rangeReduc\n\n          const branchVal = (minv + maxv) / 2\n          const glb = Math.max(...vals.filter(v => v <= branchVal))\n          const lub = Math.min(...vals.filter(v => v > branchVal))\n          return rangeReduc + Math.min(maxv - glb, lub - minv)\n        }, 0)\n        const heur = linToConsider.w[k] * postShatterRangeReduction * ((allArtifactSets as readonly string[]).includes(k) ? 5 : 1)\n        if (heur > shatterOn.heur) shatterOn = { k, heur }\n      })\n\n      if (shatterOn.k === '') {\n        console.log('===================== SHATTER BROKE ====================', lin, aarts)\n        throw Error('Shatter broke...')\n      }\n      // console.log('shatterOn', shatterOn)\n\n      const k = this.artsVec.keys.indexOf(shatterOn.k)\n      const targetBranchVal = (lower[k] + upper[k]) / 2\n\n      applyLinearForm(this.artsVec, lin)\n      if ((allArtifactSets as readonly string[]).includes(shatterOn.k)) {\n        branches = branchOnSetKey(k, this.artsVec, filters, lin)\n      }\n      else {\n        branches = branchOnValue(k, targetBranchVal, this.artsVec, filters, lin)\n      }\n    }\n    return branches.map(filters => ({ ...subproblem, filters, cache: true }))\n  }\n}\n\nfunction branchOnValue(k: number, target: number, arts: ArtifactsBySlotVec, filts: UnionFilter2, lin: LinearForm[]) {\n  let left: UnionFilter2 = []\n  let right: UnionFilter2 = []\n  // let allSeparate: UnionFilter2[] = []\n  // const allSplits: RequestFilter2[] = []\n  filts.forEach(filt => {\n    const { filterVec } = filt\n    const branchSplitsIx = splitToTargetIx(arts, k, target, filt)  // returns array of 1-2 splits per slot\n\n    const branchArts = objectKeyMap(allSlotKeys, slotKey => branchSplitsIx[slotKey]\n      .filter(ixs => ixs.length > 0)\n      .map(ixs => {\n        // const slotArts = a.values[slotKey].filter(({ id }) => ids.includes(id))\n        const slotArts = filterVec[slotKey].map(ix => arts.values[slotKey][ix])\n        return { slotArts, ixs, ...slotUpperLowerVec(slotArts) }\n      }))\n\n    cartesian(branchArts.flower, branchArts.plume, branchArts.sands, branchArts.goblet, branchArts.circlet)\n      .forEach(slots => {\n        const [flower, plume, sands, goblet, circlet] = slots\n        const lower = flower.lower.map((_, i) => slots.reduce((tot, { lower }) => tot + lower[i], arts.base[i]))// np.sum(-, axis=1)\n        const upper = flower.upper.map((_, i) => slots.reduce((tot, { upper }) => tot + upper[i], arts.base[i]))\n        const maxw = flower.maxw.map((_, i) => slots.reduce((tot, { maxw }) => tot + maxw[i], arts.baseBuffer[i]))\n        const minw = flower.minw.map((_, i) => slots.reduce((tot, { minw }) => tot + minw[i], arts.baseBuffer[i]))\n\n        const toPush: RequestFilter2 = {\n          filterVec: {\n            flower: flower.ixs,\n            plume: plume.ixs,\n            sands: sands.ixs,\n            goblet: goblet.ixs,\n            circlet: circlet.ixs,\n          },\n          lower, upper, minw, maxw\n        }\n\n        if (upper[k] - target > target - lower[k]) {\n          left.push(toPush)\n        }\n        else {\n          right.push(toPush)\n        }\n      })\n  })\n\n  return [left, right]\n}\n\nfunction branchOnSetKey(k: number, arts: ArtifactsBySlotVec, filts: UnionFilter2, lin: LinearForm[]): UnionFilter2[] {\n  function format(slotKey: SlotKey, set: 0 | 1, ixVec: number[]) {\n    const arts2 = ixVec.map(ix => arts.values[slotKey][ix])\n    return { set, ...slotUpperLowerVec(arts2), ixs: ixVec }\n  }\n\n  let left: UnionFilter2 = []\n  let middle: UnionFilter2 = []\n  let right: UnionFilter2 = []\n  filts.forEach(({ filterVec }) => {\n    const branchArts = objectKeyMap(allSlotKeys, slotKey => {\n      const slotArts = arts.values[slotKey]\n      const ixVec1 = filterVec[slotKey].filter(artIx => slotArts[artIx].values[k] === 0)\n      const ixVec2 = filterVec[slotKey].filter(artIx => slotArts[artIx].values[k] === 1)\n\n      const ret: ReturnType<typeof format>[] = []\n      if (ixVec1.length > 0) ret.push(format(slotKey, 0, ixVec1))\n      if (ixVec2.length > 0) ret.push(format(slotKey, 1, ixVec2))\n      return ret\n    })\n\n    cartesian(branchArts.flower, branchArts.plume, branchArts.sands, branchArts.goblet, branchArts.circlet)\n      .forEach(slots => {\n        const [flower, plume, sands, goblet, circlet] = slots\n        const lower = flower.lower.map((_, i) => slots.reduce((tot, { lower }) => tot + lower[i], arts.base[i]))  // np.sum(-, axis=1)\n        const upper = flower.upper.map((_, i) => slots.reduce((tot, { upper }) => tot + upper[i], arts.base[i]))\n        const maxw = flower.maxw.map((_, i) => slots.reduce((tot, { maxw }) => tot + maxw[i], arts.baseBuffer[i]))\n        const minw = flower.minw.map((_, i) => slots.reduce((tot, { minw }) => tot + minw[i], arts.baseBuffer[i]))\n\n        const toPush: RequestFilter2 = {\n          filterVec: {\n            flower: flower.ixs,\n            plume: plume.ixs,\n            sands: sands.ixs,\n            goblet: goblet.ixs,\n            circlet: circlet.ixs,\n          },\n          lower, upper, minw, maxw\n        }\n\n        const setCount = slots.reduce((setCount, { set }) => setCount + set, 0)\n        switch (setCount) {\n          case 0: case 1:\n            left.push(toPush)\n            break\n          case 2: case 3:\n            middle.push(toPush)\n            break\n          case 4: case 5:\n            right.push(toPush)\n            break\n          default:\n            throw Error('Unreachable')\n        }\n      })\n  })\n  return [left, middle, right]\n}\n\nfunction splitToTargetIx(a: ArtifactsBySlotVec, k: number, targ: number, { filterVec }: RequestFilter2) {\n  const n = 5\n  targ = targ - a.base[k]\n\n  // 1. Convert artifacts to simpler form & sort them on each slot\n  const ababa0 = allSlotKeys.map(slotKey => filterVec[slotKey]\n    .map(ix => ({ ix, v: a.values[slotKey][ix].values[k] }))\n    .sort(({ v: v1 }, { v: v2 }) => v1 - v2))\n  // 1b. Collapse same-values\n  const ababa = ababa0.map(arts => arts.map(({ ix, v }) => ({ ixs: [ix], v })))\n  for (let i = 0; i < ababa.length; i += 1) {\n    const aa = ababa[i]\n    for (let j = aa.length - 1; j > 0; j -= 1) {\n      if (aa[j].v === aa[j - 1].v) {\n        aa[j - 1].ixs.push(...aa[j].ixs)\n        aa.splice(j, 1)\n      }\n    }\n  }\n\n  // 2. Find a feasible solution\n  const x0 = ababa.map(arts => arts[0].v)\n  const v = ababa.map(arts => arts[arts.length - 1].v - arts[0].v)\n  if (v.every(vi => vi === 0)) v.fill(1)\n  const coeff = (targ - x0.reduce((a, b) => a + b)) / v.reduce((a, b) => a + b)\n\n  let feas = [] as number[]\n  ababa.forEach((arts, si) => {\n    let z = -1\n    for (let i = 0; i < arts.length; i++) {\n      // This can be replaced with binary search.\n      // if v[si] === 0 theres an ambiguity...\n      if (arts[i].v >= x0[si] + coeff * v[si]) {\n        z = i\n        break\n      }\n    }\n    if (z < 0) z = arts.length\n    feas.push(z)\n  })\n\n  // 3a. Convenience functions for checking correctness and scoring breaking schemes\n  function checkFeasible(breaks: number[]) {\n    let glb = 0, lub = 0\n    for (let i = 0; i < n; i++) {\n      const b = breaks[i]\n      glb += ababa[i][b - 1]?.v ?? -Infinity\n      lub += ababa[i][b]?.v ?? Infinity\n    }\n    return glb - targ <= 1e-6 && targ - lub <= 1e-6  // numerical silliness\n  }\n  function score(breaks: number[]) {\n    return breaks.reduce((p, bi) => p * bi, 1) + breaks.reduce((p, bi, i) => p * (ababa[i].length - bi), 1)\n  }\n\n  // 3b. Verify the feasible solution actually works\n  if (!checkFeasible(feas)) {\n    console.log('feas', feas, checkFeasible(feas), score(feas))\n    console.log({ x0, v, coeff, targ })\n    console.log(ababa)\n    throw Error('hmmm feas not working')\n  }\n\n  // 4. Greedily take 1-step or 2-steps until we cannot improve further.\n  //    TODO: more intelligent way to search.\n  const onesteps: readonly number[][] = [[0, 1], [0, -1], [1, 1], [1, -1], [2, 1], [2, -1], [3, 1], [3, -1], [4, 1], [4, -1]]\n  const twosteps: readonly number[][] = [[0, 1, -1, -1], [0, 1, -1, 1], [0, 1, 1, -1], [0, 1, 1, 1], [0, 2, -1, -1], [0, 2, -1, 1], [0, 2, 1, -1], [0, 2, 1, 1], [0, 3, -1, -1], [0, 3, -1, 1], [0, 3, 1, -1], [0, 3, 1, 1], [0, 4, -1, -1], [0, 4, -1, 1], [0, 4, 1, -1], [0, 4, 1, 1], [1, 2, -1, -1], [1, 2, -1, 1], [1, 2, 1, -1], [1, 2, 1, 1], [1, 3, -1, -1], [1, 3, -1, 1], [1, 3, 1, -1], [1, 3, 1, 1], [1, 4, -1, -1], [1, 4, -1, 1], [1, 4, 1, -1], [1, 4, 1, 1], [2, 3, -1, -1], [2, 3, -1, 1], [2, 3, 1, -1], [2, 3, 1, 1], [2, 4, -1, -1], [2, 4, -1, 1], [2, 4, 1, -1], [2, 4, 1, 1], [3, 4, -1, -1], [3, 4, -1, 1], [3, 4, 1, -1], [3, 4, 1, 1]]\n  while (true) {  // This must terminate within O(ababa[i].length) steps\n    let greedyStep: { score: number, next?: number[] } = { score: score(feas) }\n    onesteps.forEach(([i, di]) => {\n      let breaks = [...feas]\n      breaks[i] += di\n      if (breaks[i] < 0 || breaks[i] >= ababa[i].length) return\n      if (!checkFeasible(breaks)) return\n      const score = breaks.reduce((pr, b) => pr * b, 1) + breaks.reduce((pr, b, i) => pr * (ababa[i].length - b), 1)\n      if (score > greedyStep.score) greedyStep = { score, next: breaks }\n    })\n    twosteps.forEach(([i, j, di, dj]) => {\n      let breaks = [...feas]\n      breaks[i] += di\n      breaks[j] += dj\n      if (breaks[i] < 0 || breaks[i] >= ababa[i].length) return\n      if (breaks[j] < 0 || breaks[j] >= ababa[j].length) return\n      if (!checkFeasible(breaks)) return\n      const score = breaks.reduce((pr, b) => pr * b, 1) + breaks.reduce((pr, b, i) => pr * (ababa[i].length - b), 1)\n      if (score > greedyStep.score) greedyStep = { score, next: breaks }\n    })\n\n    if (greedyStep.next === undefined) break\n    feas = greedyStep.next\n  }\n\n  return objectKeyMap(allSlotKeys, (slotKey, i) => ([ababa[i].slice(0, feas[i]).flatMap(({ ixs }) => ixs), ababa[i].slice(feas[i]).flatMap(({ ixs }) => ixs)]))\n}\n\nfunction performSingletonPrune(arts: ArtifactsBySlotVec, threshold: number, { constraints, filters, lin }: SubProblem) {\n  applyLinearForm(arts, lin)\n  const mins = [...constraints.map(({ min }) => min), threshold]\n\n  let changed = false\n  for (let i = filters.length - 1; i >= 0; i--) {\n    const { maxw, filterVec } = filters[i]\n\n    const toremove = objectKeyMap(allSlotKeys, slot => {\n      const slotArts = filterVec[slot].map(ix => arts.values[slot][ix])\n      const { minw: minwSlot, maxw: maxwSlot } = slotUpperLowerVecW(slotArts)\n\n      const toremove: number[] = []\n      maxw.forEach((mv, j) => {\n        const cutoff = mins[j] - maxw[j] + maxwSlot[j]\n        if (minwSlot[j] > cutoff) return\n\n        toremove.push(...filterVec[slot].filter(ix => arts.values[slot][ix].buffer[j] < cutoff))\n      })\n      return new Set(toremove)\n    })\n    if (Object.values(toremove).every(rm => rm.size === 0)) continue\n\n    changed = true\n    const newFilterVec = objectKeyMap(allSlotKeys, slot => filterVec[slot].filter(ix => !toremove[slot].has(ix)))\n\n    const numBuilds = allSlotKeys.reduce((tot, slot) => tot * newFilterVec[slot].length, 1)\n    if (numBuilds === 0) {\n      filters.splice(i, 1)\n      continue\n    }\n\n    filters[i] = {\n      filterVec: newFilterVec,\n      ...statsUpperLowerVec(filterArtsVec2(arts, newFilterVec))\n    }\n  }\n\n  return changed\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [221], function() { return __webpack_require__(67023); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"45b11d4b\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/genshin-optimizer/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t204: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkgenshin_optimizer\"] = self[\"webpackChunkgenshin_optimizer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(221).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","sum","values","intoOps","prod","customRead","path","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","precompute","initial","binding","slotCount","body","names","_","f","operandNames","key","arr","fill","toString","join","Function","flatten","_formula","flattened","dep","deduplicate","elementCounts","array","wrap","common","counts","next","factored","count","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","c","foldStr","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","operand","v1","v2","match","unmatch","list","accu","reset","nextMap","nextContext","allSlotKeys","allArtifactSets","nonTravelerCharacterKeys","travelerKeys","filterFeasiblePerm","artSetPerm","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","nonConst","base","size","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","baseValue","filterArtsVec2","filterVec","baseBuffer","filterIxs","slotVals","ix","filters","_artSets","artSets","available","kind","sets","s","exclusionToAllowed","exclusion","includes","populateShapes","indexOfShape","shape","check_free","remaining","rainbows","isolated","missing","rejected","required","allowedSet","allowedCounts","j","some","groupped","used","requiredRainbows","l","usableRainbows","sort","replacing","allowedRainbows","shapes","rainbow","slice","noFilter","sumM","monomials","prodM","monos","ret","nxt","coeff","terms","constantM","readM","tag","foldLikeTerms","mono","mon","m","termsA","termsB","ai","splice","pivotInplace","A","Aij","h","findPiv1","r","minloc","cmp","findPiv2","minMax","lower","upper","compute","n","handleResArg","flippedResOp","flipOps","branch","bval","ge","lt","le","log","resf","toLinearUpperBound","stat2tag","toPureRead","slope","mon1","intercept","rop","cop","thresh","minVal","maxVal","em","denom","minEM","maxEM","loc","sqrt","below","nodesToMap","t2","t","nt","lins","w","err","bounds","nVar","boundScale","scaleProd","soln","cons","coords","objective","Ab","rows","cols","tableau","Ai","cj","ijTrack","ij","targ","side","ncol","backtrack","solveLP","wi","lub","lin","foldSum","constVal","pv","foldProd","countBuildsU","tot","_count","unionFilterUpperLower","minw","maxw","applyLinearForm","wixs","ws","baseC","li","ixs0","w0","indexOf","accum","slotKey","art","buffer","ixsi","reduceSubProblem","subp","optimizationTarget","constraints","artSetExclusion","depth","mins","statsMin","statsMax","fixedStats","statKey","abs","tagNodePairs","reducedNodes","branchVal","ni","tagsToKill","newTerms","newNodes","reducePolynomial","toNumNode","active","newOptTarget","pop","newConstraints","newMins","newArtExcl","setKey","exclude","feasibleKeys","feasible4sets","feasible2sets","allowedCnts","cnt","reducedExcl","fi","newFilters","minww","maxww","slotUpperLowerVecW","cache","slotUpperLowerVec","statsUpperLowerVec","slotArts","slotUL","splitWorker","computeWorker","ComputeWorker","callback","artsVec","plotBase","maxBuilds","builds","buildValues","plotData","interimReport","forced","refresh","command","tested","failed","skipped","this","opts","optimize","newThreshold","subproblem","self","totalCount","reduceFormula","reaff","preArts","unionArts","permute","setKeyCounts","excl","num","nRainbow","checkArtSetExclusion","build","artifactIds","plot","force","plots","scale","round","mergePlot","DefaultSplitWorker","items","artSet","subproblems","splitcounter","maxEst","upperBound","minCount","maxIter","addSubProblem","initialProblemTotal","newProblemTotal","splitBNB","heur","branches0","filts","rest","floor","partition","ceil","filt","origBuilds","pruned","changed","toremove","minwSlot","maxwSlot","mv","cutoff","rm","newFilterVec","performSingletonPrune","newBuilds","makeBranches","branches","numBuilds","sub2","me","allIDs","flower","ids","plume","sands","goblet","circlet","setptr","aarts","filterArtsVec","decisionHeur","th","argMax","branchOn","branchOnSetKey","linToConsider","keysToConsider","shatterOn","kix","postShatterRangeReduction","rangeReduc","vals","minv","maxv","glb","targetBranchVal","target","left","right","branchSplitsIx","ababa","ixs","aa","x0","vi","feas","checkFeasible","breaks","score","p","bi","si","z","onesteps","twosteps","greedyStep","di","pr","dj","splitToTargetIx","branchArts","slots","toPush","branchOnValue","format","ixVec","arts2","middle","ixVec1","artIx","ixVec2","setCount","onmessage","splitID","computeID","interim","postMessage","source","split","ready","computeU","setPerm","perm","countBuilds","filterArts","oo","popOne","sender","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","fulfilled","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}