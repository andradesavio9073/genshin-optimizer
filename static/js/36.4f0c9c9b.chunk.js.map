{"version":3,"file":"static/js/36.4f0c9c9b.chunk.js","mappings":"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","sources":["Formula/api.tsx","Formula/internal.ts","Formula/optimization.ts","Formula/uiData.tsx"],"sourcesContent":["import Artifact from \"../Data/Artifacts/Artifact\";\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\nimport { ICachedCharacter } from \"../Types/character\";\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\nimport { ICachedWeapon } from \"../Types/weapon\";\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\nimport { NodeDisplay, UIData } from \"./uiData\";\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\n\nconst asConst = true as const, pivot = true as const\n\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\n    if (path[0] === \"teamBuff\") {\n      path = path.slice(1)\n      if (!x.info) x.info = {}\n      x.info.isTeamBuff = true\n    }\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\n    if (reference)\n      x.info = { ...x.info, ...reference.info, prefix: undefined, source }\n    else if (path[0] !== \"tally\")\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\n  })\n\n  return data\n}\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\n  stats.push([art.mainStatKey, mainStatVal])\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\n  return {\n    art: {\n      ...Object.fromEntries(stats.map(([key, value]) =>\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\n      [art.slotKey]: {\n        id: constant(art.id), set: constant(art.setKey)\n      },\n    },\n    artSet: {\n      [art.setKey]: constant(1),\n    },\n  }\n}\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\n  const result: Data = {\n    lvl: constant(char.level),\n    constellation: constant(char.constellation),\n    asc: constant(char.ascension),\n    infusion: {\n      team: char.infusionAura ? constant(char.infusionAura) : undefined,\n    },\n    premod: {\n      auto: constant(char.talent.auto),\n      skill: constant(char.talent.skill),\n      burst: constant(char.talent.burst),\n    },\n    enemy: {\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\n    },\n    hit: {\n      hitMode: constant(char.hitMode),\n      reaction: constant(char.reactionMode),\n    },\n    customBonus: {},\n  }\n\n  for (const [key, value] of Object.entries(char.bonusStats))\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\n\n  if (char.enemyOverride.enemyDefRed_)\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_ / 100)\n  if (char.enemyOverride.enemyDefIgn_)\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_ / 100)\n\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\n    layeredAssignment(result, keys, constant(x)))\n  return result\n}\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\n  return {\n    weapon: {\n      id: constant(weapon.id),\n      lvl: constant(weapon.level),\n      asc: constant(weapon.ascension),\n      refinement: constant(weapon.refinement),\n      refineIndex: constant(weapon.refinement - 1)\n    },\n  }\n}\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\n  // May the goddess of wisdom bless any and all souls courageous\n  // enough to attempt for the understanding of this abomination.\n\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\n  const result = Object.fromEntries(mergedData.map(([key]) =>\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\n\n  const customReadNodes = {}\n  function getReadNode(path: readonly string[]): ReadNode<number> {\n    const base = (path[0] === \"teamBuff\")\n      ? objPathValue(teamBuff, path.slice(1))\n      : objPathValue(input, path)\n    if (base) return base\n    const custom = objPathValue(customReadNodes, path)\n    if (custom) return custom\n    const newNode = customRead(path)\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\n    layeredAssignment(customReadNodes, path, newNode)\n    return newNode\n  }\n\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\n    mergedData.forEach(([sourceKey, source]) => {\n      const sourceBuff = source.teamBuff\n      // Create new copy of `calc` as we're mutating it later\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\n      buffs.push(buff)\n      calcs[sourceKey] = calc\n\n      // This construction creates a `Data` representing buff\n      // from `source` applying to `target`. It has 3 data:\n      // - `target` contains the reference for the final\n      //   data. It is not populated at this stage,\n      // - `calc` contains the calculation of the buffs,\n      // - `buff` contains read nodes that point to the\n      //   calculation in `calc`.\n\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\n\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\n\n          let readNode: ReadNode<number | string> | undefined, data: Data\n          if (x.path[0] === \"target\") { // Link the node to target data\n            readNode = getReadNode(x.path.slice(1))\n            data = targetRef\n          } else { // Link the node to source data\n            readNode = x\n            data = result[sourceKey].targetRef\n          }\n          layeredAssignment(calc, x.path, resetData(readNode, data))\n        })\n      })\n    })\n  )\n  mergedData.forEach(([targetKey, data]) => {\n    delete data.teamBuff\n    const { targetRef, buffs } = result[targetKey]\n    const buff = mergeData(buffs)\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\n      // CAUTION\n      // This is safe only because `buff` is created using only `resetData`\n      // and `mergeData`. So every node here is created from either of the\n      // two functions, so the mutation wont't affect existing nodes.\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\n    })\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\n    targetRef[\"target\"] = targetRef\n  })\n  const origin = new UIData(undefined as any, undefined)\n  return Object.fromEntries(Object.entries(result).map(([key, value]) =>\n    [key, {\n      target: new UIData(value.targetRef, origin),\n      buffs: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\n        [key, new UIData(value, origin)]))\n    }]))\n}\nfunction mergeData(data: Data[]): Data {\n  function internal(data: any[], path: string[]): any {\n    if (data.length <= 1) return data[0]\n    if (data[0].operation) {\n      if (path[0] === \"teamBuff\") path = path.slice(1)\n      let { accu, type } = (objPathValue(input, path) as ReadNode<number> | ReadNode<string> | undefined) ?? {}\n      if (path[0] === \"tally\") accu = \"add\"\n      else if (accu === undefined) {\n        const errMsg = `Multiple entries when merging \\`unique\\` for key ${path}`\n        if (process.env.NODE_ENV === \"development\")\n          throw new Error(errMsg)\n        else\n          console.error(errMsg)\n\n        accu = type === \"number\" ? \"max\" : \"small\"\n      }\n      const result: NumNode | StrNode = { operation: accu, operands: data }\n      return result\n    } else {\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\n    }\n  }\n  return data.length ? internal(data, []) : {}\n}\n\nfunction computeUIData(data: Data[]): UIData {\n  return new UIData(mergeData(data), undefined)\n}\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\n}\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\n}\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\n  if (data1?.operation || data2?.operation) {\n    const d1 = data1 as NodeDisplay | undefined\n    const d2 = data2 as NodeDisplay | undefined\n\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\n      throw new Error(\"Unmatched structure when comparing UIData\")\n\n    const result: ComparedNodeDisplay = {\n      info: {},\n      operation: true,\n      value: 0,\n      isEmpty: true,\n      unit: d2?.unit!,\n      formulas: [],\n      ...d1,\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\n    }\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\n      // In case `string` got involved, just use the other value\n      result.value = d1?.value ?? \"\" as any\n      result.diff = d2?.value ?? \"\" as any\n    }\n    return result\n  }\n\n  if (data1 || data2) {\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\n  }\n}\n\nexport type { NodeDisplay, UIData };\nexport {\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\n  mergeData, computeUIData, inferInfoMut,\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\n};\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objectKeyMap, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): [compute: () => Float64Array, mapping: Dict<string, number>, buffer: Float64Array] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = new Float64Array(offset).fill(0)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return [() => {\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }, objectKeyMap(readStrings, (_, i) => readOffset + i), buffer]\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { uiInput } from \".\"\nimport ColorText from \"../Components/ColoredText\"\nimport KeyMap, { Unit, valueString } from \"../KeyMap\"\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\nimport { allOperations } from \"./optimization\"\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput } from \"./type\"\n\nconst shouldWrap = true\nexport interface NodeDisplay<V = number> {\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\n  operation: true\n  info: Info\n  value: V\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\n  isEmpty: boolean\n  unit: Unit\n  formula?: Displayable\n  formulas: Displayable[]\n}\n\nexport class UIData {\n  origin: UIData\n  children = new Map<Data, UIData>()\n\n  data: Data[]\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\n\n  display: any = undefined\n  teamBuff: any = undefined\n\n  constructor(data: Data, parent: UIData | undefined) {\n    if (data === undefined) {\n      // Secret *origin* initializer\n      this.data = []\n      this.origin = this\n    } else {\n      if (!parent)\n        parent = new UIData(undefined as any, undefined)\n\n      this.data = [data, ...parent.data]\n      this.origin = parent.origin\n    }\n  }\n\n  getDisplay(): {\n    [key: string]: DisplaySub<NodeDisplay>\n  } {\n    if (!this.display) this.display = this.getAll([\"display\"])\n    return this.display\n  }\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\n    if (!this.teamBuff) {\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\n      // Convert `input` to `uiInput`\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\n        if (node) layeredAssignment(result, path, node)\n      })\n      this.teamBuff = result\n    }\n    return this.teamBuff\n  }\n  getAll(prefix: string[]): any {\n    const result = {}\n    for (const data of this.data) {\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\n    }\n    return result\n  }\n  get(node: NumNode): NodeDisplay\n  get(node: StrNode): NodeDisplay<string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\n    if (node === undefined) {\n      console.trace(\"Please report this bug with this trace\")\n      return { info: {}, operation: true, value: undefined, isEmpty: true, unit: \"\", formulas: [] }\n    }\n    const old = this.processed.get(node)\n    if (old) return old\n\n    const result = computeNodeDisplay(this.computeNode(node))\n    this.processed.set(node, result)\n    // if (result.info.subVariant) console.log(result.info)\n    return result\n  }\n  private computeNode(node: NumNode): ContextNodeDisplay\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\n    const old = this.nodes.get(node)\n    if (old) return old\n\n    const { operation, info } = node\n    let result: ContextNodeDisplay<number | string | undefined>\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        result = this._compute(node); break\n      case \"threshold\": result = this._threshold(node); break\n      case \"const\": result = this._constant(node.value); break\n      case \"subscript\": result = this._subscript(node); break\n      case \"read\": result = this._read(node); break\n      case \"data\": result = this._data(node); break\n      case \"match\": result = this._match(node); break\n      case \"lookup\": result = this._lookup(node); break\n      case \"prio\": result = this._prio(node.operands); break\n      case \"small\": result = this._small(node.operands); break\n      default: assertUnreachable(operation)\n    }\n\n    if (info) {\n      const { asConst } = info\n      result = { ...result }\n      result.info = mergeInfo(result.info, info)\n\n      // Pivot all keyed nodes for debugging\n      // if (info.key) result.info.pivot = true\n\n      if (asConst) {\n        delete result.formula\n        delete result.assignment\n        result.dependencies = new Set()\n      }\n      if (result.info.pivot || !result.formula)\n        result.mayNeedWrapping = false\n    }\n    createDisplay(result)\n\n    this.nodes.set(node, result)\n    return result\n  }\n\n  private prereadAll(path: readonly string[]): (NumNode | StrNode)[] {\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x)\n  }\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\n    return data && this.computeNode(data)\n  }\n\n  private _prio(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\n    const first = nodes.find(node => this.computeNode(node).value !== undefined)\n    return first ? this.computeNode(first) : illformedStr\n  }\n  private _small(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\n    let smallest: ContextNodeDisplay<string | undefined> | undefined = undefined\n    for (const node of nodes) {\n      const candidate = this.computeNode(node)\n      if (smallest?.value === undefined || (candidate.value && candidate.value < smallest.value))\n        smallest = candidate\n    }\n    return smallest ?? illformedStr\n  }\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\n    const { path } = node\n    if (node.accu === undefined) {\n      return this.readFirst(path) ?? (node.type === \"string\" ? illformedStr : illformed)\n    } else {\n      const nodes = this.prereadAll(path)\n      if (nodes.length === 1) return this.computeNode(nodes[0])\n      return node.accu === \"small\"\n        ? this._small(nodes as StrNode[])\n        : this._accumulate(node.accu, nodes.map(x => this.computeNode(x)) as ContextNodeDisplay[])\n    }\n  }\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const key = this.computeNode(node.operands[0]).value\n    const selected = node.table[key!] ?? node.operands[1]\n    if (!selected)\n      throw new Error(`Lookup Fail with key ${key}`)\n    return this.computeNode(selected)\n  }\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\n    const matching = v1.value === v2.value\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\n      ? makeEmpty(result.value) : result\n  }\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const [valueNode, thresholdNode, pass, fail] = node.operands\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\n    return (value.value >= threshold.value)\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\n  }\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    let child = this.children.get(node.data)\n    if (!child) {\n      child = new UIData(node.data, node.reset ? this.origin : this)\n      this.children.set(node.data, child)\n    }\n    return child.computeNode(node.operands[0])\n  }\n  private _compute(node: ComputeNode): ContextNodeDisplay {\n    const { operation, operands } = node\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\n  }\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\n    const operand = this.computeNode(node.operands[0])\n    const value = node.list[operand.value] ?? NaN\n    return this._constant(value)\n  }\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\n    return {\n      info: {}, value,\n      empty: false,\n      mayNeedWrapping: false,\n      dependencies: new Set(),\n    }\n  }\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\n    let info: Info | undefined\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        info = accumulateInfo(operands)\n        break\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n        const identity = allOperations[operation]([])\n        if (process.env.NODE_ENV !== \"development\")\n          operands = operands.filter(operand => operand.value !== identity)\n        if (!operands.length)\n          return Object.values(info).some(x => x) ? { ...this._constant(identity), info } : this._constant(identity)\n    }\n\n    let formula: { display: Displayable, dependencies: Displayable[] }\n    let mayNeedWrapping = false\n    switch (operation) {\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap: operands.length > 1 }}`; break\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\n      case \"res\": {\n        const base = operands[0].value\n        if (base < 0) {\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\n          mayNeedWrapping = true\n        }\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\n        else {\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\n          mayNeedWrapping = true\n        }\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\":\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\n        else if (operation === \"add\") mayNeedWrapping = true\n    }\n\n    const value = allOperations[operation](operands.map(x => x.value))\n    const dependencies = new Set([...operands.flatMap(x =>\n      x.info.pivot && x.assignment\n        ? [x.assignment, ...x.dependencies]\n        : [...x.dependencies])])\n    const result: ContextNodeDisplay = {\n      info, formula: formula.display,\n      empty: operands.every(x => x.empty),\n      value, mayNeedWrapping, dependencies,\n    }\n    return result\n  }\n}\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\n  const dependencies = new Set<Displayable>()\n  const predisplay: Displayable[] = []\n\n  strings.forEach((string, i) => {\n    predisplay.push(string)\n\n    const key = list[i]\n    if (key) {\n      const { operands, shouldWrap, separator = \", \" } = key\n      operands.forEach((item, i, array) => {\n        let itemFormula: Displayable\n        if (!item.info.pivot && item.formula) itemFormula = item.formula\n        else itemFormula = createFormulaComponent(item)\n\n        if (shouldWrap && item.mayNeedWrapping) {\n          predisplay.push(\"( \")\n          predisplay.push(itemFormula)\n          predisplay.push(\" )\")\n        } else {\n          predisplay.push(itemFormula)\n        }\n        if (i + 1 < array.length) predisplay.push(separator)\n        item.dependencies.forEach(x => dependencies.add(x))\n      })\n    }\n  })\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\n}\nfunction accumulateInfo<V>(operands: ContextNodeDisplay<V>[]): Info {\n  function score(variant: Required<Info>[\"variant\"]) {\n    switch (variant) {\n      case \"overloaded\": case \"shattered\": case \"electrocharged\": case \"superconduct\":\n      case \"vaporize\": case \"swirl\": case \"melt\": case \"success\": return 2\n      case \"anemo\": case \"cryo\": case \"hydro\": case \"pyro\": case \"electro\": case \"geo\": return 1\n      case \"physical\": return 0\n      default: assertUnreachable(variant)\n    }\n  }\n  const variants = new Set(operands.flatMap(x => [x.info.variant!, x.info.subVariant!]))\n  variants.delete(undefined!);\n  const sorted = [...variants].sort((a, b) => score(a) - score(b)), result: Info = {}\n  if (sorted.length) result.variant = sorted.pop()\n  if (sorted.length) result.subVariant = sorted.pop()\n  else result.subVariant = result.variant\n  return result\n}\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\n  const { info, dependencies, value, formula, assignment, empty } = node\n  return {\n    operation: true,\n    info,\n    value,\n    isEmpty: empty,\n    unit: KeyMap.unit(info.key),\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\n  }\n}\n\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { info, value, formula } = node\n  const { key, prefix, source, variant, fixed } = info\n  if (typeof value !== \"number\") return\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, KeyMap.unit(key), fixed)}</ColorText>\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.get(key!)}</ColorText>{sourceDisplay}</>\n\n    if (formula)\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  //TODO: change formula size in the formula display element instead\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\n}\n/*/\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { info, value, formula } = node\n  const { key, prefix, source, fixed } = info\n  if (typeof value !== \"number\") return\n  node.valueDisplay = valueString(value, KeyMap.unit(key), fixed)\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? ` ${source}` : \"\"\n    node.name = `${prefixDisplay}${KeyMap.getStr(key!)}${sourceDisplay}`\n\n    if (formula)\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return (components as string[]).join(\"\")\n}\n//*/\n\nfunction mergeInfo(base: Info, override: Info): Info {\n  const result = { ...base }\n  for (const [key, value] of Object.entries(override))\n    if (value) result[key] = value as any\n  return result\n}\n\ninterface ContextNodeDisplay<V = number> {\n  info: Info\n  empty: boolean\n  value: V\n\n  dependencies: Set<Displayable>\n\n  mayNeedWrapping: boolean // Whether this formula should be parenthesized when it is a part of multiplications/divisions and subtractions' subtrahends\n\n  // Don't set these manually outside of `UIData.computeNode`\n  name?: Displayable\n  valueDisplay?: Displayable\n  formula?: Displayable\n  assignment?: Displayable\n}\n\nconst illformed: ContextNodeDisplay = {\n  info: { pivot: true },\n  value: NaN,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nconst illformedStr: ContextNodeDisplay<string | undefined> = {\n  info: { pivot: true },\n  value: undefined,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\n  return {\n    info: {}, value: emptyValue, empty: true, dependencies: new Set(), mayNeedWrapping: false\n  }\n}\n"],"names":["inferInfoMut","data","source","crawlObject","x","operation","path","slice","info","isTeamBuff","reference","objPathValue","input","prefix","undefined","console","error","dataObjForArtifact","art","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatKey","rarity","Math","max","min","level","stats","push","substats","forEach","key","accurateValue","Object","fromEntries","map","value","endsWith","percent","constant","slotKey","id","set","setKey","artSet","dataObjForCharacter","char","result","lvl","constellation","asc","ascension","infusion","team","infusionAura","premod","auto","talent","skill","burst","enemy","objectKeyMap","allElementsWithPhy","ele","enemyOverride","enemyLevel","hit","hitMode","reaction","reactionMode","customBonus","entries","bonusStats","enemyDefRed_","enemyDefIgn_","defIgn","conditional","keys","layeredAssignment","dataObjForWeapon","weapon","refinement","refineIndex","teamBuff","setReadNodeKeys","deepClone","uiDataForTeam","teamData","activeCharKey","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","base","custom","newNode","customRead","accu","values","sourceKey","sourceBuff","buff","calc","asConst","resetData","readNode","targetKey","pivot","assign","origin","UIData","target","length","internal","type","errMsg","operands","Set","flatMap","filter","computeUIData","forEachNodes","formulas","topDown","bottomUp","visiting","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","NaN","arrayEqual","a","b","every","i","allCommutativeMonoidOperations","reduce","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","precompute","binding","uniqueReadStrings","uniqueNumbers","mapping","_","f","Error","name","ins","op","assertUnreachable","locations","readStrings","readOffset","constValues","computations","str","offset","ref","node","out","Array","fill","buffer","Float64Array","number","copyList","src","copyFormula","dst","j","flattened","dep","elementCounts","array","wrap","common","counts","next","factored","count","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","smallest","v1","v2","match","unmatch","list","reset","nextContext","shouldWrap","parent","children","nodes","display","this","getAll","calculated","uiInput","trace","isEmpty","unit","dependencies","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","_prio","_small","override","mergeInfo","mayNeedWrapping","variant","fixed","valueDisplay","color","valueString","prefixDisplay","sourceDisplay","createDisplay","illformedStr","readFirst","illformed","prereadAll","_accumulate","v1Node","v2Node","matchNode","unmatchNode","matching","emptyOn","makeEmpty","valueNode","thresholdNode","child","operand","score","variants","subVariant","sorted","sort","pop","accumulateInfo","identity","some","fStr","separator","strings","predisplay","string","item","itemFormula","createFormulaComponent","mergeFormulaComponents","style","fontSize","components","emptyValue"],"sourceRoot":""}