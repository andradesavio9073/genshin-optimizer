{"version":3,"file":"static/js/564.4a4f4e60.chunk.js","mappings":"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","sources":["Assets/Assets.ts","Components/Card/CardDark.tsx","Components/Card/CardLight.tsx","Components/CloseButton.tsx","Components/ConditionalWrapper.tsx","Components/DropdownMenu/DropdownButton.tsx","Components/Image/ImgIcon.tsx","Components/ModalWrapper.tsx","Components/SolidToggleButtonGroup.tsx","Components/StarDisplay.tsx","Components/StatIcon.tsx","Data/Characters/CharacterSheet.tsx","Data/SheetUtil.tsx","Formula/api.tsx","Formula/index.ts","Formula/internal.ts","Formula/optimization.ts","Formula/uiData.tsx","Formula/utils.ts","ReactHooks/useDBState.tsx","ReactHooks/useForceUpdate.tsx","ReactHooks/usePromise.tsx","Util/CharacterSort.ts","Util/SortByFilters.ts"],"sourcesContent":["import bow from './icon_bow.png'\nimport catalyst from './icon_catalyst.png'\nimport claymore from './icon_claymore.png'\nimport polearm from './icon_polearm.png'\nimport sword from './icon_sword.png'\n\nimport fragile from './Item_Fragile_Resin.png'\nimport condensed from './Item_Condensed_Resin.png'\n\n//EXP BOOKS\nimport advice from './Item_Wanderer\\'s_Advice.png'\nimport wit from './Item_Hero\\'s_Wit.png'\nimport experience from './Item_Adventurer\\'s_Experience.png'\n\nimport team1 from './icon_team_1.png'\nimport team2 from './icon_team_2.png'\nimport team3 from './icon_team_3.png'\nimport team4 from './icon_team_4.png'\n\nimport flower from './icon_slot_flower.png'\nimport plume from './icon_slot_plume.png'\nimport sands from './icon_slot_sands.png'\nimport goblet from './icon_slot_goblet.png'\nimport circlet from './icon_slot_circlet.png'\n\nconst Assets = {\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\n  slot: {\n    flower,\n    plume,\n    sands,\n    goblet,\n    circlet,\n  },\n  resin: {\n    fragile,\n    condensed\n  },\n  exp_books: {\n    advice,\n    wit,\n    experience,\n  },\n  team: {\n    team1,\n    team2,\n    team3,\n    team4,\n  },\n};\nexport default Assets;\n","import { Card, styled } from \"@mui/material\";\n\nconst CardDark = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentDark.main\n}));\n\nexport default CardDark","import { Card, styled } from \"@mui/material\";\n\nconst CardLight = styled(Card)(({ theme }) => ({\n  backgroundColor: theme.palette.contentLight.main\n}));\n\nexport default CardLight","import { Close } from \"@mui/icons-material\";\nimport { Button, ButtonProps } from \"@mui/material\";\nimport { useTranslation } from \"react-i18next\";\ntype CloseButtonProps = ButtonProps & {\n  large?: boolean\n}\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\n  const { t } = useTranslation(\"ui\")\n  if (large)\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\n    <Close />\n  </Button>\n}\n","import { ReactNode } from \"react\";\n\ntype Prop = {\n  condition: boolean,\n  wrapper: (children: ReactNode) => ReactNode\n  falseWrapper?: (children: ReactNode) => ReactNode\n  children: ReactNode\n}\n// Wrap children with element provided by wrapper func when condition is true.\nexport default function ConditionalWrapper({ condition, wrapper, falseWrapper, children }: Prop) {\n  return (condition ? wrapper(children) : (falseWrapper ? falseWrapper(children) : children)) as JSX.Element;\n}","import { KeyboardArrowDown } from \"@mui/icons-material\";\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\nimport { Suspense, useCallback, useState } from \"react\";\n\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\n  title: React.ReactNode,\n  id?: string,\n  children: React.ReactNode\n}\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n  const open = Boolean(anchorEl);\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\n    [setAnchorEl],\n  )\n  const handleClose = useCallback(\n    () => setAnchorEl(null),\n    [setAnchorEl],\n  )\n\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\n    <Button\n      {...props}\n      id={id}\n      aria-controls=\"basic-menu\"\n      aria-haspopup=\"true\"\n      aria-expanded={open ? 'true' : undefined}\n      onClick={handleClick}\n      endIcon={<KeyboardArrowDown />}\n    >\n      {title}\n    </Button>\n    <Menu\n      id=\"basic-menu\"\n      anchorEl={anchorEl}\n      open={open}\n      onClose={handleClose}\n      MenuListProps={{\n        'aria-labelledby': id,\n      }}\n      onClick={handleClose}\n    >\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\n        {children}\n      </Suspense>\n    </Menu>\n  </Suspense>\n}","import { styled } from \"@mui/material\"\ninterface ImgIconProps {\n  size?: number;\n}\nconst ImgIcon = styled(\"img\", {\n  name: 'ImgIcon',\n  slot: 'Root',\n})<ImgIconProps>(({ size = 1 }) => ({\n  display: \"inline-block\",\n  width: \"auto\",\n  height: `${size * 1.2}em`,\n  verticalAlign: \"text-bottom\"\n}))\n\nexport default ImgIcon","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\nimport { Suspense } from \"react\"\nimport CardLight from \"./Card/CardLight\"\n\nconst ScrollModal = styled(Modal)(({ theme }) => ({\n  overflow: \"scroll\",\n  paddingTop: theme.spacing(2),\n  paddingBottom: theme.spacing(2),\n\n}))\nconst ModalContainer = styled(Container)(({ theme }) => ({\n  padding: 0,\n  minHeight: \"100%\",\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\n  pointerEvents: \"none\",\n  \"& > *\": {\n    pointerEvents: \"auto\"\n  }\n}))\n\ntype ModalWrapperProps = ModalProps & {\n  containerProps?: ContainerProps\n}\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\n  return <ScrollModal {...props}>\n    <ModalContainer {...containerProps}>\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\n        {children}\n      </Suspense>\n    </ModalContainer>\n  </ScrollModal>\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\n\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\ntype SolidToggleButtonGroupPropsPartial = {\n  baseColor?: ButtonProps[\"color\"];\n  selectedColor?: ButtonProps[\"color\"];\n}\n\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"secondary\", selectedColor = \"success\" }) => ({\n  '& .MuiToggleButtonGroup-grouped': {\n    '&': {\n      backgroundColor: theme.palette[baseColor].main,\n      color: theme.palette[baseColor].contrastText,\n    },\n    '&:hover': {\n      backgroundColor: theme.palette[baseColor].dark,\n      transition: \"background-color 0.25s ease\",\n    },\n    '&.Mui-selected': {\n      backgroundColor: theme.palette[selectedColor].main,\n      color: theme.palette[selectedColor].contrastText,\n    },\n    '&.Mui-selected:hover': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n    '&.Mui-disabled': {\n      backgroundColor: theme.palette[baseColor].dark,\n    },\n    '&.Mui-selected.Mui-disabled': {\n      backgroundColor: theme.palette[selectedColor].dark,\n    },\n  },\n}));\n\nexport default SolidToggleButtonGroup\n","import { faStar } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Typography } from '@mui/material'\nimport { Rarity } from '../Types/consts'\n\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\n  </Typography>\n\nexport {\n  StarIcon,\n  Stars\n}\n","import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { objectKeyMap } from '../Util/Util'\nimport ColorText from './ColoredText'\nimport { faAnemo, faAtk, faCdReduction, faCritDmg, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRecharge, faGeo, faHealingAdd, faHealingBonus, faHp, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\n\nexport const uncoloredEleIcons = {\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\n} as const\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} sx={{ lineHeight: 1 }} >{uncoloredEleIcons[key]}</ColorText>)\n\nconst StatIcon = {\n  hp_: <FontAwesomeIcon icon={faHp as any} />,\n  hp: <FontAwesomeIcon icon={faHp as any} />,\n\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\n\n  def_: <FontAwesomeIcon icon={faDef as any} />,\n  def: <FontAwesomeIcon icon={faDef as any} />,\n\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\n  critDMG_: <FontAwesomeIcon icon={faCritDmg as any} />,\n  enerRech_: <FontAwesomeIcon icon={faEnergyRecharge as any} />,\n  incHeal_: <FontAwesomeIcon icon={faHealingAdd as any} />,\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\n\n  cdRed_: <FontAwesomeIcon icon={faCdReduction as any} />,\n\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\n\n  ...coloredEleIcon,\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [\n    [`${ele}_dmg_`, coloredEleIcon[ele]],\n    [`${ele}_res_`, coloredEleIcon[ele]],\n    [`${ele}_critDMG_`, coloredEleIcon[ele]],\n    [`${ele}_dmgInc`, coloredEleIcon[ele]],\n    [`${ele}_enemyRes_`, coloredEleIcon[ele]]\n  ]))\n}\n\nexport default StatIcon\n","import Assets from \"../../Assets/Assets\";\nimport ImgIcon from \"../../Components/Image/ImgIcon\";\nimport SqBadge from \"../../Components/SqBadge\";\nimport { Translate } from \"../../Components/Translate\";\nimport { input } from \"../../Formula\";\nimport { Data, NumNode } from \"../../Formula/type\";\nimport { greaterEq } from \"../../Formula/utils\";\nimport { TalentSheet, TalentSheetElement, TalentSheetElementKey } from \"../../Types/character\";\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\nimport { DocumentConditional, DocumentConditionalBase, DocumentSection, IDocumentFields, IDocumentHeader } from \"../../Types/sheet\";\nimport { ascensionMaxLevel } from \"../LevelData\";\nimport { st, trans } from \"../SheetUtil\";\n\nconst characterSheets = import('.').then(imp => imp.default)\n\ninterface ICharacterSheetBase {\n  name: Displayable\n  cardImg: string\n  thumbImg: string\n  thumbImgSide: string\n  barImg?: string\n  bannerImg?: string\n  rarity: Rarity\n  weaponTypeKey: WeaponTypeKey\n  gender: string\n  constellationName: Displayable\n  title: Displayable\n}\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\n  elementKey: ElementKey\n  talent: TalentSheet\n}\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\n  talents: Dict<ElementKey, TalentSheet>\n}\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\n\nexport default class CharacterSheet {\n  sheet: ICharacterSheet;\n  private data: Data | Partial<Record<ElementKey, Data>>;\n  constructor(charSheet: ICharacterSheet, data: Data | Partial<Record<ElementKey, Data>>) {\n    this.sheet = charSheet\n    this.data = data\n  }\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\n  static get getAll() { return characterSheets }\n  get name() { return this.sheet.name }\n  get icon() { return <ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> }\n  get nameWIthIcon() { return <span>{this.icon} {this.name}</span> }\n  get cardImg() { return this.sheet.cardImg }\n  get thumbImg() { return this.sheet.thumbImg }\n  get thumbImgSide() { return this.sheet.thumbImgSide }\n  get bannerImg() { return this.sheet.bannerImg }\n  get rarity() { return this.sheet.rarity }\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\n  get constellationName() { return this.sheet.constellationName }\n\n  isMelee = () => {\n    const weaponTypeKey = this.sheet.weaponTypeKey\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\n  }\n  get isTraveler() {\n    return \"talents\" in this.sheet\n  }\n  getData = (ele: ElementKey = \"anemo\"): Data => {\n    if (\"charKey\" in this.data)\n      return this.data\n    return this.data[ele]!\n  }\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\n    if (\"talent\" in this.sheet) return this.sheet.talent\n    else return this.sheet.talents[eleKey]\n  }\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\n\n  static getLevelString = (level: number, ascension: number): string =>\n    `${level}/${ascensionMaxLevel[ascension]}`\n}\n\nconst talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, docSections?: DocumentSection[]): TalentSheetElement => ({\n  name: tr(`${talentKey}.name`),\n  img,\n  sections: [\n    ...(talentKey !== \"auto\" ? [{ text: tr(`${talentKey}.description`) }] : []),\n    ...(docSections || []),\n  ],\n})\n\nconst talentHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IDocumentHeader => {\n  return {\n    title: tr(`${talentKey}.name`),\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\n    action: <SqBadge color=\"success\">{st(`talents.${talentKey}`)}</SqBadge>,\n    description: tr(`${talentKey}.description`),\n  }\n}\n\nconst headerTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, partialSection: DocumentSection): DocumentSection => ({\n  ...partialSection,\n  header: talentHeader(talentKey, tr, img),\n  canShow: canShowTemplate(talentKey, partialSection.canShow),\n})\n\nconst fieldsTemplate = (talentKey: TalentSheetElementKey, partialFields: IDocumentFields): IDocumentFields => ({\n  ...partialFields,\n  canShow: canShowTemplate(talentKey, partialFields.canShow),\n})\n\nconst conditionalTemplate = (talentKey: TalentSheetElementKey, partialCond: DocumentConditionalBase, tr: (string) => Displayable, img: string): DocumentConditional => ({\n  ...partialCond,\n  header: { ...talentHeader(talentKey, tr, img), ...partialCond.header },\n  canShow: canShowTemplate(talentKey, partialCond.canShow),\n})\n\nconst canShowTalentsNodes: Partial<Record<TalentSheetElementKey, NumNode>> = {\n  \"passive1\": greaterEq(input.asc, 1, 1),\n  \"passive2\": greaterEq(input.asc, 4, 1),\n  \"constellation1\": greaterEq(input.constellation, 1, 1),\n  \"constellation2\": greaterEq(input.constellation, 2, 1),\n  \"constellation3\": greaterEq(input.constellation, 3, 1),\n  \"constellation4\": greaterEq(input.constellation, 4, 1),\n  \"constellation5\": greaterEq(input.constellation, 5, 1),\n  \"constellation6\": greaterEq(input.constellation, 6, 1),\n}\nfunction canShowTemplate(talentKey: TalentSheetElementKey, canShow: NumNode | undefined): NumNode | undefined {\n  if (!canShowTalentsNodes[talentKey]) {\n    return canShow\n  }\n  let compareVal\n  let val\n  if ([\"passive1\", \"passive2\"].includes(talentKey)) {\n    compareVal = input.asc\n    val = +talentKey.slice(-1) === 1 ? 1 : 4\n  } else {\n    compareVal = input.constellation\n    val = +talentKey.slice(-1)\n  }\n  // Try to reuse the base canShow node when possible for caching performance\n  return canShow\n    ? greaterEq(compareVal, val, canShow ? canShow : 1)\n    : canShowTalentsNodes[talentKey]\n}\n\ninterface ICharacterTemplate {\n  talentTemplate: (talentKey: TalentSheetElementKey, docSections?: DocumentSection[]) => TalentSheetElement\n  headerTemplate: (talentKey: TalentSheetElementKey, partialSection: DocumentSection) => DocumentSection\n  fieldsTemplate: (talentKey: TalentSheetElementKey, partialFields: IDocumentFields) => IDocumentFields\n  conditionalTemplate: (talentKey: TalentSheetElementKey, partialCond: DocumentConditionalBase) => DocumentConditional\n}\nexport const charTemplates = (cKey: CharacterKey, wKey: WeaponTypeKey, assets: Partial<Record<TalentSheetElementKey, string>>, travelerEle?: ElementKey): ICharacterTemplate => {\n  const [tr] = cKey === \"Traveler\"\n    ? [(key: string) => <Translate ns=\"char_Traveler_gen\" key18={`${travelerEle}.${key}`} />]\n    : trans(\"char\", cKey)\n  assets.auto = Assets.weaponTypes[wKey]\n  return {\n    talentTemplate: (talentKey: TalentSheetElementKey, docSections?: DocumentSection[]) => talentTemplate(talentKey, tr, assets[talentKey] ?? \"\", docSections),\n    headerTemplate: (talentKey: TalentSheetElementKey, partialSection: DocumentSection) => headerTemplate(talentKey, tr, assets[talentKey] ?? \"\", partialSection),\n    fieldsTemplate: (talentKey: TalentSheetElementKey, partialFields: IDocumentFields) => fieldsTemplate(talentKey, partialFields),\n    conditionalTemplate: (talentKey: TalentSheetElementKey, partialCond: DocumentConditionalBase) => conditionalTemplate(talentKey, partialCond, tr, assets[talentKey] ?? \"\")\n  }\n}\n","import { Translate } from \"../Components/Translate\"\nimport { ReadNode } from \"../Formula/type\"\nimport { customStringRead } from \"../Formula/utils\"\nimport { ArtifactSetKey, CharacterKey, WeaponKey } from \"../Types/consts\"\n\nexport const st = (strKey: string, values?: object) => <Translate ns=\"sheet\" key18={strKey} values={values} />\nexport const sgt = (strKey: string) => <Translate ns=\"sheet_gen\" key18={strKey} />\n\nexport const condReadNode = (path: string[]) => customStringRead([\"conditional\", ...path])\nexport function cond(key: CharacterKey | WeaponKey | ArtifactSetKey, subKey: string): [path: string[], node: ReadNode<string>] {\n  const path = [key, subKey]\n  const node = condReadNode(path)\n  return [path, node]\n}\n\ntype Translated = [tr: ((i18key: string) => Displayable), tran: ((i18key: string, values?: object) => Displayable)]\nexport function trans(typeKey: \"char\", key: CharacterKey): Translated\nexport function trans(typeKey: \"weapon\", key: WeaponKey): Translated\nexport function trans(typeKey: \"artifact\", key: ArtifactSetKey): Translated\nexport function trans(typeKey: \"char\" | \"weapon\" | \"artifact\", key: CharacterKey | WeaponKey | ArtifactSetKey): Translated {\n  return [\n    (strKey: string) => <Translate ns={`${typeKey}_${key}_gen`} key18={strKey} />,\n    (strKey: string, values?: object) => <Translate ns={`${typeKey}_${key}`} key18={strKey} values={values} />\n  ]\n}\n","import Artifact from \"../Data/Artifacts/Artifact\";\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\nimport { ICachedCharacter } from \"../Types/character\";\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\nimport { ICachedWeapon } from \"../Types/weapon\";\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\nimport { input } from \"./index\";\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\nimport { NodeDisplay, UIData } from \"./uiData\";\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\n\nconst asConst = true as const, pivot = true as const\n\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\n    if (path[0] === \"teamBuff\") {\n      path = path.slice(1)\n      if (!x.info) x.info = {}\n      x.info.isTeamBuff = true\n    }\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\n    if (reference)\n      x.info = { ...x.info, ...reference.info, prefix: undefined, source }\n    else if (path[0] !== \"tally\")\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\n  })\n\n  return data\n}\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\n  stats.push([art.mainStatKey, mainStatVal])\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\n  return {\n    art: {\n      ...Object.fromEntries(stats.map(([key, value]) =>\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\n      [art.slotKey]: {\n        id: constant(art.id), set: constant(art.setKey)\n      },\n    },\n    artSet: {\n      [art.setKey]: constant(1),\n    },\n  }\n}\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\n  const result: Data = {\n    lvl: constant(char.level),\n    constellation: constant(char.constellation),\n    asc: constant(char.ascension),\n    infusion: {\n      team: char.infusionAura ? constant(char.infusionAura) : undefined,\n    },\n    premod: {\n      auto: constant(char.talent.auto),\n      skill: constant(char.talent.skill),\n      burst: constant(char.talent.burst),\n    },\n    enemy: {\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\n    },\n    hit: {\n      hitMode: constant(char.hitMode),\n      reaction: constant(char.reactionMode),\n    },\n    customBonus: {},\n  }\n\n  for (const [key, value] of Object.entries(char.bonusStats))\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\n\n  if (char.enemyOverride.enemyDefRed_)\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_ / 100)\n  if (char.enemyOverride.enemyDefIgn_)\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_ / 100)\n\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\n    layeredAssignment(result, keys, constant(x)))\n  return result\n}\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\n  return {\n    weapon: {\n      id: constant(weapon.id),\n      lvl: constant(weapon.level),\n      asc: constant(weapon.ascension),\n      refinement: constant(weapon.refinement),\n      refineIndex: constant(weapon.refinement - 1)\n    },\n  }\n}\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\n  // May the goddess of wisdom bless any and all souls courageous\n  // enough to attempt for the understanding of this abomination.\n\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\n  const result = Object.fromEntries(mergedData.map(([key]) =>\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\n\n  const customReadNodes = {}\n  function getReadNode(path: readonly string[]): ReadNode<number> {\n    const base = (path[0] === \"teamBuff\")\n      ? objPathValue(teamBuff, path.slice(1))\n      : objPathValue(input, path)\n    if (base) return base\n    const custom = objPathValue(customReadNodes, path)\n    if (custom) return custom\n    const newNode = customRead(path)\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\n    layeredAssignment(customReadNodes, path, newNode)\n    return newNode\n  }\n\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\n    mergedData.forEach(([sourceKey, source]) => {\n      const sourceBuff = source.teamBuff\n      // Create new copy of `calc` as we're mutating it later\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\n      buffs.push(buff)\n      calcs[sourceKey] = calc\n\n      // This construction creates a `Data` representing buff\n      // from `source` applying to `target`. It has 3 data:\n      // - `target` contains the reference for the final\n      //   data. It is not populated at this stage,\n      // - `calc` contains the calculation of the buffs,\n      // - `buff` contains read nodes that point to the\n      //   calculation in `calc`.\n\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\n\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\n\n          let readNode: ReadNode<number | string> | undefined, data: Data\n          if (x.path[0] === \"target\") { // Link the node to target data\n            readNode = getReadNode(x.path.slice(1))\n            data = targetRef\n          } else { // Link the node to source data\n            readNode = x\n            data = result[sourceKey].targetRef\n          }\n          layeredAssignment(calc, x.path, resetData(readNode, data))\n        })\n      })\n    })\n  )\n  mergedData.forEach(([targetKey, data]) => {\n    delete data.teamBuff\n    const { targetRef, buffs } = result[targetKey]\n    const buff = mergeData(buffs)\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\n      // CAUTION\n      // This is safe only because `buff` is created using only `resetData`\n      // and `mergeData`. So every node here is created from either of the\n      // two functions, so the mutation wont't affect existing nodes.\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\n    })\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\n    targetRef[\"target\"] = targetRef\n  })\n  const origin = new UIData(undefined as any, undefined)\n  return Object.fromEntries(Object.entries(result).map(([key, value]) =>\n    [key, {\n      target: new UIData(value.targetRef, origin),\n      buffs: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\n        [key, new UIData(value, origin)]))\n    }]))\n}\nfunction mergeData(data: Data[]): Data {\n  function internal(data: any[], path: string[]): any {\n    if (data.length <= 1) return data[0]\n    if (data[0].operation) {\n      if (path[0] === \"teamBuff\") path = path.slice(1)\n      let { accu, type } = (objPathValue(input, path) as ReadNode<number> | ReadNode<string> | undefined) ?? {}\n      if (path[0] === \"tally\") accu = \"add\"\n      else if (accu === undefined) {\n        const errMsg = `Multiple entries when merging \\`unique\\` for key ${path}`\n        if (process.env.NODE_ENV === \"development\")\n          throw new Error(errMsg)\n        else\n          console.error(errMsg)\n\n        accu = type === \"number\" ? \"max\" : \"small\"\n      }\n      const result: NumNode | StrNode = { operation: accu, operands: data }\n      return result\n    } else {\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\n    }\n  }\n  return data.length ? internal(data, []) : {}\n}\n\nfunction computeUIData(data: Data[]): UIData {\n  return new UIData(mergeData(data), undefined)\n}\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\n}\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\n}\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\n  if (data1?.operation || data2?.operation) {\n    const d1 = data1 as NodeDisplay | undefined\n    const d2 = data2 as NodeDisplay | undefined\n\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\n      throw new Error(\"Unmatched structure when comparing UIData\")\n\n    const result: ComparedNodeDisplay = {\n      info: {},\n      operation: true,\n      value: 0,\n      isEmpty: true,\n      unit: d2?.unit!,\n      formulas: [],\n      ...d1,\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\n    }\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\n      // In case `string` got involved, just use the other value\n      result.value = d1?.value ?? \"\" as any\n      result.diff = d2?.value ?? \"\" as any\n    }\n    return result\n  }\n\n  if (data1 || data2) {\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\n  }\n}\n\nexport type { NodeDisplay, UIData };\nexport {\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\n  mergeData, computeUIData, inferInfoMut,\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\n};\n","import { allEleEnemyResKeys } from \"../KeyMap\"\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\nimport { constant, equalStr, frac, infoMut, lookup, max, min, naught, percent, prod, read, res, setReadNodeKeys, stringRead, sum, one } from \"./utils\"\n\nconst asConst = true as const, pivot = true as const\n\nconst allElements = allElementsWithPhy\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\", \"elemental\"] as const\nconst allArtModStats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"heal_\"] as const\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\nconst allMisc = [\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\", \"dmgRed_\", \"healInc\"\n] as const\n\nconst allModStats = [\n  ...allArtModStats,\n  ...([\"all\", \"burning\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\n]\nconst allNonModStats = [\n  ...allElements.flatMap(x => [\n    `${x}_dmgInc` as const,\n    `${x}_critDMG_` as const,\n    `${x}_res_` as const]),\n  ...allMoves.flatMap(x => [\n    `${x}_dmgInc` as const,\n    `${x}_critDMG_` as const,\n    `${x}_critRate_` as const]),\n  \"all_dmgInc\" as const,\n  ...allEleEnemyResKeys,\n  \"enemyDefRed_\" as const,\n  ...allMisc,\n]\n\nconst talent = objectKeyMap(allTalents, _ => read())\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\n\nfor (const ele of allElements) {\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\n  allNonModStatNodes[`${ele}_dmgInc`].info!.variant = ele\n  allModStatNodes[`${ele}_dmg_`].info!.variant = ele\n}\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\n  allModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\n}\n\nfunction withDefaultInfo<T>(info: Info, value: T): T {\n  value = deepClone(value)\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\n  return value\n}\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\n  })\n}\n\n/** All read nodes */\nconst input = setReadNodeKeys(deepClone({\n  activeCharKey: stringRead(),\n  charKey: stringRead(), charEle: stringRead(), weaponType: stringRead(),\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\n\n  infusion: {\n    overridableSelf: stringRead(\"small\"),\n    nonOverridableSelf: stringRead(\"small\"),\n    team: stringRead(\"small\"),\n  },\n\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\n    ...allModStatNodes, ...allNonModStatNodes,\n  }),\n  bonus: { ...talent },\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\n    ...allModStatNodes, ...allNonModStatNodes,\n    /** Total Crit Rate capped to [0%, 100%] */\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\n  }),\n\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\n    ...objectKeyMap(allArtModStats, key => allModStatNodes[key]),\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\n  }),\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\n\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\n    id: stringRead(),\n    key: stringRead(), type: stringRead(),\n\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\n    main: read(), sub: read(), sub2: read(),\n  }),\n\n  enemy: {\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\n\n    level: read(undefined, { key: \"enemyLevel\" }),\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\n    defRed: read(undefined),\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\n  },\n\n  hit: {\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\n    base: read(\"add\", { key: \"base\" }),\n\n    dmgBonus: read(\"add\", { key: \"dmg_\", pivot }),\n    dmgInc: read(\"add\", { key: \"dmgInc\", pivot }),\n    dmg: read(),\n  },\n}))\n\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\n\n// Adjust `info` for printing\nmarkAccu('add', {\n  bonus, customBonus, premod, art,\n  total: objectKeyMap(allModStats, stat => total[stat]),\n})\nbonus.auto.info = { key: \"autoBoost\" }\nbonus.skill.info = { key: \"skillBoost\" }\nbonus.burst.info = { key: \"burstBoost\" }\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\ndelete total.critRate_.info!.pivot\ntotal.critRate_.info!.prefix = \"uncapped\"\n\n// Nodes that are not used anywhere else but `common` below\n\n/** Base Amplifying Bonus */\nconst baseAmpBonus = sum(one, prod(25 / 9, frac(total.eleMas, 1400)))\n/** Effective reaction, taking into account the hit's element */\nexport const effectiveReaction = lookup(hit.ele, {\n  pyro: lookup(hit.reaction, { pyro_vaporize: constant(\"vaporize\"), pyro_melt: constant(\"melt\") }, undefined),\n  hydro: equalStr(hit.reaction, \"hydro_vaporize\", \"vaporize\"),\n  cryo: equalStr(hit.reaction, \"cryo_melt\", \"melt\"),\n}, undefined)\n\nconst common: Data = {\n  premod: {\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\n    ...objectKeyMap(allModStats, key => {\n      const operands: NumNode[] = []\n      switch (key) {\n        case \"atk\": case \"def\": case \"hp\":\n          operands.push(prod(base[key], sum(one, premod[`${key}_`])))\n          break\n        case \"critRate_\":\n          operands.push(percent(0.05, { key, prefix: \"default\" }),\n            lookup(hit.move, objectKeyMap(allMoves, move => premod[`${move}_critRate_`]), 0))\n          break\n        case \"critDMG_\":\n          operands.push(percent(0.5, { key, prefix: \"default\" }),\n            lookup(hit.ele, objectKeyMap(allElements, ele => premod[`${ele}_critDMG_`]), 0),\n            lookup(hit.move, objectKeyMap(allMoves, ele => premod[`${ele}_critDMG_`]), 0))\n          break\n        case \"enerRech_\":\n          operands.push(percent(1, { key, prefix: \"default\" }))\n          break\n      }\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\n    }),\n  },\n  total: {\n    ...objectKeyMap(allTalents, talent => premod[talent]),\n    ...objectKeyMap(allModStats, key => premod[key]),\n    ...objectKeyMap(allNonModStats, key => premod[key]),\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\n\n    cappedCritRate: max(min(total.critRate_, one), naught),\n  },\n\n  hit: {\n    dmgBonus: sum(\n      total.all_dmg_,\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\n    ),\n    dmgInc: sum(\n      total.all_dmgInc,\n      lookup(hit.ele, objectKeyMap(allElements, element => total[`${element}_dmgInc`]), NaN),\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\n    ),\n    dmg: prod(\n      sum(hit.base, hit.dmgInc),\n      sum(one, hit.dmgBonus),\n      lookup(hit.hitMode, {\n        hit: one,\n        critHit: sum(one, total.critDMG_),\n        avgHit: sum(one, prod(total.cappedCritRate, total.critDMG_)),\n      }, NaN),\n      enemy.def,\n      lookup(hit.ele,\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\n      lookup(effectiveReaction, {\n        melt: lookup(hit.ele, {\n          pyro: prod(2, sum(baseAmpBonus, total.melt_dmg_)),\n          cryo: prod(1.5, sum(baseAmpBonus, total.melt_dmg_)),\n        }, 1, { key: \"melt_dmg_\" }),\n        vaporize: lookup(hit.ele, {\n          hydro: prod(2, sum(baseAmpBonus, total.vaporize_dmg_)),\n          pyro: prod(1.5, sum(baseAmpBonus, total.vaporize_dmg_)),\n        }, 1, { key: \"vaporize_dmg_\" }),\n      }, 1),\n    ),\n  },\n\n  enemy: {\n    // TODO: shred cap of 90%\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(one, prod(-1, enemy.defRed)), sum(one, prod(-1, enemy.defIgn)))),\n    defRed: total.enemyDefRed_,\n    ...objectKeyValueMap(allElements, ele =>\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\n  },\n}\n\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\nconst tally = setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"])\n\n/**\n * List of `input` nodes, rearranged to conform to the needs of the\n * UI code. This is a separate list so that the evolution of the UIs\n * does not rely on the structure of `input`. So the UI code can rearrange\n * nodes as it sees fit without requiring updates to data sheets, which\n * pertains ~90% of all `input`-related code, and so are very sensitive\n * to any changes to `input`. For zero overhead, use the nodes directly\n * from `input` instead of a copy.\n */\nconst uiInput = input\n\nexport {\n  input, uiInput, common, customBonus,\n\n  target, tally,\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { uiInput } from \".\"\nimport ColorText from \"../Components/ColoredText\"\nimport KeyMap, { Unit, valueString } from \"../KeyMap\"\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\nimport { allOperations } from \"./optimization\"\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\n\nconst shouldWrap = true\nexport interface NodeDisplay<V = number> {\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\n  operation: true\n  info: Info\n  value: V\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\n  isEmpty: boolean\n  unit: Unit\n  formula?: Displayable\n  formulas: Displayable[]\n}\n\nexport class UIData {\n  origin: UIData\n  children = new Map<Data, UIData>()\n\n  data: Data[]\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\n\n  display: any = undefined\n  teamBuff: any = undefined\n\n  constructor(data: Data, parent: UIData | undefined) {\n    if (data === undefined) {\n      // Secret *origin* initializer\n      this.data = []\n      this.origin = this\n    } else {\n      if (!parent)\n        parent = new UIData(undefined as any, undefined)\n\n      this.data = [data, ...parent.data]\n      this.origin = parent.origin\n    }\n  }\n\n  getDisplay(): {\n    [key: string]: DisplaySub<NodeDisplay>\n  } {\n    if (!this.display) this.display = this.getAll([\"display\"])\n    return this.display\n  }\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\n    if (!this.teamBuff) {\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\n      // Convert `input` to `uiInput`\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\n        if (node) layeredAssignment(result, path, node)\n      })\n      this.teamBuff = result\n    }\n    return this.teamBuff\n  }\n  getAll(prefix: string[]): any {\n    const result = {}\n    for (const data of this.data) {\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\n    }\n    return result\n  }\n  get(node: NumNode): NodeDisplay\n  get(node: StrNode): NodeDisplay<string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\n    if (node === undefined) {\n      console.trace(\"Please report this bug with this trace\")\n      return { info: {}, operation: true, value: undefined, isEmpty: true, unit: \"\", formulas: [] }\n    }\n    const old = this.processed.get(node)\n    if (old) return old\n\n    const result = computeNodeDisplay(this.computeNode(node))\n    this.processed.set(node, result)\n    return result\n  }\n  private computeNode(node: NumNode): ContextNodeDisplay\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\n    const old = this.nodes.get(node)\n    if (old) return old\n\n    const { operation, info } = node\n    let result: ContextNodeDisplay<number | string | undefined>\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        result = this._compute(node); break\n      case \"threshold\": result = this._threshold(node); break\n      case \"const\": result = this._constant(node.value); break\n      case \"subscript\": result = this._subscript(node); break\n      case \"read\": result = this._read(node); break\n      case \"data\": result = this._data(node); break\n      case \"match\": result = this._match(node); break\n      case \"lookup\": result = this._lookup(node); break\n      case \"prio\": result = this._prio(node.operands); break\n      case \"small\": result = this._small(node.operands); break\n      default: assertUnreachable(operation)\n    }\n\n    if (info) {\n      const { asConst } = info\n      result = { ...result }\n      result.info = mergeInfo(result.info, info)\n\n      // Pivot all keyed nodes for debugging\n      // if (key) result.info.pivot = true\n\n      if (asConst) {\n        delete result.formula\n        delete result.assignment\n        result.dependencies = new Set()\n      }\n      if (result.pivot || !result.formula)\n        result.mayNeedWrapping = false\n    }\n    createDisplay(result)\n\n    this.nodes.set(node, result)\n    return result\n  }\n\n  private prereadAll(path: readonly string[]): (NumNode | StrNode)[] {\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x)\n  }\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\n    return data && this.computeNode(data)\n  }\n\n  private _prio(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\n    const first = nodes.find(node => this.computeNode(node).value !== undefined)\n    return first ? this.computeNode(first) : illformedStr\n  }\n  private _small(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\n    let smallest: ContextNodeDisplay<string | undefined> | undefined = undefined\n    for (const node of nodes) {\n      const candidate = this.computeNode(node)\n      if (smallest?.value === undefined || (candidate.value && candidate.value < smallest.value))\n        smallest = candidate\n    }\n    return smallest ?? illformedStr\n  }\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\n    const { path } = node\n    if (node.accu === undefined) {\n      return this.readFirst(path) ?? (node.type === \"string\" ? illformedStr : illformed)\n    } else {\n      const nodes = this.prereadAll(path)\n      if (nodes.length === 1) return this.computeNode(nodes[0])\n      return node.accu === \"small\"\n        ? this._small(nodes as StrNode[])\n        : this._accumulate(node.accu, nodes.map(x => this.computeNode(x)) as ContextNodeDisplay[])\n    }\n  }\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const key = this.computeNode(node.operands[0]).value\n    const selected = node.table[key!] ?? node.operands[1]\n    if (!selected)\n      throw new Error(`Lookup Fail with key ${key}`)\n    return this.computeNode(selected)\n  }\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\n    const matching = v1.value === v2.value\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\n      ? makeEmpty(result.value) : result\n  }\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    const [valueNode, thresholdNode, pass, fail] = node.operands\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\n    return (value.value >= threshold.value)\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\n  }\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\n    let child = this.children.get(node.data)\n    if (!child) {\n      child = new UIData(node.data, node.reset ? this.origin : this)\n      this.children.set(node.data, child)\n    }\n    return child.computeNode(node.operands[0])\n  }\n  private _compute(node: ComputeNode): ContextNodeDisplay {\n    const { operation, operands } = node\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\n  }\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\n    const operand = this.computeNode(node.operands[0])\n    const value = node.list[operand.value] ?? NaN\n    return this._constant(value)\n  }\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\n    return {\n      info: {},\n      value, pivot: false,\n      empty: false,\n      mayNeedWrapping: false,\n      dependencies: new Set(),\n    }\n  }\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\n    let variant: Variant | undefined\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n      case \"res\": case \"sum_frac\":\n        variant = mergeVariants(operands); break\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\": case \"min\": case \"max\":\n        const identity = allOperations[operation]([])\n        if (process.env.NODE_ENV !== \"development\")\n          operands = operands.filter(operand => operand.value !== identity)\n        if (!operands.length)\n          return variant ? { ...this._constant(identity), info: { variant } } : this._constant(identity)\n    }\n\n    let formula: { display: Displayable, dependencies: Displayable[] }\n    let mayNeedWrapping = false\n    switch (operation) {\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap: operands.length > 1 }}`; break\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\n      case \"res\": {\n        const base = operands[0].value\n        if (base < 0) {\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\n          mayNeedWrapping = true\n        }\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\n        else {\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\n          mayNeedWrapping = true\n        }\n        break\n      }\n      default: assertUnreachable(operation)\n    }\n    switch (operation) {\n      case \"add\": case \"mul\":\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\n        else if (operation === \"add\") mayNeedWrapping = true\n    }\n\n    const value = allOperations[operation](operands.map(x => x.value))\n    const dependencies = new Set([...operands.flatMap(x =>\n      x.pivot && x.assignment\n        ? [x.assignment, ...x.dependencies]\n        : [...x.dependencies])])\n    const result: ContextNodeDisplay = {\n      info: { variant },\n      formula: formula.display,\n      empty: operands.every(x => x.empty),\n      value, mayNeedWrapping,\n      pivot: false, dependencies,\n    }\n    return result\n  }\n}\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\n  const dependencies = new Set<Displayable>()\n  const predisplay: Displayable[] = []\n\n  strings.forEach((string, i) => {\n    predisplay.push(string)\n\n    const key = list[i]\n    if (key) {\n      const { operands, shouldWrap, separator = \", \" } = key\n      operands.forEach((item, i, array) => {\n        let itemFormula: Displayable\n        if (!item.pivot && item.formula) itemFormula = item.formula\n        else itemFormula = createFormulaComponent(item)\n\n        if (shouldWrap && item.mayNeedWrapping) {\n          predisplay.push(\"( \")\n          predisplay.push(itemFormula)\n          predisplay.push(\" )\")\n        } else {\n          predisplay.push(itemFormula)\n        }\n        if (i + 1 < array.length) predisplay.push(separator)\n        item.dependencies.forEach(x => dependencies.add(x))\n      })\n    }\n  })\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\n}\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): Info[\"variant\"] {\n  const unique = new Set(operands.map(x => x.info.variant))\n  if (unique.size > 1) unique.delete(undefined)\n  if (unique.size > 1) unique.delete(\"physical\")\n  // Prefer reactions\n  if (unique.has(\"melt\")) return \"melt\"\n  if (unique.has(\"vaporize\")) return \"vaporize\"\n  return unique.values().next().value\n}\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\n  const { info, dependencies, value, formula, assignment, empty } = node\n  return {\n    operation: true,\n    info,\n    value,\n    isEmpty: empty,\n    unit: KeyMap.unit(info.key),\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\n  }\n}\n\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { info, value, formula } = node\n  const { key, prefix, source, variant, fixed } = info\n  if (typeof value !== \"number\") return\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, KeyMap.unit(key), fixed)}</ColorText>\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.get(key!)}</ColorText>{sourceDisplay}</>\n\n    if (formula)\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  //TODO: change formula size in the formula display element instead\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\n}\n/*/\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\n  const { info, value, formula } = node\n  const { key, prefix, source, fixed } = info\n  if (typeof value !== \"number\") return\n  node.valueDisplay = valueString(value, KeyMap.unit(key), fixed)\n  if (key && key !== '_') {\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\n    // TODO: Convert `source` key to actual name\n    const sourceDisplay = source ? ` ${source}` : \"\"\n    node.name = `${prefixDisplay}${KeyMap.getStr(key!)}${sourceDisplay}`\n\n    if (formula)\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\n  }\n}\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\n  const { name, valueDisplay } = node\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\n}\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\n  return (components as string[]).join(\"\")\n}\n//*/\n\nfunction mergeInfo(base: Info, override: Info): Info {\n  const result = { ...base }\n  for (const [key, value] of Object.entries(override))\n    if (value) result[key] = value as any\n  return result\n}\n\ninterface ContextNodeDisplay<V = number> {\n  info: Info\n\n  pivot: boolean\n  empty: boolean\n\n  value: V\n\n  dependencies: Set<Displayable>\n\n  mayNeedWrapping: boolean // Whether this formula should be parenthesized when it is a part of multiplications/divisions and subtractions' subtrahends\n\n  // Don't set these manually outside of `UIData.computeNode`\n  name?: Displayable\n  valueDisplay?: Displayable\n  formula?: Displayable\n  assignment?: Displayable\n}\n\nconst illformed: ContextNodeDisplay = {\n  info: {},\n  value: NaN, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nconst illformedStr: ContextNodeDisplay<string | undefined> = {\n  info: {},\n  value: undefined, pivot: true,\n  empty: false,\n  dependencies: new Set(),\n  mayNeedWrapping: false\n}\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\n  return {\n    info: {}, value: emptyValue, pivot: false, empty: true, dependencies: new Set(), mayNeedWrapping: false\n  }\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\n/** v1 >= v2 ? pass : fail */\nexport function cmp(v1: Num, v2: Num, pass: Num, fail: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n","import { useCallback, useContext, useEffect, useState } from \"react\";\nimport { DatabaseContext } from \"../Database/Database\";\n\nexport default function useDBState<O extends object>(key: string, init: () => O): [O, (value: Partial<O>) => void] {\n  const { database } = useContext(DatabaseContext)\n  const [state, setState] = useState(database._getState<O>(key, init))\n\n  useEffect(() => setState(database._getState(key, init)), [database, key, init])\n  useEffect(() =>\n    key ? database.followState(key, setState) : undefined,\n    [key, setState, database])\n  const updateState = useCallback(\n    value => database.updateState(key, value),\n    [database, key],\n  )\n\n  return [state, updateState]\n}\n","import { useCallback, useState } from \"react\"\n\nexport default function useForceUpdate(): [object, () => void] {\n  const [stateDirty, update] = useState({})\n  const forceUpdateHook = useCallback(() => update({}), [])\n  return [stateDirty, forceUpdateHook]\n}","import { useEffect, useState } from \"react\";\n/**\n *\n * @param promise\n * @param dependencies - Reloads the promise when any of the dependencies are changed. (Using useEffect dependency)\n * @param useOld - When the promises are updated, then there is a period of time before the new promise return. useOld uses the previous value without a undefined gap.\n * @returns\n */\nexport default function usePromise<T>(promise: Promise<T> | undefined, dependencies: any[], useOld = true): T | undefined {\n  const [res, setRes] = useState<T | undefined>(undefined);\n  useEffect(() => {\n    let pending = true\n    promise?.then(res => pending && setRes(() => res), console.error) ?? setRes(undefined)\n    return () => {\n      pending = false\n      !useOld && setRes(undefined)\n    }\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\n  return res\n}\n","import CharacterSheet from \"../Data/Characters/CharacterSheet\";\nimport { ArtCharDatabase } from \"../Database/Database\";\nimport i18n from \"../i18n\";\nimport { CharacterKey } from \"../Types/consts\";\nimport { FilterConfigs, SortConfigs } from \"./SortByFilters\";\nexport const characterSortKeys = [\"level\", \"rarity\", \"name\"]\nexport type CharacterSortKey = typeof characterSortKeys[number]\n\nexport function characterSortConfigs(database: ArtCharDatabase, characterSheets: Record<CharacterKey, CharacterSheet>): SortConfigs<CharacterSortKey, CharacterKey> {\n  return {\n    new: {\n      getValue: (ck) => database._getChar(ck as CharacterKey) ? 0 : 1,\n      tieBreaker: \"name\"\n    },\n    name: {\n      // TODO: #412 - Enforce that the character names are loaded: getValue: (ck) => i18n.t(`char_${ck}_gen:name`).toString(),\n      getValue: (ck) => ck\n    },\n    level: {\n      getValue: (ck) => database._getChar(ck as CharacterKey)?.level ?? 0,\n      tieBreaker: \"rarity\"\n    },\n    rarity: {\n      getValue: (ck) => characterSheets?.[ck]?.rarity,\n      tieBreaker: \"level\"\n    }\n  }\n}\n\nexport type CharacterFilterConfigs = FilterConfigs<\"element\" | \"weaponType\" | \"favorite\" | \"name\", CharacterKey>\nexport function characterFilterConfigs(database: ArtCharDatabase, characterSheets: Record<CharacterKey, CharacterSheet>): CharacterFilterConfigs {\n  return {\n    element: (ck, filter) => !filter || (filter === characterSheets?.[ck]?.elementKey) || (ck === \"Traveler\" && database._getChar(ck as CharacterKey)?.elementKey === filter),\n    weaponType: (ck, filter) => !filter || (filter === characterSheets?.[ck]?.weaponTypeKey),\n    favorite: (ck, filter) =>\n      !filter || (filter === (database._getChar(ck as CharacterKey)?.favorite ? \"yes\" : \"no\")),\n    name: (ck, filter) => !filter || (i18n.t(`char_${ck}_gen:name`).toLowerCase().includes(filter.toLowerCase()))\n  }\n}\n","type SortConfig<T> = {\n  getValue: (id: T) => number | string\n  tieBreaker?: string\n}\nexport type SortConfigs<Keys extends string, T> = Record<Keys, SortConfig<T>>\n\nexport function sortFunction<Keys extends string, T>(sortby: string, ascending: boolean, configs: SortConfigs<Keys, T>) {\n  function Sort(a: T, b: T, ascending: boolean, config: SortConfig<T>) {\n    const aV = config.getValue(a)\n    const bV = config.getValue(b)\n    let diff = 0\n    if (typeof aV === \"string\" && typeof bV === \"string\")\n      diff = aV.localeCompare(bV)\n    else\n      diff = ((bV as number) - (aV as number))\n    return (ascending ? -1 : 1) * diff\n  }\n  return (a: T, b: T) => {\n    if (!configs[sortby]) return 0\n    const filterOption = configs[sortby]\n    let diff = Sort(a, b, ascending, filterOption)\n    if (!diff && filterOption.tieBreaker && configs[filterOption.tieBreaker])\n      diff = Sort(a, b, ascending, configs[filterOption.tieBreaker])\n    return diff\n  }\n}\n\ntype FilterConfig<T> = (obj: T, filter: any) => boolean\nexport type FilterConfigs<Keys extends string, T> = Record<Keys, FilterConfig<T>>\nexport function filterFunction<Keys extends string, T>(filterOptions: Record<Keys, any>, filterConfigs: FilterConfigs<Keys, T>) {\n  return (obj: T) => Object.entries(filterOptions).every(([optionKey, optionVal]) => filterConfigs[optionKey as any] && filterConfigs[optionKey as any](obj, optionVal))\n}\n"],"names":["weaponTypes","bow","catalyst","claymore","polearm","sword","slot","flower","plume","sands","goblet","circlet","resin","fragile","condensed","exp_books","advice","wit","experience","team","team1","team2","team3","team4","CardDark","styled","Card","backgroundColor","theme","palette","contentDark","main","CardLight","contentLight","CloseButton","large","props","t","useTranslation","color","startIcon","sx","p","minWidth","ConditionalWrapper","condition","wrapper","falseWrapper","children","DropdownButton","title","id","useState","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","Suspense","fallback","endIcon","width","undefined","onClick","onClose","MenuListProps","height","ImgIcon","name","size","display","verticalAlign","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","padding","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","variant","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","contrastText","dark","transition","StarIcon","icon","faStar","Stars","stars","colored","component","Array","keys","map","_","i","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","hydro","faHydro","pyro","faPyro","cryo","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","objectKeyMap","Object","key","lineHeight","StatIcon","hp_","faHp","hp","atk_","faAtk","atk","def_","faDef","def","eleMas","faElementalMastery","critRate_","faCritRate","critDMG_","faCritDmg","enerRech_","faEnergyRecharge","incHeal_","faHealingAdd","heal_","faHealingBonus","cdRed_","faCdReduction","shield_","faShieldStrength","stamina","faMaxStamina","fromEntries","flatMap","ele","characterSheets","then","imp","default","CharacterSheet","charSheet","data","sheet","isMelee","weaponTypeKey","getData","getTalent","eleKey","talent","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","charKey","c","getLevelString","level","ascension","ascensionMaxLevel","talentHeader","tr","img","m","action","st","description","canShowTalentsNodes","greaterEq","input","canShowTemplate","canShow","includes","compareVal","val","slice","charTemplates","cKey","wKey","assets","travelerEle","ns","key18","trans","auto","Assets","talentTemplate","docSections","sections","text","headerTemplate","partialSection","header","fieldsTemplate","partialFields","conditionalTemplate","partialCond","strKey","values","sgt","condReadNode","path","customStringRead","cond","subKey","typeKey","inferInfoMut","source","crawlObject","x","operation","info","isTeamBuff","reference","objPathValue","prefix","console","error","dataObjForArtifact","art","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatKey","Math","max","min","stats","push","substats","forEach","accurateValue","value","endsWith","percent","constant","slotKey","set","setKey","artSet","dataObjForCharacter","char","result","lvl","constellation","asc","infusion","infusionAura","premod","skill","burst","enemy","allElementsWithPhy","enemyOverride","enemyLevel","hit","hitMode","reaction","reactionMode","customBonus","entries","bonusStats","enemyDefRed_","enemyDefIgn_","defIgn","conditional","layeredAssignment","dataObjForWeapon","weapon","refinement","refineIndex","teamBuff","setReadNodeKeys","deepClone","uiDataForTeam","teamData","activeCharKey","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","base","custom","newNode","customRead","accu","sourceKey","sourceBuff","buff","calc","asConst","resetData","readNode","targetKey","pivot","assign","origin","UIData","target","length","internal","type","errMsg","operands","Set","filter","computeUIData","allElements","allTalents","allMoves","allArtModStats","allTransformative","allAmplifying","allModStats","allNonModStats","allEleEnemyResKeys","read","allModStatNodes","allNonModStatNodes","withDefaultInfo","stringRead","charEle","weaponType","special","overridableSelf","nonOverridableSelf","bonus","total","objectKeyValueMap","cappedCritRate","allSlotKeys","allArtifactSets","sub","sub2","defRed","move","dmgBonus","dmgInc","dmg","stat","baseAmpBonus","sum","one","prod","frac","effectiveReaction","lookup","pyro_vaporize","pyro_melt","equalStr","common","naught","all_dmg_","all_dmgInc","element","NaN","critHit","avgHit","melt","melt_dmg_","vaporize","vaporize_dmg_","res","infoMut","tally","allRegions","uiInput","forEachNodes","formulas","topDown","bottomUp","visiting","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","arrayEqual","a","b","every","allCommutativeMonoidOperations","reduce","mul","allOperations","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","precompute","binding","uniqueReadStrings","uniqueNumbers","mapping","f","Error","ins","op","assertUnreachable","locations","readStrings","readOffset","constValues","computations","str","offset","ref","node","out","fill","buffer","array","number","copyList","copyFormula","dst","j","flattened","dep","elementCounts","wrap","counts","next","factored","count","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","smallest","v1","v2","match","unmatch","list","reset","nextContext","shouldWrap","parent","nodes","getAll","calculated","trace","isEmpty","unit","dependencies","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","_prio","_small","override","mergeInfo","mayNeedWrapping","fixed","valueDisplay","valueString","prefixDisplay","sourceDisplay","createDisplay","illformedStr","readFirst","illformed","prereadAll","_accumulate","v1Node","v2Node","matchNode","unmatchNode","matching","emptyOn","makeEmpty","valueNode","thresholdNode","child","operand","unique","mergeVariants","identity","fStr","separator","strings","predisplay","string","item","itemFormula","createFormulaComponent","mergeFormulaComponents","style","fontSize","components","emptyValue","Number","MAX_VALUE","Infinity","defaultV","intoV","intoOps","equal","unequal","greaterEqStr","lessThan","cmp","nodeList","stringPrio","subscript","matchFull","useDBState","init","database","useContext","DatabaseContext","_getState","state","setState","useEffect","followState","updateState","useForceUpdate","stateDirty","update","usePromise","promise","useOld","setRes","pending","characterSortKeys","characterSortConfigs","new","getValue","ck","_getChar","tieBreaker","characterFilterConfigs","favorite","i18n","toLowerCase","sortFunction","sortby","ascending","configs","Sort","config","aV","bV","localeCompare","filterOption","diff","filterFunction","filterOptions","filterConfigs","obj","optionKey","optionVal"],"sourceRoot":""}