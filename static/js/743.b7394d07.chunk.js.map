{"version":3,"file":"static/js/743.b7394d07.chunk.js","mappings":"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AAOC,UAAW,IAAIxE,KACtEyE,EAAepE,IAAI2F,EAAa,IAAIhG,KACpCzD,EAAI8D,IAAIb,EAAQ+E,KAAMyB,IAExB1F,EAASoE,EAAKlF,EAAQrB,SAAS,GAAI6H,GACnC,MACF,QAAS7I,EAAkBe,GAI7B,OADAyG,EAAQH,UAAUnE,IAAIb,EAASc,GACxBA,CACR,CAED,IAAMqE,EAAU,CAAEJ,KAAM,CAACH,GAAeI,UAAW,IAAIxE,KAGvD,OAFAyE,EAAepE,IAAIsE,EAAS,IAAI3E,KAChCyE,EAAetE,IAAImE,GAASjE,IAAI+D,EAAcO,GACvC3F,EAASzC,KAAI,SAAAqE,GAAC,OAAI8D,EAAK9D,EAAG+D,EAAZ,GACtB,CAEM,ICxWMsB,EAAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAUrDC,GARkB,CAAI,YAAJ,OADJ,CAAC,QAAS,MAAO,UAAW,QAAS,OAAQ,OAAQ,WASjD,CAC7B,aACA,eACA,YACA,kBACA,uBACA,aACA,uBACA,mBACA,gBACA,qBACA,sBACA,UACA,eACA,mBACA,eACA,sBACA,aACA,aACA,WACA,gBACA,gBACA,iBACA,gBACA,YACA,oBACA,yBACA,mBACA,sBACA,wBACA,kBACA,UACA,yBACA,yBACA,WACA,iBACA,iBACA,cACA,kBACA,sBACA,qBACA,oBAEWC,EAA2B,CACtC,SACA,QACA,UACA,SACA,UACA,WACA,QACA,QACA,SACA,QACA,QACA,OACA,QACA,SACA,OACA,YACA,cACA,OACA,OACA,YACA,SACA,OACA,QACA,UACA,YACA,eACA,QACA,YACA,OACA,UACA,SACA,UACA,SACA,OACA,kBACA,gBACA,OACA,SACA,UACA,OACA,oBACA,QACA,QACA,cACA,UACA,SACA,UACA,gBACA,QACA,kBACA,SACA,OACA,YAwBWC,GAtBqB,UAC7BD,EAD6B,CAEhC,aAoB0B,CAC1B,gBACA,cACA,kBACA,mBAE2B,UACxBA,EACAC,GAG6B,UAC7BD,EAxBwB,CAC3B,iBACA,eACA,mBACA,mBAE2B,CAC3B,iBACA,eACA,mBACA,oBAoLwB,UAjKQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,eACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,eACA,gB,qBC4EeE,GAAAA,GAAAA,EAAAA,EAAAA,KAAAA,KAoBAC,GA3VV,SAASC,EAASC,EAAkBC,GAAmG,IAA5EC,EAA2E,wDACrIC,EAAc,IAAIvH,IAAgBwH,EAAiB,IAAIxH,IAE7D,SAASyH,EAAMC,EAAeC,GACxBA,EAAUJ,EAAYjH,IAAIoH,GACzBA,EAAK3I,SAASmB,SAAQ,SAAA0H,GACzB,IAAMzB,EAAKyB,EACXL,EAAYlH,IAAI8F,IAAOqB,EAAelH,IAAI6F,EAC3C,GACF,CAED,IAAM0B,EAAU,IAAI7H,IA6BpB,GA3BAL,EAAayH,GAAO,SAAA3E,GAAQ,IAAE,SAAAC,GAC5B,IAAM5D,EAAY4D,EAAE5D,UAC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","sources":["Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","Formula/expandPoly.ts","Formula/solveLP_simplex.ts","Formula/linearUpperBound.ts","Formula/addedUtils.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/subproblemUtil.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/SplitWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map(t => map(t))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap(d => b.map(e => [d, [e]].flat())), [[]] as T[][])\n}\n\nexport function partition<T>(q: T[], length: number): T[][] {\n  let rest = q.length % length\n  let size = Math.floor(q.length / length)\n  let j = 0;\n  return Array.from({ length }, (_, i) => q.slice(j, j += size + (i < rest ? 1 : 0)));\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze(obj: any, layers: number = 5) {\n  if (layers === 0) return\n  if (typeof obj === \"object\")\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\n}\n\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\n  if (newIndex < 0 || newIndex >= arr.length) return arr\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\n  return arr\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\nexport const none = constant(\"none\")\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? eq : neq */\nexport function compareEq(v1: Num, v2: Num, eq: Num, neq: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function compareEq(v1: Num, v2: Num, eq: Str, neq: Str, info?: Info): MatchNode<NumNode, StrNode>\nexport function compareEq(v1: Str, v2: Str, eq: Num, neq: Num, info?: Info): MatchNode<StrNode, NumNode>\nexport function compareEq(v1: Str, v2: Str, eq: Str, neq: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function compareEq(v1: Num | Str, v2: Num | Str, eq: Num | Str, neq: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)], info }\n}\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<NumNode | StrNode, StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 != v2 ? pass : `undefined` */\nexport function unequalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\nexport function unequalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function unequalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<NumNode | StrNode, StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(undefined), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\n/** v1 >= v2 ? pass : fail */\nexport function cmp(v1: Num, v2: Num, pass: Num, fail: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, `equalStr`, or `compareEq` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n\nexport function cmpNode(a: NumNode, b: NumNode): boolean {\n  if (a.operation !== b.operation) return false;\n  if (a.operands.length !== b.operands.length) return false;\n\n  switch (a.operation) {\n    case 'read':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.path.every((ai, i) => ai === b.path[i])\n    case 'const':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.value === b.value\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      let used = [] as number[]\n      return a.operands.every((ai, i) => b.operands.some((bj, j) => {\n        if (used.includes(j)) return false\n        if (cmpNode(ai, bj)) {\n          used.push(j)\n          return true\n        }\n        return false\n      }))\n    default:\n      return a.operands.every((ai, i) => cmpNode(ai as NumNode, b.operands[i] as NumNode))\n  }\n}\n\n// Hash function pulled from StackOverflow\n//   https://stackoverflow.com/a/52171480\nconst cyrb53 = function (str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n\n// I made these numbers up; we might get better performance with different choice.\nexport function hashNode(n: NumNode): number {\n  let hsh = Math.imul(cyrb53(n.operation), 5234543537);\n  switch (n.operation) {\n    case 'const':\n      return hsh ^ cyrb53(n.value.toString(2))\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      return n.operands.reduce((hsh, ni) => hsh ^ hashNode(ni), hsh)\n    default:\n      return (n.operands as NumNode[]).reduce((hsh, ni) => Math.imul(hsh ^ hashNode(ni), 9923429423), hsh)\n  }\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import type { ArtifactBuildData } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], initial: ArtifactBuildData[\"values\"], binding: (readNode: ReadNode<number> | ReadNode<string | undefined>) => string, slotCount: number): (_: ArtifactBuildData[]) => number[] {\n  let body = `\n\"use strict\";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n};\nconst x0=0`; // making sure `const` has at least one entry\n\n  let i = 1;\n  const names = new Map<NumNode | StrNode, string>()\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation, operands } = f, name = `x${i++}`, operandNames = operands.map(x => names.get(x)!)\n    names.set(f, name)\n    switch (operation) {\n      case \"read\": {\n        const key = binding(f)\n        let arr = new Array(slotCount).fill(null).map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\n        if (initial[key] && initial[key] !== 0) {\n          arr = [initial[key].toString(), ...arr]\n        }\n        body += `,${name}=${arr.join('+')}`\n        break\n      }\n      case \"const\": names.set(f, `(${f.value})`); break\n      case \"add\": case \"mul\": body += `,${name}=${operandNames.join(operation === \"add\" ? \"+\" : \"*\")}`; break\n      case \"min\": case \"max\": body += `,${name}=Math.${operation}(${operandNames})`; break\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandNames\n        body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\n        break\n      }\n      case \"res\": body += `,${name}=res(${operandNames[0]})`; break\n      case \"sum_frac\": body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`; break\n\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n  body += `;\\nreturn [${formulas.map(f => names.get(f)!)}]`\n  return new (Function as any)(`b`, body)\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (pass.operation === \"const\" && fail.operation === \"const\" && pass.value === fail.value)\n          result = pass\n        else if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allAmpReactions = [\"vaporize\", \"melt\",] as const\nexport const allAdditiveReactions = [\"spread\", \"aggravate\"] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allInfusionAuraElements = [\"pyro\", 'cryo'] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allRollColorKeys = ['roll1', 'roll2', 'roll3', 'roll4', 'roll5', 'roll6'] as const\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = [\"max\", \"mid\", \"min\"] as const\n\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  \"DeepwoodMemories\",\n  \"DefendersWill\",\n  \"EchoesOfAnOffering\",\n  \"EmblemOfSeveredFate\",\n  \"Gambler\",\n  \"GildedDreams\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  \"HuskOfOpulentDreams\",\n  \"Instructor\",\n  \"Lavawalker\",\n  \"LuckyDog\",\n  \"MaidenBeloved\",\n  \"MartialArtist\",\n  \"NoblesseOblige\",\n  \"OceanHuedClam\",\n  \"PaleFlame\",\n  \"PrayersForDestiny\",\n  \"PrayersForIllumination\",\n  \"PrayersForWisdom\",\n  \"PrayersToSpringtime\",\n  \"ResolutionOfSojourner\",\n  \"RetracingBolide\",\n  \"Scholar\",\n  \"ShimenawasReminiscence\",\n  \"TenacityOfTheMillelith\",\n  \"TheExile\",\n  \"ThunderingFury\",\n  \"Thundersoother\",\n  \"TinyMiracle\",\n  \"TravelingDoctor\",\n  \"VermillionHereafter\",\n  \"ViridescentVenerer\",\n  \"WanderersTroupe\",\n] as const\nexport const nonTravelerCharacterKeys = [\n  \"Albedo\",\n  \"Amber\",\n  \"Barbara\",\n  \"Beidou\",\n  \"Bennett\",\n  \"Chongyun\",\n  \"Diluc\",\n  \"Diona\",\n  \"Fischl\",\n  \"Ganyu\",\n  \"HuTao\",\n  \"Jean\",\n  \"Kaeya\",\n  \"Keqing\",\n  \"Klee\",\n  \"KujouSara\",\n  \"KukiShinobu\",\n  \"Lisa\",\n  \"Mona\",\n  \"Ningguang\",\n  \"Noelle\",\n  \"Qiqi\",\n  \"Razor\",\n  \"Sucrose\",\n  \"Tartaglia\",\n  \"RaidenShogun\",\n  \"Venti\",\n  \"Xiangling\",\n  \"Xiao\",\n  \"Xingqiu\",\n  \"Xinyan\",\n  \"Rosaria\",\n  \"Yanfei\",\n  \"Eula\",\n  \"KaedeharaKazuha\",\n  \"KamisatoAyaka\",\n  \"Sayu\",\n  \"Shenhe\",\n  \"Yoimiya\",\n  \"Aloy\",\n  \"SangonomiyaKokomi\",\n  \"Thoma\",\n  \"Gorou\",\n  \"AratakiItto\",\n  \"YaeMiko\",\n  \"YunJin\",\n  \"Zhongli\",\n  \"KamisatoAyato\",\n  \"Yelan\",\n  \"ShikanoinHeizou\",\n  \"Collei\",\n  \"Dori\",\n  \"Tighnari\",\n] as const\nexport const locationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  \"Traveler\",\n] as const\nexport const travelerElements = [\n  \"anemo\",\n  \"geo\",\n  \"electro\",\n  \"dendro\"\n] as const\nexport const travelerFKeys = [\n  \"TravelerAnemoF\",\n  \"TravelerGeoF\",\n  \"TravelerElectroF\",\n  \"TravelerDendroF\",\n] as const\nexport const travelerMKeys = [\n  \"TravelerAnemoM\",\n  \"TravelerGeoM\",\n  \"TravelerElectroM\",\n  \"TravelerDendroM\",\n] as const\nexport const travelerKeys = [\n  \"TravelerAnemo\",\n  \"TravelerGeo\",\n  \"TravelerElectro\",\n  \"TravelerDendro\",\n] as const\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\nexport const allWeaponSwordKeys = [\n  \"AmenomaKageuchi\",\n  \"AquilaFavonia\",\n  \"BlackcliffLongsword\",\n  \"CinnabarSpindle\",\n  \"CoolSteel\",\n  \"KagotsurubeIsshin\",\n  \"DarkIronSword\",\n  \"DullBlade\",\n  \"FavoniusSword\",\n  \"FesteringDesire\",\n  \"FilletBlade\",\n  \"FreedomSworn\",\n  \"HaranGeppakuFutsu\",\n  \"HarbingerOfDawn\",\n  \"IronSting\",\n  \"LionsRoar\",\n  \"MistsplitterReforged\",\n  \"PrimordialJadeCutter\",\n  \"PrototypeRancour\",\n  \"RoyalLongsword\",\n  \"SacrificialSword\",\n  \"SapwoodBlade\",\n  \"SilverSword\",\n  \"SkyriderSword\",\n  \"SkywardBlade\",\n  \"SummitShaper\",\n  \"SwordOfDescension\",\n  \"TheAlleyFlash\",\n  \"TheBlackSword\",\n  \"TheFlute\",\n  \"TravelersHandySword\",\n] as const\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\n\nexport const allWeaponClaymoreKeys = [\n  \"Akuoumaru\",\n  \"BlackcliffSlasher\",\n  \"BloodtaintedGreatsword\",\n  \"DebateClub\",\n  \"FavoniusGreatsword\",\n  \"FerrousShadow\",\n  \"ForestRegalia\",\n  \"KatsuragikiriNagamasa\",\n  \"LithicBlade\",\n  \"LuxuriousSeaLord\",\n  \"OldMercsPal\",\n  \"PrototypeArchaic\",\n  \"Rainslasher\",\n  \"RedhornStonethresher\",\n  \"RoyalGreatsword\",\n  \"SacrificialGreatsword\",\n  \"SerpentSpine\",\n  \"SkyriderGreatsword\",\n  \"SkywardPride\",\n  \"SnowTombedStarsilver\",\n  \"SongOfBrokenPines\",\n  \"TheBell\",\n  \"TheUnforged\",\n  \"WasterGreatsword\",\n  \"Whiteblind\",\n  \"WhiteIronGreatsword\",\n  \"WolfsGravestone\",\n] as const\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\n\nexport const allWeaponPolearmKeys = [\n  \"BeginnersProtector\",\n  \"BlackcliffPole\",\n  \"BlackTassel\",\n  \"CalamityQueller\",\n  \"CrescentPike\",\n  \"Deathmatch\",\n  \"DragonsBane\",\n  \"DragonspineSpear\",\n  \"EngulfingLightning\",\n  \"FavoniusLance\",\n  \"Halberd\",\n  \"IronPoint\",\n  \"KitainCrossSpear\",\n  \"LithicSpear\",\n  \"Moonpiercer\",\n  \"PrimordialJadeWingedSpear\",\n  \"PrototypeStarglitter\",\n  \"RoyalSpear\",\n  \"SkywardSpine\",\n  \"StaffOfHoma\",\n  \"TheCatch\",\n  \"VortexVanquisher\",\n  \"WavebreakersFin\",\n  \"WhiteTassel\",\n] as const\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\n\nexport const allWeaponBowKeys = [\n  \"AlleyHunter\",\n  \"AmosBow\",\n  \"AquaSimulacra\",\n  \"BlackcliffWarbow\",\n  \"CompoundBow\",\n  \"ElegyForTheEnd\",\n  \"FadingTwilight\",\n  \"FavoniusWarbow\",\n  \"Hamayumi\",\n  \"HuntersBow\",\n  \"HuntersPath\",\n  \"KingsSquire\",\n  \"Messenger\",\n  \"MitternachtsWaltz\",\n  \"MouunsMoon\",\n  \"PolarStar\",\n  \"Predator\",\n  \"PrototypeCrescent\",\n  \"RavenBow\",\n  \"RecurveBow\",\n  \"RoyalBow\",\n  \"Rust\",\n  \"SacrificialBow\",\n  \"SeasonedHuntersBow\",\n  \"SharpshootersOath\",\n  \"SkywardHarp\",\n  \"Slingshot\",\n  \"TheStringless\",\n  \"TheViridescentHunt\",\n  \"ThunderingPulse\",\n  \"EndOfTheLine\",\n  \"WindblumeOde\",\n] as const\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\n\nexport const allWeaponCatalystKeys = [\n  \"ApprenticesNotes\",\n  \"BlackcliffAgate\",\n  \"DodocoTales\",\n  \"EmeraldOrb\",\n  \"EverlastingMoonglow\",\n  \"EyeOfPerception\",\n  \"FavoniusCodex\",\n  \"Frostbearer\",\n  \"FruitOfFulfillment\",\n  \"HakushinRing\",\n  \"KagurasVerity\",\n  \"LostPrayerToTheSacredWinds\",\n  \"MagicGuide\",\n  \"MappaMare\",\n  \"MemoryOfDust\",\n  \"OathswornEye\",\n  \"OtherworldlyStory\",\n  \"PocketGrimoire\",\n  \"PrototypeAmber\",\n  \"RoyalGrimoire\",\n  \"SacrificialFragments\",\n  \"SkywardAtlas\",\n  \"SolarPearl\",\n  \"TheWidsith\",\n  \"ThrillingTalesOfDragonSlayers\",\n  \"TwinNephrite\",\n  \"WineAndSong\",\n] as const\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"dendro_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type AmpReactionKey = typeof allAmpReactions[number]\nexport type AdditiveReactionKey = typeof allAdditiveReactions[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type InfusionAuraElements = typeof allInfusionAuraElements[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type NonTravelerCharacterKey = typeof nonTravelerCharacterKeys[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type CharacterSheetKey = typeof allCharacterSheetKeys[number]\nexport type LocationCharacterKey = typeof locationCharacterKeys[number]\nexport type TravelerKey = typeof travelerKeys[number]\nexport type TravelerElementKey = typeof travelerElements[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type RollColorKey = typeof allRollColorKeys[number]\nexport type Ascension = typeof allAscension[number]\nexport type Refinement = typeof allRefinement[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: [\"vaporize\", \"melt\"],\n  hydro: [\"vaporize\"],\n  cryo: [\"melt\"],\n  anemo: [\"vaporize\", \"melt\"],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> = {\n  dendro: [\"spread\"],\n  electro: [\"aggravate\"],\n  anemo: [\"aggravate\"],\n}\n\nexport type SubstatType = typeof substatType[number]\n\nexport function charKeyToLocCharKey(charKey: CharacterKey): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return \"Traveler\"\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(key: TravelerKey, element: TravelerElementKey): TravelerKey {\n  return \"Traveler\" + element.toUpperCase().slice(0, 1) + element.slice(1) as TravelerKey\n}\n\nexport type LocationKey = LocationCharacterKey | \"\"\n\nexport function charKeyToCharName(ck: CharacterKey, gender: \"F\" | \"M\"): string {\n  return ck.startsWith(\"Traveler\") ? \"Traveler\" + gender : ck\n}\n","import { ArtSetExclusion } from \"../../../../Database/Data/BuildsettingData\";\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\n\ntype DynMinMax = { [key in string]: MinMax }\ntype MinMax = { min: number, max: number }\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\n\n  function visit(node: NumNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(_op => {\n      const op = _op as NumNode\n      affineNodes.has(op) && topLevelAffine.add(op)\n    })\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const operation = f.operation\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\":\n        if (typeof f.value === \"string\" || f.value === undefined)\n          throw new Error(`Found constant ${f.value} while compacting`)\n        visit(f as NumNode, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\n    Object.keys(arts.base).length === dynKeys.size)\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\n  let progress = false\n  const noRainbow = !exclusion.rainbow?.length\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return f.operands[3]\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter(key => arts.every(art => art.values[key]))\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\n  const range = new Map<NumNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, _f => {\n    const f = _f as NumNode\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"subscript\": current = computeMinMax(f.list); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = operands[3]\n        else current = computeMinMax([], [operands[2], operands[3]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      case \"data\": case \"lookup\": case \"match\":\n        throw new Error(`Unsupported ${operation} node`)\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\nexport function filterArtsVec(arts: ArtifactsBySlotVec, filters: RequestFilter): ArtifactsBySlotVec {\n  return {\n    keys: arts.keys, base: arts.base, baseBuffer: arts.baseBuffer,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\nexport function filterArts2(arts: ArtifactsBySlot, filterVec: StrictDict<SlotKey, number[]>): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filterIxs = filterVec[slot]\n      const slotVals = arts.values[slot]\n      return filterIxs.map(ix => slotVals[ix])\n    })\n  }\n}\nexport function filterArtsVec2(arts: ArtifactsBySlotVec, filterVec: StrictDict<SlotKey, number[]>): ArtifactsBySlotVec {\n  return {\n    keys: arts.keys, base: arts.base, baseBuffer: arts.baseBuffer,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filterIxs = filterVec[slot]\n      const slotVals = arts.values[slot]\n      return filterIxs.map(ix => slotVals[ix])\n    })\n  }\n}\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n\n\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\n        case \"id\": break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\n  return new Set(exclusion?.includes(2)\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length))\n        shapes.push(current)\n      return\n    }\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\n      return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\n        shape[replacing] = 5\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\n\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set()\n    let groupped: number[][] = [], rainbows: number[] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length)\n        return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set], count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find(x => x > count)! - count\n          missing.push(set)\n        }\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport const emptyfilter: RequestFilter = objectKeyMap(allSlotKeys, _ => ({ kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }));\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\n\n\nexport type ArtifactBuildDataVecDense = {\n  id: string\n  set?: ArtifactSetKey\n  values: number[]\n  buffer: number[]\n}\n// I dont *think* its worth it to implement sparse vectors n shit\n// export type ArtifactBuildDataVecSparse = {\n//   id: string\n//   set?: ArtifactSetKey\n//   values: number[][]\n// }\nexport type ArtifactsBySlotVec = { keys: string[], base: number[], values: StrictDict<SlotKey, ArtifactBuildDataVecDense[]>, baseBuffer: number[] }\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n","import { sum, prod, hashNode, cmpNode } from \"./utils\"\nimport { ConstantNode, NumNode } from \"./type\"\nimport { allArtifactSets } from \"../Types/consts\"\nimport { cartesian } from '../Util/Util'\nimport { forEachNodes } from \"./internal\"\nimport { makeid } from \"./optimize2\"\nimport { DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\n\nfunction countSlotUsage(node: NumNode): DynStat {\n  if (node.operation === 'add') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => {\n      Object.entries(b).forEach(([slotKey, n]) => a[slotKey] = Math.min(n, a[slotKey] ?? 0))\n      return a\n    }, {})\n  }\n  else if (node.operation === 'mul') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => {\n      Object.entries(b).forEach(([slotKey, n]) => a[slotKey] = Math.max(n, a[slotKey] ?? 0))\n      return a\n    }, {})\n  }\n  else if (node.operation === 'threshold') {\n    const branch = node.operands[0]\n    if (branch.operation === 'read' && (allArtifactSets as readonly string[]).includes(branch.path[1])) {\n      let con = node.operands[1] as ConstantNode<number>\n      return { [branch.path[1]]: con.value }\n    }\n  }\n  return {}\n}\n\nfunction filterProductPossible({ terms, nodes }: ExpandedPolynomial, slotsLeft = 5) {\n  let sCount = Object.fromEntries(Object.entries(nodes).map(([tag, n]) => [tag, countSlotUsage(n)]))\n\n  terms = terms.filter(({ terms }) => {\n    const slotUsage = terms.reduce((tot, s) => {\n      Object.entries(sCount[s]).forEach(([slotKey, n]) => tot[slotKey] = Math.max(n, tot[slotKey] ?? 0))\n      return tot\n    }, {} as DynStat)\n    return Object.values(slotUsage).reduce((a, b) => a + b, 0) <= slotsLeft\n  })\n  return { terms, nodes }\n}\n\nexport type Monomial = {\n  coeff: number,\n  terms: string[]\n}\nexport type ExpandedPolynomial = {\n  terms: Monomial[],\n  nodes: Dict<string, NumNode>,\n}\n\nexport function sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nexport function prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map(monos => monos.reduce((ret, nxt) => {\n    ret.coeff *= nxt.coeff\n    ret.terms.push(...nxt.terms)\n    return ret\n  }, { coeff: 1, terms: [] }))\n}\nexport function constantM(v: number): Monomial[] {\n  return [{ coeff: v, terms: [] }]\n}\nexport function readM(tag: string): Monomial[] {\n  return [{ coeff: 1, terms: [tag] }]\n}\n\nexport function foldLikeTerms(mono: Monomial[]): Monomial[] {\n  let mon = [...mono]\n  mon.forEach(m => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : 1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    let a = mon[i].terms\n    let b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].coeff = (mon[i].coeff ?? 0) + (mon[i + 1].coeff ?? 0)\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\n\n/**\n * Factors damage formula into sums of monomials in each variable.\n * For example:  (1700 * atk_ + atk) * (1 + cr * cd) * (1 + sum_frac(EM))\n *   -> 1700 * atk_ + 1700 * atk_ * cr * cd + 1700 * atk_ * sum_frac(EM) + 1700 * atk_ * cr * cd * sum_frac(EM)\n *            + atk +         atk * cr * cd +         atk * sum_frac(EM) +         atk * cr * cd * sum_frac(EM)\n *\n * For a total of 8 terms, since there are 3 pairs of additions, for 2^3 sum-of-product terms.\n *\n * isVar() is used to check whether any node should be considered a variable on its own.\n */\ntype NodeLinkedList = { n: NumNode, tag: string, next: NodeLinkedList | undefined }\nexport function expandPoly(node: NumNode, inheritTags?: string[]): ExpandedPolynomial {\n  let varMap = {} as Dict<number, NodeLinkedList> // my shitty hashmap\n  let tagMap = {} as Dict<string, NumNode>\n  const varTags = inheritTags ?? []\n  function lookup(n: NumNode) {\n    let hsh = hashNode(n)\n    let z = varMap[hsh]\n    while (z !== undefined) {\n      if (cmpNode(z.n, n)) return z.tag\n      z = z.next\n    }\n    const newTag = makeid(10, varTags)\n    varMap[hsh] = { n, tag: newTag, next: varMap[hsh] }\n    tagMap[newTag] = n\n    varTags.push(newTag)\n    return newTag\n  }\n\n  let stat2tag = {} as Dict<string, string>\n  forEachNodes([node], _ => { }, n => {\n    if (n.operation === 'read') stat2tag[n.path[1]] = lookup(n as NumNode)\n  })\n\n  function toSOP(n: NumNode): Monomial[] {\n    switch (n.operation) {\n      case 'add':\n        return sumM(...n.operands.map(toSOP))\n      case 'mul':\n        return prodM(...n.operands.map(toSOP))\n      case 'const':\n        return constantM(n.value)\n      default:\n        return readM(lookup(n))\n    }\n  }\n\n  // let sop = toSOP(node)\n  let sop = foldLikeTerms(toSOP(node))\n  return filterProductPossible({\n    terms: sop,\n    nodes: tagMap,\n  })\n}\n\n// Really should avoid using this function ever\nexport function toNumNode({ nodes, terms }: ExpandedPolynomial) {\n  return sum(...terms.map(({ coeff, terms }) => prod(coeff, ...terms.map(t => nodes[t]!))))\n}\n","function pivotInplace(A: number[][], { i, j }: { i: number, j: number }) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= A[i][k] * A[h][j] / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\nfunction findPiv1(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= 0) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > 1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\nfunction findPiv2(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= 0) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\nfunction backtrack(tableau: number[][], ijTrack: { i: number, j: number }[], targ: number) {\n  let side = 1;  // 0 left, 1 right\n  ijTrack.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    }\n    else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to:\n *   https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* a problem for GO's use\n *   case. This algorithm is fairly numerically unstable though, use with care & always\n *   try to verify the solution. It's also a fair bit slower than it needs to be.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        the optimal solution x\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  let rows = Ab.length + 1\n  let cols = Ab[0].length\n\n  let tableau = Array(rows).fill(0).map(_ => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => tableau[i][j] = Aij))\n  // b.forEach((bi, i) => tableau[i][cols - 1] = bi)\n  c.forEach((cj, j) => tableau[rows - 1][j] = cj)\n  // console.log('tab', tableau)\n\n  let ijTrack: { i: number, j: number }[] = []\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < 0)) {\n    const ij = findPiv2(tableau)\n    ijTrack.push(ij)\n    // tableau = pivot(tableau, ij)\n    pivotInplace(tableau, ij)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < 0)) {\n    const ij = findPiv1(tableau)\n    ijTrack.push(ij)\n    // tableau = pivot(tableau, ij)\n    pivotInplace(tableau, ij)\n  }\n\n  return c.map((_, i) => backtrack(tableau, ijTrack, i))\n}\n","import { NumNode } from \"./type\"\nimport { ArtifactsBySlot, ArtifactsBySlotVec, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { constant, sum, prod, cmp } from \"./utils\"\nimport { ExpandedPolynomial, Monomial, sumM, prodM, constantM, readM, foldLikeTerms } from './expandPoly'\nimport { precompute, allOperations } from \"./optimization\"\nimport { solveLP } from './solveLP_simplex'\nimport { cartesian } from '../Util/Util'\nimport { fillBuffer } from \"./addedUtils\"\n\nexport type LinearForm = {\n  w: DynStat,\n  c: number,\n  err: number\n}\nexport type LinearFormVec = {\n  w: number[],\n  c: number,\n  err: number\n}\n\nfunction minMax(node: NumNode, lower: DynStat, upper: DynStat) {\n  const compute = precompute([node], {}, n => n.path[1], 1)\n  const minval = compute([{ id: '', values: lower }])[0]\n  const maxval = compute([{ id: '', values: upper }])[0]\n  return [minval, maxval]\n}\n\n/**\n * `res` is the ONE place where negative arguments & negative slopes are allowed.\n * @param node\n */\nfunction handleResArg(node: { 'operation': 'res', 'operands': NumNode[] }, lower: DynStat, upper: DynStat) {\n  function flipOps(n: NumNode): NumNode {\n    switch (n.operation) {\n      case 'add':\n        return sum(...n.operands.map(n => flipOps(n)))\n      case 'const':\n        return constant(-n.value)\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (ge.operation === 'const' && lt.operation === 'const') {\n          if (ge.value <= lt.value) {\n            return cmp(branch, bval, -ge.value, -lt.value)\n          }\n        }\n        console.log(n)\n        throw Error('(res neg slope): threshold. Something went wrong.')\n      default:\n        console.log(n)\n        throw Error('(res neg slope) Havent written logic to handle this')\n    }\n  }\n\n  const flippedResOp = flipOps(node.operands[0])\n\n  let [a, b] = minMax(flippedResOp, lower, upper)\n  let resf = allOperations['res']\n  let [c, d] = [resf([-a]), resf([-b])]\n\n  if (b > 0 && a > -1.75) {\n    // 1 + x / 2\n    return sum(1, prod(.5, flippedResOp))\n  }\n\n  const intercept = (b * c - a * d) / (b - a)\n  const slope = (c - d) / (b - a)\n  return sum(intercept, prod(slope, flippedResOp))\n}\n\n/**\n * First converts a product of variables (including max, min, sum_frac, threshold, etc.) to\n *   a pure product form consisting of only `read` and `const` nodes, guaranteeing the\n *   product form is an upper bound.\n *\n * Then on the product form, create a linear upper bound using `lub` and return it.\n *\n * @param node The formula to expand\n * @param lower Stat lower bounds\n * @param upper Stat upper bounds\n * @returns\n */\nexport function toLinearUpperBound({ nodes, terms }: ExpandedPolynomial, lower: DynStat, upper: DynStat): LinearForm {\n  let stat2tag = {} as Dict<string, string>\n  Object.entries(nodes).forEach(([tag, n]) => {\n    if (n.operation === 'read') stat2tag[n.path[1]] = tag\n  })\n\n  let linerr = 0\n  function toPureRead(n: NumNode): Monomial[] {\n    switch (n.operation) {\n      case 'const':\n        return constantM(n.value)\n      case 'read':\n        return readM(stat2tag[n.path[1]]!)\n      case 'add':\n        return sumM(...n.operands.map(toPureRead))\n      case 'mul':\n        return prodM(...n.operands.map(toPureRead))\n\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (branch.operation === 'read' && bval.operation === 'const'\n          && lt.operation === 'const' && ge.operation === 'const') {\n          if (ge.value < lt.value) {\n            console.log(n)\n            throw Error('Not Implemented (threshold must be increasing)')\n          }\n\n          let key = branch.path[1]\n          if (lower[key] >= bval.value) return constantM(ge.value)\n          if (upper[key] < bval.value) return constantM(lt.value)\n\n          const slope = (ge.value - lt.value) / (bval.value - lower[key])\n          const mon1 = prodM(constantM(slope), readM(stat2tag[branch.path[1]]!))\n\n          const intercept = lt.value - slope * lower[key]\n          if (intercept === 0) return mon1\n          return sumM(constantM(intercept), mon1)\n          // if (lt.value === 0) return mon1\n          // return sumM(constantM(lt.value), mon1)\n        }\n        console.log(n)\n        throw Error('Not Implemented (threshold must branch between constants)')\n      case 'res':\n        let op = handleResArg(n as { 'operation': 'res', 'operands': NumNode[] }, lower, upper)\n        return toPureRead(op)\n\n      case 'min': case 'max':\n        let [rop, cop] = n.operands\n        if (cop.operation !== 'const')\n          [rop, cop] = [cop, rop]  // Assume min(const, read)\n        if (n.operation === 'min') return toPureRead(rop)\n\n        if (cop.operation === 'const') {\n          const thresh = cop.value\n          const [minVal, maxVal] = minMax(rop, lower, upper)\n          if (minVal > thresh) return toPureRead(rop)\n          if (thresh > maxVal) return constantM(thresh)\n\n          // rescale `rop` to be above thresh, since max(f, 0) is a convex function\n          const m = (maxVal - thresh) / (maxVal - minVal)\n          const b = thresh - m * minVal\n          return sumM(constantM(b), prodM(constantM(m), toPureRead(rop)))\n        }\n        console.log(n)\n        throw Error('Not Implemented (max between two non-constants)')\n\n      case 'sum_frac':\n        const [em, denom] = n.operands\n        if (denom.operation !== 'const') throw Error('Not Implemented (non-constant sum_frac denominator)')\n\n        const [minEM, maxEM] = minMax(em, lower, upper)\n        const k = denom.value\n        // The sum_frac form is concave, so any Taylor expansion of EM / (EM + k) gives an upper bound.\n        // We can solve for the best Taylor approximation location with the following formula.\n        let loc = Math.sqrt((minEM + k) * (maxEM + k)) - k\n        let below = (k + loc) * (k + loc)\n        let slope = k / below\n        let c = loc * loc / below\n\n        // TODO: update linerr\n        return sumM(constantM(c), prodM(constantM(slope), toPureRead(em)))\n\n      default:\n        console.log(n)\n        throw Error('Not Implemented')\n    }\n  }\n\n  // 1. Turn all nodes into linear upper bounds\n  const nodesToMap = Object.fromEntries(Object.entries(nodes).filter(([tag, n]) => n.operation !== 'read').map(([tag, n]) => [tag, toPureRead(n)]))\n\n  // 2. substitute into `terms` and construct a new SOPForm whose nodes are all pure read nodes\n  let t2 = terms.flatMap(({ coeff, terms }) => prodM(constantM(coeff), ...terms.map(t => nodesToMap[t] ?? readM(t))))\n  t2 = foldLikeTerms(t2)\n\n  // 2.5 Re-name all the tags to their read node version\n  t2 = t2.map(({ coeff, terms }) => {\n    terms = terms.map(t => {\n      const nt = nodes[t]\n      if (!nt || nt.operation !== 'read') throw Error('MUST be a read node.')\n      return nt.path[1]\n    })\n    return { coeff, terms }\n  })\n\n  // 3. call lub() on each term\n  const lins = t2.map(({ coeff, terms }) => {\n    if (terms.length === 0) return { w: {}, c: coeff, err: 0 }\n    if (terms.length === 1) return { w: { [terms[0]]: coeff }, c: 0, err: 0 }\n    const { w, c, err } = lub(terms.map(k => ({ lower: lower[k], upper: upper[k] })))\n    const retw = w.reduce((ret, wi, i) => {\n      ret[terms[i]] = wi * coeff + (ret[terms[i]] ?? 0)\n      return ret\n    }, {} as DynStat)\n    return { w: retw, c: coeff * c, err: coeff * err + linerr }\n  })\n\n  return lins.reduce((lin, l) => {\n    lin.c += l.c; lin.err += l.err\n    Object.entries(l.w).forEach(([k, v]) => lin.w[k] = v + (lin.w[k] ?? 0))\n    return lin\n  }, { w: {}, c: 0, err: 0 })\n}\n\n/**\n * Constructs an upper bounding linear form for a function x_1 * x_2 * ... * x_n\n * @param bounds upper and lower bounds for each x_i\n * @returns { w, c, err } with\n */\nfunction lub(bounds: { lower: number, upper: number }[]): { w: number[], c: number, err: number } {\n  if (bounds.length === 0) return { w: [], c: 0, err: 0 }\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ upper }) => upper)\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ lower, upper }) => ({ lower: lower / upper, upper: 1 }))\n\n  // Setting up the linear program in terms of constraints.\n  let cons = cartesian(...bounds.map(({ lower, upper }) => [lower, upper])).flatMap((coords) => {\n    const prod = coords.reduce((prod, v) => prod * v, 1)\n    return [\n      [...coords.map(v => -v), 1, 0, -prod],\n      [...coords, -1, -1, prod],\n    ]\n  })\n\n  // Force equality at upper & lower corners?\n  // cons.push([...bounds.map(lu => lu.lower), -1, 0, bounds.reduce((prod, { lower }) => prod * lower, 1)])\n  // cons.push([...bounds.map(lu => lu.upper), -1, 0, bounds.reduce((prod, { upper }) => prod * upper, 1)])\n\n  let soln: any\n  const objective = [...bounds.map(_ => 0), 0, 1]\n  try {\n    // TODO: verify solution\n    soln = solveLP(objective, cons)\n  }\n  catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    throw e\n  }\n  return {\n    w: soln.slice(0, nVar).map((wi, i) => wi * scaleProd / boundScale[i]),\n    c: -scaleProd * soln[nVar],\n    err: scaleProd * soln[nVar + 1]\n  }\n}\n\nexport function maxWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmulMax([lin], [a.base])[0] + lin.c\n\n  return baseVal + Object.entries(a.values)\n    .reduce((maxTotVal, [slotKey, slotArts]) => maxTotVal + sparseMatmulMax([lin], slotArts.map(a => a.values))[0], 0)\n}\nexport function minWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmulMin([lin], [a.base])[0] + lin.c\n\n  return baseVal + Object.entries(a.values)\n    .reduce((minTotVal, [slotKey, slotArts]) => minTotVal + sparseMatmulMin([lin], slotArts.map(a => a.values))[0], 0)\n}\n\nexport function maxWeightVec(a: ArtifactsBySlotVec, lin: LinearForm) {\n  const ixs: number[] = []\n  const w: number[] = []\n  Object.entries(lin.w).forEach(([k, ww]) => {\n    ixs.push(a.keys.indexOf(k))\n    w.push(ww)\n  })\n\n  const baseVal = ixs.reduce((accum, ix, i) => accum + a.base[ix] * w[i], lin.c)\n  return Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.max(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n}\nexport function minMaxWeightVec(a: ArtifactsBySlotVec, lin: LinearForm) {\n  const ixs: number[] = []\n  const w: number[] = []\n  Object.entries(lin.w).forEach(([k, ww]) => {\n    ixs.push(a.keys.indexOf(k))\n    w.push(ww)\n  })\n\n  const baseVal = ixs.reduce((accum, ix, i) => accum + a.base[ix] * w[i], lin.c)\n  const maxw = Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.max(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n\n  const minw = Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.min(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n  return { minw, maxw }\n}\n\n\n\n// Implement matrix multiply between row-major w's of LinearForm and col-major DynStats that represent artifacts.\n/**\n * Implements sparse matrix multiplication between A and x\n * @param A A list of row-major w's of some LinearForm\n * @param x A list of col-major DynStats that represent some artifacts\n * @returns A col-major 2d array number[][] with shape (A.length, x.length).\n *          ret[0] is [A1 @ x1, A2 @ x1, ..., An @ x1]\n */\nexport function sparseMatmul(A: LinearForm[], x: DynStat[]) {\n  return x.map(dyn => A.map(({ w }) => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0)))\n}\n\n/**\n * Sparse matrix multiplication between A and x, followed by a max() along the rows.\n */\nexport function sparseMatmulMax(A: LinearForm[], x: DynStat[]) {\n  return A.map(({ w }) => Math.max(...x.map(dyn => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0))))\n}\n\n/**\n * Sparse matrix multiplication between A and x, followed by a min() along the rows.\n */\nexport function sparseMatmulMin(A: LinearForm[], x: DynStat[]) {\n  return A.map(({ w }) => Math.min(...x.map(dyn => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0))))\n}\n","import { constant, sum, prod, cmp } from \"./utils\"\nimport { NumNode } from \"./type\"\nimport { allOperations } from \"./optimization\"\nimport { mapFormulas } from \"./internal\"\nimport { ArtifactBuildData, ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { LinearForm, maxWeight, toLinearUpperBound } from \"./linearUpperBound\"\nimport { foldLikeTerms, ExpandedPolynomial } from \"./expandPoly\"\nimport { ArtifactSetKey } from \"../Types/consts\"\nimport { ArtSetExclusion } from \"../Database/Data/BuildsettingData\"\n\nexport function foldSum(nodes: readonly NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n  nodes = nodes.flatMap(n => n.operation === 'add' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv + n.value : pv, 0)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 0) {\n    if (nodes.length === 1) return nodes[0]\n    return sum(...nodes)\n  }\n  return sum(...nodes, constant(constVal))\n}\n\nexport function foldProd(nodes: readonly NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n  nodes = nodes.flatMap(n => n.operation === 'mul' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv * n.value : pv, 1)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 1) return prod(...nodes)\n  return prod(...nodes, constant(constVal))\n}\n\nexport function slotUpperLower(a: ArtifactBuildData[]) {\n  if (a.length === 0) return { statsMin: {}, statsMax: {} }\n  // Assume keys are the same for all artifacts.\n  const keys = Object.keys(a[0].values)\n  let statsMin: DynStat = {}\n  let statsMax: DynStat = {}\n  let sets = new Set<ArtifactSetKey>()\n  keys.forEach(k => {\n    statsMin[k] = Infinity\n    statsMax[k] = -Infinity\n  })\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < keys.length; j++) {\n      const k = keys[j]\n      statsMin[k] = Math.min(a[i].values[k], statsMin[k])\n      statsMax[k] = Math.max(a[i].values[k], statsMax[k])\n    }\n    if (a[i].set) sets.add(a[i].set!)\n  }\n  sets.forEach(set => {\n    statsMax[set] = 1\n    statsMin[set] = 0\n  })\n  if (sets.size === 1) {\n    const [s] = sets\n    statsMin[s] = 1\n  }\n  return { statsMin, statsMax }\n}\n\nexport function statsUpperLower(a: ArtifactsBySlot) {\n  let statsMin: DynStat = { ...a.base }\n  let statsMax: DynStat = { ...a.base }\n  Object.entries(a.values).forEach(([slotKey, slotArts]) => {\n    const { statsMin: smin, statsMax: smax } = slotUpperLower(slotArts)\n    Object.keys(smin).forEach(sk => {\n      statsMin[sk] = smin[sk] + (statsMin[sk] ?? 0)\n      statsMax[sk] = smax[sk] + (statsMax[sk] ?? 0)\n    })\n  })\n  return { statsMin, statsMax }\n}\n\nexport function reduceFormula(f: NumNode[], lower: DynStat, upper: DynStat) {\n  const fixedStats = Object.keys(lower).filter(statKey => lower[statKey] === upper[statKey])\n  let f2 = mapFormulas(f, n => n, n => {\n    switch (n.operation) {\n      case 'add':\n        return foldSum(n.operands)\n      case 'mul':\n        return foldProd(n.operands)\n\n      case 'read':\n        if (fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n        return n\n      case 'threshold':\n        const [branch, branchVal, ge, lt] = n.operands\n        if (branch.operation === 'const' && branchVal.operation === 'const')\n          return branch.value >= branchVal.value ? ge : lt\n        if (branch.operation === 'read' && branchVal.operation === 'const') {\n          if (lower[branch.path[1]] >= branchVal.value) return ge\n          if (upper[branch.path[1]] < branchVal.value) return lt\n        }\n        return n\n      case 'min': case 'max':\n      case 'res': case 'sum_frac':\n        if (n.operands.every(ni => ni.operation === 'const')) {\n          const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n          return constant(out)\n        }\n        return n\n      default:\n        return n\n    }\n  })\n\n  // f2 = optimize(f2, {})\n  return f2\n}\n\nexport function reducePolynomial(f: ExpandedPolynomial[], lower: DynStat, upper: DynStat): ExpandedPolynomial[] {\n  const fixedStats = Object.keys(lower).filter(statKey => Math.abs(lower[statKey] - upper[statKey]) < 1e-6)\n  return f.map(({ nodes, terms }) => {\n    // 1. Reduce nodes by substituting constants\n    const tagNodePairs = Object.entries(nodes)\n    const reducedNodes = mapFormulas(tagNodePairs.map(([k, v]) => v), n => n, n => {\n      switch (n.operation) {\n        case 'read':\n          if (fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n          return n\n        case 'threshold':\n          const [branch, branchVal, ge, lt] = n.operands\n          if (branch.operation === 'const' && branchVal.operation === 'const')\n            return branch.value >= branchVal.value ? ge : lt\n          if (branch.operation === 'read' && branchVal.operation === 'const') {\n            if (lower[branch.path[1]] >= branchVal.value) return ge\n            if (upper[branch.path[1]] < branchVal.value) return lt\n          }\n          else throw Error('Branch between non-read and non-const!!!')\n          return n\n        case 'add':\n          return foldSum(n.operands)\n        case 'mul':\n          return foldProd(n.operands)\n        case 'res': case 'sum_frac':\n          if (n.operands.every(ni => ni.operation === 'const')) {\n            const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n            return constant(out)\n          }\n          return n\n        case 'min': case 'max':\n          // TODO: reduce min & max\n          if (n.operands.every(ni => ni.operation === 'const')) {\n            const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n            return constant(out)\n          }\n          return n\n        default:\n          return n\n      }\n    })\n\n    // 2a. Find all the nodes that have been reduced to constants\n    let tagsToKill = {} as Dict<string, number>\n    reducedNodes.forEach((n, i) => {\n      if (n.operation !== 'const') return\n      const [tag] = tagNodePairs[i]\n      tagsToKill[tag] = n.value\n    })\n\n    // 2b. Substitute the constant nodes in where possible\n    let newTerms = terms.map(mon => {\n      let c = mon.coeff\n      const newTerms = mon.terms.filter(t => {\n        if (tagsToKill[t] !== undefined) {\n          c *= tagsToKill[t]!\n          return false\n        }\n        return true\n      })\n      if (c === 0) return { coeff: 0, terms: [] }\n      return { coeff: c, terms: newTerms }\n    })\n\n    // 3. Delete all the constant tags & add like terms together\n    let newNodes = Object.fromEntries(reducedNodes.map((n, i) => [tagNodePairs[i][0], n]))\n    Object.keys(tagsToKill).forEach(t => delete newNodes[t])\n    return { nodes: newNodes, terms: foldLikeTerms(newTerms) }\n  })\n}\n\n/**\n * Estimates maximum value across an array of formulas\n * @param f              Functions to maximize\n * @param a              Artifact set\n * @param cachedCompute  Optional Prior cached compute. If specified, will re-calculate `maxEst` assuming `lin, lower, upper` are correct.\n * @returns              CachedCompute\n */\ntype MaxEstQuery2 = { f: ExpandedPolynomial[], a: ArtifactsBySlot, cachedCompute: { lower: DynStat, upper: DynStat } }\n  | { f?: undefined, cachedCompute: { lin: LinearForm[], lower: DynStat, upper: DynStat }, a: ArtifactsBySlot }\nexport function estimateMaximum({ f, a, cachedCompute }: MaxEstQuery2) {\n  if (f === undefined) {\n    return { maxEst: cachedCompute.lin.map(l => maxWeight(a, l)), ...cachedCompute }\n  }\n\n  const { lower, upper } = cachedCompute\n  const est = f.map(fi => {\n    const lin = toLinearUpperBound(fi, lower, upper)\n    return { maxEst: maxWeight(a, lin), lin }\n  })\n\n  return {\n    maxEst: est.map(({ maxEst }) => maxEst),\n    lin: est.map(({ lin }) => lin),\n    lower, upper\n  }\n}\n\nexport function fillBuffer(stats: DynStat, mapping: Dict<string, number>, buffer: Float64Array) {\n  Object.entries(stats)\n    .filter(([k]) => mapping[k] !== undefined)\n    .forEach(([k, v]) => buffer[mapping[k]!] = v)\n}\n\nexport function thresholdExclusions(nodes: NumNode[], excl: ArtSetExclusion) {\n  nodes = mapFormulas(nodes, n => n, n => {\n    switch (n.operation) {\n      case 'threshold':\n        const [branch, branchVal, ge, lt] = n.operands\n        if (branch.operation === 'read' && branchVal.operation === 'const') {\n          const key = branch.path[1] as ArtifactSetKey\n          if (excl[key] !== undefined) {\n            const exc = excl[key] as (2 | 4)[]\n            // Based on exclusion, either return `lt` or shift `branchVal` to 4.\n            if (branchVal.value === 2 && exc.includes(2)) {\n              if (exc.includes(4)) return lt\n              return cmp(branch, 4, ge, lt)\n            }\n            if (branchVal.value === 4 && exc.includes(4))\n              return lt\n          }\n        }\n        return n\n      default:\n        return n\n    }\n  })\n  return nodes\n}\n","import { ArtSetExclusion } from \"../../../../Database/Data/BuildsettingData\"\nimport { reducePolynomial } from \"../../../../Formula/addedUtils\"\nimport { ExpandedPolynomial, expandPoly, toNumNode } from \"../../../../Formula/expandPoly\"\nimport { LinearForm, minMaxWeightVec, toLinearUpperBound } from \"../../../../Formula/linearUpperBound\"\nimport { precompute } from \"../../../../Formula/optimization\"\nimport { NumNode } from \"../../../../Formula/type\"\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\"\nimport { objectKeyMap, objectKeyValueMap, range } from \"../../../../Util/Util\"\nimport { ArtifactBuildDataVecDense, ArtifactsBySlot, ArtifactsBySlotVec, DynStat, filterArtsVec2, RequestFilter } from \"./common\"\n\nexport type UnionFilter = {\n  uType: true\n  filters: StrictDict<SlotKey, { kind: \"id\", ids: Set<string> }>[]\n} | (RequestFilter & { uType: false })\n\nexport type RequestFilter2 = {\n  // filter: StrictDict<SlotKey, { kind: \"id\", ids: Set<string> }>,\n  filterVec: StrictDict<SlotKey, number[]>,  // dict of list of indices (for some particular ArtifactsBySetVec)\n  lower: number[],  // length `k` list of lower bound stats\n  upper: number[],  // length `k` list of upper bound stats\n  minw: number[],   // length `l` list of minimum upper bound estimates\n  maxw: number[],   // length `l` list of maximum upper bound weights\n}\nexport type UnionFilter2 = RequestFilter2[]\nexport type ArtSetExclusionFull = Dict<Exclude<ArtifactSetKey, \"PrayersForDestiny\" | \"PrayersForIllumination\" | \"PrayersForWisdom\" | \"PrayersToSpringtime\"> | \"uniqueKey\", number[]>\n// export type SubProblem = SubProblemNC | SubProblemWC\nexport type SubProblem = SubProblemWC\nexport type SubProblemNC = {\n  cache: false,\n  optimizationTarget: ExpandedPolynomial,\n  constraints: { value: ExpandedPolynomial, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filters: UnionFilter2,\n  depth: number,\n}\nexport type SubProblemWC = {\n  cache: true,\n  optimizationTarget: ExpandedPolynomial,\n  constraints: { value: ExpandedPolynomial, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filters: UnionFilter2,\n  lin: LinearForm[],\n  // cachedCompute: CachedCompute,\n  depth: number,\n}\nexport type CachedCompute = {\n  maxEst: number[],\n  lin: LinearForm[],\n  lower: DynStat,\n  upper: DynStat\n}\n\nexport function countBuildsU(f: UnionFilter2): number {\n  return f.reduce((tot, { filterVec }) => tot + allSlotKeys.reduce((_count, slot) => _count * filterVec[slot].length, 1), 0)\n}\n\nexport function unionFilterUpperLower(f: UnionFilter2) {\n  const lower = [...f[0].lower]\n  const upper = [...f[0].upper]\n  const minw = [...f[0].minw]\n  const maxw = [...f[0].maxw]\n\n  for (let i = 1; i < f.length; i++) {\n    for (let j = 0; j < lower.length; j++) {\n      lower[j] = Math.min(lower[j], f[i].lower[j])\n      upper[j] = Math.max(upper[j], f[i].upper[j])\n    }\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], f[i].minw[j])\n      maxw[j] = Math.max(maxw[j], f[i].maxw[j])\n    }\n  }\n\n  return { lower, upper, minw, maxw }\n}\n\nexport function applyLinearForm(arts: ArtifactsBySlotVec, lin: LinearForm[]) {\n  const wixs: number[][] = []\n  const ws: number[][] = []\n  const baseC: number[] = []\n  lin.forEach(li => {\n    const ixs0: number[] = []\n    const w0: number[] = []\n    Object.entries(li.w).forEach(([k, w]) => {\n      ixs0.push(arts.keys.indexOf(k))\n      w0.push(w)\n    })\n    wixs.push(ixs0)\n    ws.push(w0)\n\n    baseC.push(ixs0.reduce((accum, ix, i) => accum + arts.base[ix] * w0[i], li.c))\n  })\n\n  arts.baseBuffer = baseC\n  allSlotKeys.forEach(slotKey => arts.values[slotKey].forEach(art =>\n    art.buffer = wixs.map((ixsi, i) => ixsi.reduce((accum, ix, j) => accum + art.values[ix] * ws[i][j], 0))\n  ))\n}\n\nexport function reduceSubProblem(arts: ArtifactsBySlotVec, threshold: number, subp: SubProblem): SubProblemWC | undefined {\n  const { optimizationTarget, constraints, artSetExclusion, depth } = subp\n  let { filters } = subp\n  let nodes = [...constraints.map(({ value }) => value), optimizationTarget]\n  const mins = constraints.map(({ min }) => min)\n\n  // 0. Check for never-feasible constraints\n  filters = filters.filter(({ maxw }) => {\n    if (mins.some((min, j) => maxw[j] < min)) return false\n    if (maxw[mins.length] < threshold) return false\n    return true\n  })\n  if (filters.length === 0) return undefined\n\n  // 0b. Calculate stat bounding box\n  const { lower, upper } = unionFilterUpperLower(filters)\n  const statsMin: DynStat = Object.fromEntries(arts.keys.map((k, i) => ([k, lower[i]])))\n  const statsMax: DynStat = Object.fromEntries(arts.keys.map((k, i) => ([k, upper[i]])))\n\n  nodes = reducePolynomial(nodes, statsMin, statsMax)\n\n  // 1. Check for always-feasible constraints.\n  const compute = precompute(constraints.map(({ value }) => toNumNode(value)), {}, n => n.path[1], 1)\n  const result = compute([{ id: '', values: statsMin }])\n\n  const active = mins.map((m, i) => m > result[i])\n\n  const newOptTarget = nodes.pop()!\n  const newConstraints = nodes.map((value, i) => ({ value, min: mins[i] })).filter((_, i) => active[i])\n  const newMins = newConstraints.map(({ min }) => min)\n\n  // 2. Check for never-active and always-active ArtSetExcl constraints.\n  const newArtExcl = {} as ArtSetExclusionFull\n  for (const [setKey, exclude] of Object.entries(artSetExclusion)) {\n    if (setKey === 'uniqueKey') {\n      // TODO: Check and exclude rainbow bullshit.\n      newArtExcl[setKey] = exclude\n      const feasibleKeys = allArtifactSets.filter(setKey => statsMax[setKey] > 0)\n      let feasible4sets = 0\n      let feasible2sets = 0\n      feasibleKeys.forEach(k => {\n        let allowedCnts = range(statsMin[k], statsMax[k])\n        if (artSetExclusion[k])\n          allowedCnts = allowedCnts.filter(cnt => !artSetExclusion[k].includes(cnt))\n\n        if (allowedCnts.includes(4) || allowedCnts.includes(5)) feasible4sets++\n        if (allowedCnts.includes(2) || allowedCnts.includes(3)) feasible2sets++\n      })\n\n      if (exclude.includes(5) && feasible4sets === 0) {\n        if (feasible2sets === 0) return; // No feasible 4sets or 2sets along with rainbow5 excluded is never satisfiable\n        if (exclude.includes(3) && feasible2sets < 2) return; // No 4sets, rainbow5 excluded, rainbow3 excluded means we need at least 2 2sets\n      }\n      continue\n    }\n    const reducedExcl = exclude.filter(n => statsMin[setKey] <= n && n <= statsMax[setKey])        // Cut away never-active\n    if (reducedExcl.includes(statsMin[setKey]) && reducedExcl.includes(statsMax[setKey])) return;  // Always active.\n    if (reducedExcl.length > 0) newArtExcl[setKey] = reducedExcl\n  }\n\n  // 3. Estimate Upper Bounds and re-check for never-feasible constraints\n  let f = [...newConstraints.map(({ value }) => value), newOptTarget]\n  const lin = f.map(fi => toLinearUpperBound(fi, statsMin, statsMax))\n  applyLinearForm(arts, lin)\n  const newFilters = filters\n    .map(filter => {\n      const { filterVec, lower, upper } = filter\n      const a = filterArtsVec2(arts, filter.filterVec)  // CANDIDATE for making this more efficient\n      const minww = [...a.baseBuffer]\n      const maxww = [...a.baseBuffer]\n      allSlotKeys.forEach(slotKey => {\n        const { minw, maxw } = slotUpperLowerVecW(a.values[slotKey])\n        for (let j = 0; j < minww.length; j++) {\n          minww[j] += minw[j]\n          maxww[j] += maxw[j]\n        }\n      })\n      return {\n        filterVec, lower, upper,\n        minw: minww, maxw: maxww,\n      }\n    })\n    .filter(({ maxw }) => {\n      if (newMins.some((min, j) => maxw[j] < min)) return false\n      if (maxw[mins.length] < threshold) return false\n      return true\n    })\n\n  return {\n    cache: true,\n    optimizationTarget: newOptTarget,\n    constraints: newConstraints,\n    artSetExclusion: newArtExcl,\n\n    depth, lin, filters: newFilters\n  }\n}\n\nexport function toArtifactBySlotVec(arts: ArtifactsBySlot): ArtifactsBySlotVec {\n  const allKeys = new Set(Object.keys(arts.base))\n  Object.values(arts.values).forEach(slotArts => {\n    slotArts.forEach(art => {\n      if (art.set) allKeys.add(art.set)\n      Object.keys(art.values).forEach(k => allKeys.add(k))\n    })\n  })\n\n  const allKeysList = [...allKeys]\n  const keys = [...allKeysList.filter(k => !(allArtifactSets as readonly string[]).includes(k)), ...allKeysList.filter(k => (allArtifactSets as readonly string[]).includes(k))]\n\n  return {\n    keys, baseBuffer: [],\n    base: keys.map(k => arts.base[k] ?? 0),\n    values: {\n      flower: arts.values.flower.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      plume: arts.values.plume.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      sands: arts.values.sands.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      goblet: arts.values.goblet.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      circlet: arts.values.circlet.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n    }\n  }\n}\n\ntype ProblemSetup = {\n  optimizationTargetNode: NumNode,\n  nodes: NumNode[],\n  minimum: number[],\n  artSetExclusion: ArtSetExclusion\n}\nexport function problemSetup(arts: ArtifactsBySlotVec, { optimizationTargetNode, nodes, minimum, artSetExclusion }: ProblemSetup): SubProblemWC {\n  const artSetExclFull = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n    if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n    return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n  })\n\n  const constraintsEP = nodes\n    .map((value, i) => ({ value: expandPoly(value), min: minimum[i] }))\n    .filter(x => x.min > -Infinity)\n  const opttargetEP = expandPoly(optimizationTargetNode)\n\n  const { lower, upper } = statsUpperLowerVec(arts)\n  const statsMin = Object.fromEntries(arts.keys.map((k, i) => [k, lower[i]]))\n  const statsMax = Object.fromEntries(arts.keys.map((k, i) => [k, upper[i]]))\n  let f = [...constraintsEP.map(({ value }) => value), opttargetEP]\n  const lin = f.map(fi => toLinearUpperBound(fi, statsMin, statsMax))\n  const minMaxEst = lin.map(li => minMaxWeightVec(arts, li))\n\n  console.log('-----------------------------------------------------------------------')\n  console.log('lin', lin)\n  console.log('-----------------------------------------------------------------------')\n\n  const filterVec = objectKeyMap(allSlotKeys, slotKey => {\n    return arts.values[slotKey].map((v, i) => i)\n  })\n\n  const initialProblem: SubProblemWC = {\n    cache: true,\n    optimizationTarget: opttargetEP,\n    constraints: constraintsEP,\n    artSetExclusion: artSetExclFull,\n\n    filters: [{\n      filterVec, lower, upper,\n      maxw: minMaxEst.map(({ maxw }) => maxw),\n      minw: minMaxEst.map(({ minw }) => minw),\n    }],\n    depth: 0,\n    lin,\n  }\n  const initialReducedProblem = reduceSubProblem(arts, -Infinity, initialProblem)\n  console.log(initialReducedProblem)\n\n  const statsBase = Object.fromEntries(arts.keys.map((k, i) => [k, arts.base[i]]))\n  evaluateExpandedPolynomial(opttargetEP, statsBase)\n\n  if (initialReducedProblem === undefined)\n    return initialProblem\n  return initialReducedProblem\n}\n\nexport function slotUpperLowerVec(arts: ArtifactBuildDataVecDense[]) {\n  const lower = [...arts[0].values]\n  const upper = [...arts[0].values]\n  const minw = [...arts[0].buffer]\n  const maxw = [...arts[0].buffer]\n  for (let i = 1; i < arts.length; i++) {\n    for (let j = 0; j < lower.length; j++) {\n      lower[j] = Math.min(lower[j], arts[i].values[j])\n      upper[j] = Math.max(upper[j], arts[i].values[j])\n    }\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], arts[i].buffer[j])\n      maxw[j] = Math.max(maxw[j], arts[i].buffer[j])\n    }\n  }\n  return { lower, upper, minw, maxw }\n}\nexport function slotUpperLowerVecW(arts: ArtifactBuildDataVecDense[]) {\n  const minw = [...arts[0].buffer]\n  const maxw = [...arts[0].buffer]\n  for (let i = 1; i < arts.length; i++) {\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], arts[i].buffer[j])\n      maxw[j] = Math.max(maxw[j], arts[i].buffer[j])\n    }\n  }\n  return { minw, maxw }\n}\nexport function statsUpperLowerVec(a: ArtifactsBySlotVec) {\n  const lower = [...a.base]\n  const upper = [...a.base]\n  const minw = [...a.baseBuffer]\n  const maxw = [...a.baseBuffer]\n  Object.values(a.values).forEach(slotArts => {\n    const slotUL = slotUpperLowerVec(slotArts)\n    for (let i = 0; i < lower.length; i++) {\n      lower[i] += slotUL.lower[i]\n      upper[i] += slotUL.upper[i]\n    }\n    for (let i = 0; i < minw.length; i++) {\n      minw[i] += slotUL.minw[i]\n      maxw[i] += slotUL.maxw[i]\n    }\n  })\n  return { lower, upper, minw, maxw }\n}\nexport function statsUpperLowerVecW(a: ArtifactsBySlotVec) {\n  const minw = [...a.baseBuffer]\n  const maxw = [...a.baseBuffer]\n  Object.values(a.values).forEach(slotArts => {\n    const slotUL = slotUpperLowerVecW(slotArts)\n    for (let i = 0; i < minw.length; i++) {\n      minw[i] += slotUL.minw[i]\n      maxw[i] += slotUL.maxw[i]\n    }\n  })\n  return { minw, maxw }\n}\nexport function evaluateExpandedPolynomial(poly: ExpandedPolynomial, x: DynStat) {\n  // 1. evaluate each component node\n  const nodeVals = Object.fromEntries(Object.entries(poly.nodes).map(([fk, f]) => {\n    const compute = precompute([f], {}, n => n.path[1], 1);\n    return [fk, compute([{ id: '', values: x }])[0]]\n  }))\n\n  const termVals = poly.terms.map(({ coeff, terms }) => coeff * terms.reduce((v, t) => v * nodeVals[t], 1))\n  console.log('Value of {poly(x)}: ', termVals.reduce((a, b) => a + b))\n}\n","import { reduceFormula, statsUpperLower } from '../../../../Formula/addedUtils';\nimport { optimize, precompute } from '../../../../Formula/optimization';\nimport type { NumNode } from '../../../../Formula/type';\nimport type { InterimResult, Setup } from './BackgroundWorker';\nimport { ArtifactBuildData, ArtifactsBySlot, ArtifactsBySlotVec, Build, countBuilds, DynStat, filterArts, filterArts2, mergePlot, PlotData, reaffine, RequestFilter } from './common';\nimport { ArtSetExclusionFull, countBuildsU, SubProblem, unionFilterUpperLower } from './subproblemUtil';\n\nfunction checkArtSetExclusion(setKeyCounts: DynStat, excl: ArtSetExclusionFull) {\n  let pass = Object.entries(setKeyCounts).every(([setKey, num]) => {\n    if (!excl[setKey]) return true\n    return !excl[setKey].includes(num)\n  })\n  if (!pass) return false\n\n  if (!excl['uniqueKey']) return true\n\n  const nRainbow = Object.values(setKeyCounts).reduce((a, b) => a + (b % 2), 0)\n  return !excl['uniqueKey'].includes(nRainbow)\n}\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] = []\n  plotData: PlotData | undefined\n  plotBase: NumNode | undefined\n  threshold: number = -Infinity\n  maxBuilds: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n  nodes: NumNode[]\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, artsVec, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.artsVec = artsVec\n    this.min = filters.map(x => x.min)\n    this.maxBuilds = maxBuilds\n    this.callback = callback\n    this.nodes = filters.map(x => x.value)\n    this.nodes.push(optimizationTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.plotBase = plotBase\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, _ => false)\n  }\n\n  computeU(newThreshold: number, subproblem: SubProblem) {\n    if (this.threshold < newThreshold) this.threshold = newThreshold\n    const { filters, artSetExclusion, depth } = subproblem\n    const self = this // `this` in nested functions means different things\n\n    const totalCount = countBuildsU(filters)\n    const { lower, upper, maxw } = unionFilterUpperLower(filters)\n    if (maxw[maxw.length - 1] < this.threshold) {\n      this.interimReport({ tested: 0, failed: 0, skipped: totalCount })\n      return\n    }\n\n    let nodes = [...this.nodes]\n    let min = [...this.min]\n    if (this.plotBase !== undefined) nodes.push(this.plotBase);\n    // let { statsMin, statsMax } = unionFilterUpperLower(this.arts, filter)\n    const statsMin: DynStat = Object.fromEntries(this.artsVec.keys.map((k, i) => ([k, lower[i]])))\n    const statsMax: DynStat = Object.fromEntries(this.artsVec.keys.map((k, i) => ([k, upper[i]])))\n    nodes = reduceFormula(nodes, statsMin, statsMax)\n    const reaff = reaffine(nodes, this.arts)\n    nodes = reaff.nodes\n    const preArts = reaff.arts\n\n    // const [compute, mapping, buffer] = precompute(nodes, f => f.path[1])\n    const unionArts = filters.map(filter => {\n      const a = filterArts2(preArts, filter.filterVec)\n      return Object.values(a.values)\n        .sort((a, b) => a.length - b.length)\n    })\n    const compute = precompute(nodes, preArts.base, f => f.path[1], 5)  // should p much always be 5\n    const buffer = Array<ArtifactBuildData>(5)\n    let count = { tested: 0, failed: 0, skipped: 0 }\n\n    function permute(i: number, j: number, setKeyCounts: DynStat) {\n      if (j < 0) {\n        const result = compute(buffer)\n        if (min.some((m, i) => m > result[i]) || !checkArtSetExclusion(setKeyCounts, artSetExclusion)) {\n          count.failed++\n          return\n        }\n\n        const value = result[min.length], { builds, buildValues, plotData, threshold } = self\n        let build: Build | undefined\n        if (value >= threshold) {\n          build = { value, artifactIds: buffer.map(x => x.id) }\n          builds.push(build)\n          buildValues.push(value)\n        }\n        if (plotData) {\n          const x = result[min.length + 1]\n          if (!plotData[x] || plotData[x]!.value < value) {\n            if (!build) build = { value, artifactIds: buffer.map(x => x.id) }\n            build.plot = x\n            plotData[x] = build\n          }\n        }\n        return\n      }\n\n      unionArts[i][j].forEach(art => {\n        buffer[j] = art\n\n        setKeyCounts[art.set ?? ''] = 1 + (setKeyCounts[art.set ?? ''] ?? 0)\n        permute(i, j - 1, setKeyCounts)\n        setKeyCounts[art.set ?? ''] -= 1\n        if (setKeyCounts[art.set ?? ''] === 0) delete setKeyCounts[art.set ?? '']\n      })\n\n      if (j === 0) count.tested += unionArts[i][j].length\n    }\n\n    // 4. Set up buffer with `preArts.base`\n    // for (const [key, value] of Object.entries(preArts.base)) {\n    //   const i = mapping[key]\n    //   if (i !== undefined) buffer[i] = value\n    // }\n\n    // 5. permute all combinations\n    for (let i = 0; i < unionArts.length; i++) {\n      buffer.fill({ id: '', values: {} })\n      permute(i, unionArts[i].length - 1, {})\n    }\n\n    this.interimReport(count)\n    return this.threshold\n  }\n\n  refresh(force: boolean): void {\n    const { maxBuilds } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    // I need frequent updating of threshold\n    if (true || this.builds.length >= 100000 || force) {\n      this.builds = this.builds\n        .sort((a, b) => b.value - a.value)\n        .slice(0, maxBuilds)\n    }\n  }\n  interimReport = (count: { tested: number, failed: number, skipped: number }) => {\n    this.refresh(false)\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\n    this.buildValues = []\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { ArtSetExclusion } from '../../../../Database/Data/BuildsettingData'\nimport { NumNode } from '../../../../Formula/type'\nimport { assertUnreachable } from '../../../../Util/Util'\nimport { ArtifactsBySlot, ArtifactsBySlotVec, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData } from \"./common\"\nimport { ComputeWorker } from \"./ComputeWorker\"\nimport { SplitWorker } from \"./SplitWorker\"\nimport { SubProblem } from './subproblemUtil'\n\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nonmessage = ({ data }: { data: WorkerCommand }) => {\n  const command = data.command\n  let result: WorkerResult\n  switch (command) {\n    case \"setup\":\n      id = data.id\n      const splitID = `split${id}`, computeID = `compute${id}`\n      splitWorker = new SplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\n      computeWorker = new ComputeWorker(data, interim => postMessage({ id, source: computeID, ...interim }))\n      result = { command: \"iterate\" }\n      break\n    case \"split\":\n      result = { command: \"split\", subproblems: splitWorker.split(data), ready: splitWorker.subproblems.length === 0 }\n      // console.log(id, splitWorker.subproblems)\n      break\n    case \"iterate\":\n      const { threshold, subproblem } = data\n      computeWorker.computeU(threshold, subproblem)\n      result = { command: \"iterate\" }\n      break\n    case \"finalize\":\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      result = { command: \"finalize\", builds, plotData }\n      break\n    case \"count\":\n      {\n        const { exclusion } = data, arts = computeWorker.arts\n        const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\n        let counts = data.arts.map(_ => 0)\n        for (const perm of setPerm)\n          data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\n        result = { command: \"count\", counts }\n        break\n      }\n    case \"share\":\n      const oo = splitWorker.popOne()\n      result = { command: 'share', subproblem: oo, sender: data.sender }\n      break\n    default: assertUnreachable(command)\n  }\n  postMessage({ id, ...result });\n}\n\n\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Share | Count\nexport type WorkerResult = SourcedInterimResult | SplitResult | IterateResult | FinalizeResult | ShareResult | CountResult\n\nexport interface Setup {\n  command: \"setup\"\n\n  id: number\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n\n  optimizationTarget: NumNode\n  filters: { value: NumNode, min: number }[]\n  artSetExclusion: ArtSetExclusion\n  plotBase: NumNode | undefined,\n  maxBuilds: number\n}\nexport interface Split {\n  command: \"split\"\n  threshold: number\n  minCount: number\n  maxIter: number\n\n  subproblem?: SubProblem\n}\nexport interface Iterate {\n  command: \"iterate\"\n  threshold: number\n\n  subproblem: SubProblem\n}\nexport interface Finalize {\n  command: \"finalize\"\n}\nexport interface Share {\n  command: \"share\"\n  sender: number\n}\nexport interface Count {\n  command: \"count\"\n  arts: ArtifactsBySlot[]\n  exclusion: ArtSetExclusion\n}\n\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface IterateResult {\n  command: \"iterate\"\n}\nexport interface SplitResult {\n  command: \"split\"\n  ready: boolean\n  subproblems: SubProblem[]\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface ShareResult {\n  command: \"share\"\n  subproblem?: SubProblem\n  sender: number\n}\nexport interface CountResult {\n  command: \"count\"\n  counts: number[]\n}\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface SourcedInterimResult extends InterimResult {\n  /** the source of the message, must be unique for each source of `buildValues` */\n  source: string\n}\n","import type { NumNode } from '../../../../Formula/type';\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey, SlotKey } from '../../../../Types/consts';\nimport type { InterimResult, Setup, Split } from './BackgroundWorker';\nimport { ArtifactsBySlot, ArtifactsBySlotVec, filterArtsVec, filterArtsVec2 } from './common';\nimport { cartesian, objectKeyMap, objectKeyValueMap, partition } from '../../../../Util/Util';\nimport { LinearForm } from '../../../../Formula/linearUpperBound';\nimport { applyLinearForm, countBuildsU, reduceSubProblem, RequestFilter2, slotUpperLowerVec, slotUpperLowerVecW, statsUpperLowerVec, SubProblem, SubProblemWC, UnionFilter2, unionFilterUpperLower } from './subproblemUtil';\n\nexport class SplitWorker {\n  min: number[]\n\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n  nodes: NumNode[]\n  artSet: Dict<ArtifactSetKey | 'uniqueKey', number[]>\n\n  subproblems: { count: number, upperBound: number, subproblem: SubProblem }[] = []\n\n  splitcounter: number = 0\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, artsVec, optimizationTarget, filters, artSetExclusion }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.artsVec = artsVec  // buffer is volatile, shared memory problems?\n    this.min = filters.map(x => x.min)\n    this.nodes = filters.map(x => x.value)\n    this.callback = callback\n\n    this.min.push(-Infinity)\n    this.nodes.push(optimizationTarget)\n\n    this.artSet = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n      if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n      return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n    })\n  }\n\n  addSubProblem(subproblem: SubProblem) {\n    const count = countBuildsU(subproblem.filters)\n    if (count === 0) return\n    const maxEst = Math.max(...subproblem.filters.map(({ maxw }) => maxw[maxw.length - 1]))\n    this.subproblems.push({ count, upperBound: maxEst, subproblem })\n  }\n\n  /**\n   * Iteratively splits the subproblem (depth-first) into smaller chunks until it is small enough,\n   *   as determined by `minCount`. Repeat up to `maxIter` times before returning control to the main thread.\n   * @param minCount\n   * @param maxIter\n   * @returns Either ONE [subproblem] of size `minCount` or ZERO [] subproblems.\n   */\n  split({ threshold, minCount, maxIter, subproblem }: Split): SubProblem[] {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n    const initialProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n\n    let n = 0\n    while (n < maxIter && this.subproblems.length) {\n      n += 1\n      const { count, subproblem } = this.subproblems.pop()!\n      if (count <= minCount) {\n        const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0) + count\n        this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n        return [subproblem]\n      }\n\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n      // console.log('work queue', this.subproblems)\n    }\n    const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n    this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n    return []\n  }\n\n  popOne() {\n    // Yield largest subproblem (requests => level-order / prio queue order)\n    if (this.subproblems.length === 0) return undefined\n    let ret = { i: -1, heur: -Infinity }\n    for (let i = 1; i < this.subproblems.length; i++) {\n      const { upperBound: heur } = this.subproblems[i]\n      if (heur > ret.heur) ret = { i, heur }\n    }\n    if (ret.i < 0) return undefined\n    return this.subproblems.splice(ret.i, 1)[0].subproblem\n  }\n\n  /**\n   * splitBNB takes a SubProblem and tries to perform Branch and Bound (BnB) pruning to solve for the\n   *   optimal damage value. As the name states, there are two main phases: Branching and Bounding.\n   *   The bounding is handled by an `estimateMaximum()` function call, and the branching is done by `pickBranch()`.\n   *\n   * @param threshold  Objective function lower bound threshold\n   * @param subproblem The subproblem to split\n   * @returns An array of up to 32 splits of the input subproblem.\n   */\n  splitBNB(threshold: number, subproblem: SubProblem) {\n    // 1. check threshold\n    subproblem.filters = subproblem.filters.filter(({ maxw }) => maxw[maxw.length - 1] > threshold)\n    if (subproblem.filters.length === 0) return []\n\n    // 2. Pick branching method\n    let branches0: SubProblem[] = []\n    const maxFilters = 50\n    if (subproblem.filters.length > maxFilters) {\n      // console.log('large problem detected', subproblem.filters.length)\n      // too many filters; just split them somehow I guess?\n      const filts = subproblem.filters.sort((a, b) => a.maxw[a.maxw.length - 1] - b.maxw[b.maxw.length - 1])\n      const nsplit = Math.ceil(filts.length / maxFilters)\n      const newFilts = partition(filts, nsplit)\n\n      branches0 = newFilts.map(filt => ({\n        ...subproblem,\n        filters: filt\n      }))\n    }\n    else {\n      const origBuilds = countBuildsU(subproblem.filters)\n      const pruned = performSingletonPrune(this.artsVec, threshold, subproblem)\n      const newBuilds = countBuildsU(subproblem.filters)\n      if (pruned && countBuildsU(subproblem.filters) === 0) return []\n      if (pruned && (origBuilds - newBuilds) > .3 * origBuilds) {\n        // if more than a third got pruned due to buillshit\n        branches0 = [subproblem]\n      }\n      else {\n        branches0 = this.makeBranches(threshold, subproblem)\n      }\n    }\n\n    // 3. Perform branching. Check bounding during the branching phase as well.\n    let branches = [] as { numBuilds: number, heur: number, subproblem: SubProblemWC }[]\n    branches0.forEach(branch => {\n      let numBuilds = countBuildsU(branch.filters)\n      if (numBuilds === 0) return;\n\n      let sub2 = reduceSubProblem(this.artsVec, threshold, branch)\n      if (sub2 === undefined) return;\n      sub2.depth += 1\n\n      const me = Math.max(...sub2.filters.map(({ maxw }) => maxw[maxw.length - 1]))\n      const li = sub2.lin\n      branches.push({\n        numBuilds, heur: me - li[li.length - 1].err,\n        subproblem: sub2\n      })\n    })\n    // branches.sort((a, b) => a.heur - b.heur)  // Alternative: sort by increasing maxEst - err\n    branches.sort((a, b) => b.numBuilds - a.numBuilds)  // Alternative: sort by decreasing num builds\n\n    // console.log('adding branches', branches)\n    return branches.map(({ subproblem }) => subproblem)\n  }\n\n  makeBranches(threshold: number, subproblem: SubProblemWC): SubProblemWC[] {\n    const { constraints, lin, artSetExclusion, filters } = subproblem\n    // 1a. Get min & max upper bound estimates for objective & constraints\n    const { minw, maxw, lower, upper } = unionFilterUpperLower(filters)\n\n    // console.log('splitting info', { nsp: this.splitcounter, nfilt: filters.length, cnt: countBuildsU(filters) }, { max: maxw[maxw.length - 1], min: minw[minw.length - 1] })\n    this.splitcounter += 1\n\n    // 1b. Take subset of relevant artifacts\n    const allIDs = {\n      flower: { kind: 'id', ids: new Set<string>() },\n      plume: { kind: 'id', ids: new Set<string>() },\n      sands: { kind: 'id', ids: new Set<string>() },\n      goblet: { kind: 'id', ids: new Set<string>() },\n      circlet: { kind: 'id', ids: new Set<string>() },\n    } as StrictDict<SlotKey, { kind: 'id', ids: Set<string> }>\n    filters.forEach(filt => {\n      allSlotKeys.forEach(slotKey => {\n        const setptr = allIDs[slotKey].ids\n        filt.filterVec[slotKey].forEach(ix => setptr.add(this.arts.values[slotKey][ix].id))\n      })\n    })\n    const aarts = filterArtsVec(this.artsVec, allIDs)\n\n    const thr = [...constraints.map(({ min }) => min), threshold]\n    const decisionHeur = thr.map((th, i) => (th - minw[i]) / (maxw[i] - minw[i]))\n    let argMax = -1\n    for (let i = decisionHeur.length - 1; i >= 0; i--) {\n      if (Object.keys(lin[i].w).length === 0) continue  // don't branch on an empty `lin`\n      if (argMax < 0) argMax = i                        // by default, pick optTarget to branch on\n      if (decisionHeur[argMax] < .5) continue           // Discard constraints with low probability of violation\n      if (decisionHeur[i] > decisionHeur[argMax]) argMax = i\n    }\n\n    // TODO: figure out a heuristic for when to branch on artSetExclusion instead. Currently doing so\n    //  when no other options available.\n    let branches: UnionFilter2[];\n    if (argMax < 0) {\n      // Split on set exclusion by just picking the most popular set key.\n      const feasibleKeys = allArtifactSets.filter(setKey => upper[setKey] > 0)\n\n      var branchOn = { k: undefined as ArtifactSetKey | undefined, cnt: -1 }\n      feasibleKeys.forEach(k => {\n        let cnt = upper[k]\n        if (artSetExclusion[k] && artSetExclusion[k].includes(cnt))\n          cnt = Math.min(...artSetExclusion[k]) - 1\n\n        if (cnt > branchOn.cnt) branchOn = { k, cnt }\n      })\n\n      const k = this.artsVec.keys.indexOf(branchOn.k!)\n      applyLinearForm(this.artsVec, lin)\n      branches = branchOnSetKey(k, this.artsVec, filters, lin)\n    }\n    else {\n      let linToConsider = lin[argMax]\n      let keysToConsider = Object.keys(linToConsider.w)\n\n      let shatterOn = { k: '', heur: -1 }\n      keysToConsider.forEach(k => {\n        const kix = this.artsVec.keys.indexOf(k)\n        const postShatterRangeReduction = Object.entries(aarts.values).reduce((rangeReduc, [slot, arts]) => {\n          const vals = arts.map(a => a.values[kix])\n          const minv = Math.min(...vals)\n          const maxv = Math.max(...vals)\n          if (minv === maxv) return rangeReduc\n\n          const branchVal = (minv + maxv) / 2\n          const glb = Math.max(...vals.filter(v => v <= branchVal))\n          const lub = Math.min(...vals.filter(v => v > branchVal))\n          return rangeReduc + Math.min(maxv - glb, lub - minv)\n        }, 0)\n        const heur = linToConsider.w[k] * postShatterRangeReduction * ((allArtifactSets as readonly string[]).includes(k) ? 5 : 1)\n        if (heur > shatterOn.heur) shatterOn = { k, heur }\n      })\n\n      if (shatterOn.k === '') {\n        console.log('===================== SHATTER BROKE ====================', lin, aarts)\n        throw Error('Shatter broke...')\n      }\n      // console.log('shatterOn', shatterOn)\n\n      const k = this.artsVec.keys.indexOf(shatterOn.k)\n      const targetBranchVal = (lower[k] + upper[k]) / 2\n\n      applyLinearForm(this.artsVec, lin)\n      if ((allArtifactSets as readonly string[]).includes(shatterOn.k)) {\n        branches = branchOnSetKey(k, this.artsVec, filters, lin)\n      }\n      else {\n        branches = branchOnValue(k, targetBranchVal, this.artsVec, filters, lin)\n      }\n    }\n    return branches.map(filters => ({ ...subproblem, filters, cache: true }))\n  }\n}\n\nfunction branchOnValue(k: number, target: number, arts: ArtifactsBySlotVec, filts: UnionFilter2, lin: LinearForm[]) {\n  let left: UnionFilter2 = []\n  let right: UnionFilter2 = []\n  // let allSeparate: UnionFilter2[] = []\n  // const allSplits: RequestFilter2[] = []\n  filts.forEach(filt => {\n    const { filterVec } = filt\n    const branchSplitsIx = splitToTargetIx(arts, k, target, filt)  // returns array of 1-2 splits per slot\n\n    const branchArts = objectKeyMap(allSlotKeys, slotKey => branchSplitsIx[slotKey]\n      .filter(ixs => ixs.length > 0)\n      .map(ixs => {\n        // const slotArts = a.values[slotKey].filter(({ id }) => ids.includes(id))\n        const slotArts = filterVec[slotKey].map(ix => arts.values[slotKey][ix])\n        return { slotArts, ixs, ...slotUpperLowerVec(slotArts) }\n      }))\n\n    cartesian(branchArts.flower, branchArts.plume, branchArts.sands, branchArts.goblet, branchArts.circlet)\n      .forEach(slots => {\n        const [flower, plume, sands, goblet, circlet] = slots\n        const lower = flower.lower.map((_, i) => slots.reduce((tot, { lower }) => tot + lower[i], arts.base[i]))// np.sum(-, axis=1)\n        const upper = flower.upper.map((_, i) => slots.reduce((tot, { upper }) => tot + upper[i], arts.base[i]))\n        const maxw = flower.maxw.map((_, i) => slots.reduce((tot, { maxw }) => tot + maxw[i], arts.baseBuffer[i]))\n        const minw = flower.minw.map((_, i) => slots.reduce((tot, { minw }) => tot + minw[i], arts.baseBuffer[i]))\n\n        const toPush: RequestFilter2 = {\n          filterVec: {\n            flower: flower.ixs,\n            plume: plume.ixs,\n            sands: sands.ixs,\n            goblet: goblet.ixs,\n            circlet: circlet.ixs,\n          },\n          lower, upper, minw, maxw\n        }\n\n        if (upper[k] - target > target - lower[k]) {\n          left.push(toPush)\n        }\n        else {\n          right.push(toPush)\n        }\n      })\n  })\n\n  return [left, right]\n}\n\nfunction branchOnSetKey(k: number, arts: ArtifactsBySlotVec, filts: UnionFilter2, lin: LinearForm[]): UnionFilter2[] {\n  function format(slotKey: SlotKey, set: 0 | 1, ixVec: number[]) {\n    const arts2 = ixVec.map(ix => arts.values[slotKey][ix])\n    return { set, ...slotUpperLowerVec(arts2), ixs: ixVec }\n  }\n\n  let left: UnionFilter2 = []\n  let middle: UnionFilter2 = []\n  let right: UnionFilter2 = []\n  filts.forEach(({ filterVec }) => {\n    const branchArts = objectKeyMap(allSlotKeys, slotKey => {\n      const slotArts = arts.values[slotKey]\n      const ixVec1 = filterVec[slotKey].filter(artIx => slotArts[artIx].values[k] === 0)\n      const ixVec2 = filterVec[slotKey].filter(artIx => slotArts[artIx].values[k] === 1)\n\n      const ret: ReturnType<typeof format>[] = []\n      if (ixVec1.length > 0) ret.push(format(slotKey, 0, ixVec1))\n      if (ixVec2.length > 0) ret.push(format(slotKey, 1, ixVec2))\n      return ret\n    })\n\n    cartesian(branchArts.flower, branchArts.plume, branchArts.sands, branchArts.goblet, branchArts.circlet)\n      .forEach(slots => {\n        const [flower, plume, sands, goblet, circlet] = slots\n        const lower = flower.lower.map((_, i) => slots.reduce((tot, { lower }) => tot + lower[i], arts.base[i]))  // np.sum(-, axis=1)\n        const upper = flower.upper.map((_, i) => slots.reduce((tot, { upper }) => tot + upper[i], arts.base[i]))\n        const maxw = flower.maxw.map((_, i) => slots.reduce((tot, { maxw }) => tot + maxw[i], arts.baseBuffer[i]))\n        const minw = flower.minw.map((_, i) => slots.reduce((tot, { minw }) => tot + minw[i], arts.baseBuffer[i]))\n\n        const toPush: RequestFilter2 = {\n          filterVec: {\n            flower: flower.ixs,\n            plume: plume.ixs,\n            sands: sands.ixs,\n            goblet: goblet.ixs,\n            circlet: circlet.ixs,\n          },\n          lower, upper, minw, maxw\n        }\n\n        const setCount = slots.reduce((setCount, { set }) => setCount + set, 0)\n        switch (setCount) {\n          case 0: case 1:\n            left.push(toPush)\n            break\n          case 2: case 3:\n            middle.push(toPush)\n            break\n          case 4: case 5:\n            right.push(toPush)\n            break\n          default:\n            throw Error('Unreachable')\n        }\n      })\n  })\n  return [left, middle, right]\n}\n\nfunction splitToTargetIx(a: ArtifactsBySlotVec, k: number, targ: number, { filterVec }: RequestFilter2) {\n  const n = 5\n  targ = targ - a.base[k]\n\n  // 1. Convert artifacts to simpler form & sort them on each slot\n  const ababa0 = allSlotKeys.map(slotKey => filterVec[slotKey]\n    .map(ix => ({ ix, v: a.values[slotKey][ix].values[k] }))\n    .sort(({ v: v1 }, { v: v2 }) => v1 - v2))\n  // 1b. Collapse same-values\n  const ababa = ababa0.map(arts => arts.map(({ ix, v }) => ({ ixs: [ix], v })))\n  for (let i = 0; i < ababa.length; i += 1) {\n    const aa = ababa[i]\n    for (let j = aa.length - 1; j > 0; j -= 1) {\n      if (aa[j].v == aa[j - 1].v) {\n        aa[j - 1].ixs.push(...aa[j].ixs)\n        aa.splice(j, 1)\n      }\n    }\n  }\n\n  // 2. Find a feasible solution\n  const x0 = ababa.map(arts => arts[0].v)\n  const v = ababa.map(arts => arts[arts.length - 1].v - arts[0].v)\n  if (v.every(vi => vi === 0)) v.fill(1)\n  const coeff = (targ - x0.reduce((a, b) => a + b)) / v.reduce((a, b) => a + b)\n\n  let feas = [] as number[]\n  ababa.forEach((arts, si) => {\n    let z = -1\n    for (let i = 0; i < arts.length; i++) {\n      // This can be replaced with binary search.\n      // if v[si] === 0 theres an ambiguity...\n      if (arts[i].v >= x0[si] + coeff * v[si]) {\n        z = i\n        break\n      }\n    }\n    if (z < 0) z = arts.length\n    feas.push(z)\n  })\n\n  // 3a. Convenience functions for checking correctness and scoring breaking schemes\n  function checkFeasible(breaks: number[]) {\n    let glb = 0, lub = 0\n    for (let i = 0; i < n; i++) {\n      const b = breaks[i]\n      glb += ababa[i][b - 1]?.v ?? -Infinity\n      lub += ababa[i][b]?.v ?? Infinity\n    }\n    return glb - targ <= 1e-6 && targ - lub <= 1e-6  // numerical silliness\n  }\n  function score(breaks: number[]) {\n    return breaks.reduce((p, bi) => p * bi, 1) + breaks.reduce((p, bi, i) => p * (ababa[i].length - bi), 1)\n  }\n\n  // 3b. Verify the feasible solution actually works\n  if (!checkFeasible(feas)) {\n    console.log('feas', feas, checkFeasible(feas), score(feas))\n    console.log({ x0, v, coeff, targ })\n    console.log(ababa)\n    throw Error('hmmm feas not working')\n  }\n\n  // 4. Greedily take 1-step or 2-steps until we cannot improve further.\n  //    TODO: more intelligent way to search.\n  const onesteps: readonly number[][] = [[0, 1], [0, -1], [1, 1], [1, -1], [2, 1], [2, -1], [3, 1], [3, -1], [4, 1], [4, -1]]\n  const twosteps: readonly number[][] = [[0, 1, -1, -1], [0, 1, -1, 1], [0, 1, 1, -1], [0, 1, 1, 1], [0, 2, -1, -1], [0, 2, -1, 1], [0, 2, 1, -1], [0, 2, 1, 1], [0, 3, -1, -1], [0, 3, -1, 1], [0, 3, 1, -1], [0, 3, 1, 1], [0, 4, -1, -1], [0, 4, -1, 1], [0, 4, 1, -1], [0, 4, 1, 1], [1, 2, -1, -1], [1, 2, -1, 1], [1, 2, 1, -1], [1, 2, 1, 1], [1, 3, -1, -1], [1, 3, -1, 1], [1, 3, 1, -1], [1, 3, 1, 1], [1, 4, -1, -1], [1, 4, -1, 1], [1, 4, 1, -1], [1, 4, 1, 1], [2, 3, -1, -1], [2, 3, -1, 1], [2, 3, 1, -1], [2, 3, 1, 1], [2, 4, -1, -1], [2, 4, -1, 1], [2, 4, 1, -1], [2, 4, 1, 1], [3, 4, -1, -1], [3, 4, -1, 1], [3, 4, 1, -1], [3, 4, 1, 1]]\n  while (true) {  // This must terminate within O(ababa[i].length) steps\n    let greedyStep: { score: number, next?: number[] } = { score: score(feas) }\n    onesteps.forEach(([i, di]) => {\n      let breaks = [...feas]\n      breaks[i] += di\n      if (breaks[i] < 0 || breaks[i] >= ababa[i].length) return\n      if (!checkFeasible(breaks)) return\n      const score = breaks.reduce((pr, b) => pr * b, 1) + breaks.reduce((pr, b, i) => pr * (ababa[i].length - b), 1)\n      if (score > greedyStep.score) greedyStep = { score, next: breaks }\n    })\n    twosteps.forEach(([i, j, di, dj]) => {\n      let breaks = [...feas]\n      breaks[i] += di\n      breaks[j] += dj\n      if (breaks[i] < 0 || breaks[i] >= ababa[i].length) return\n      if (breaks[j] < 0 || breaks[j] >= ababa[j].length) return\n      if (!checkFeasible(breaks)) return\n      const score = breaks.reduce((pr, b) => pr * b, 1) + breaks.reduce((pr, b, i) => pr * (ababa[i].length - b), 1)\n      if (score > greedyStep.score) greedyStep = { score, next: breaks }\n    })\n\n    if (greedyStep.next === undefined) break\n    feas = greedyStep.next\n  }\n\n  return objectKeyMap(allSlotKeys, (slotKey, i) => ([ababa[i].slice(0, feas[i]).flatMap(({ ixs }) => ixs), ababa[i].slice(feas[i]).flatMap(({ ixs }) => ixs)]))\n}\n\nfunction performSingletonPrune(arts: ArtifactsBySlotVec, threshold: number, { constraints, filters, lin }: SubProblem) {\n  applyLinearForm(arts, lin)\n  const mins = [...constraints.map(({ min }) => min), threshold]\n\n  let changed = false\n  for (let i = filters.length - 1; i >= 0; i--) {\n    const { maxw, filterVec } = filters[i]\n\n    const toremove = objectKeyMap(allSlotKeys, slot => {\n      const slotArts = filterVec[slot].map(ix => arts.values[slot][ix])\n      const { minw: minwSlot, maxw: maxwSlot } = slotUpperLowerVecW(slotArts)\n\n      const toremove: number[] = []\n      maxw.forEach((mv, j) => {\n        const cutoff = mins[j] - maxw[j] + maxwSlot[j]\n        if (minwSlot[j] > cutoff) return\n\n        toremove.push(...filterVec[slot].filter(ix => arts.values[slot][ix].buffer[j] < cutoff))\n      })\n      return new Set(toremove)\n    })\n    if (Object.values(toremove).every(rm => rm.size === 0)) continue\n\n    changed = true\n    const newFilterVec = objectKeyMap(allSlotKeys, slot => filterVec[slot].filter(ix => !toremove[slot].has(ix)))\n\n    const numBuilds = allSlotKeys.reduce((tot, slot) => tot * newFilterVec[slot].length, 1)\n    if (numBuilds === 0) {\n      filters.splice(i, 1)\n      continue\n    }\n\n    filters[i] = {\n      filterVec: newFilterVec,\n      ...statsUpperLowerVec(filterArtsVec2(arts, newFilterVec))\n    }\n  }\n\n  return changed\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [221], function() { return __webpack_require__(60743); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"45b11d4b\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/genshin-optimizer/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t743: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkgenshin_optimizer\"] = self[\"webpackChunkgenshin_optimizer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(221).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","cartesian","q","b","flatMap","d","e","flat","constant","NaN","key","percent","info","operation","operands","Number","MAX_VALUE","Infinity","sum","values","intoOps","prod","customRead","path","type","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","precompute","initial","binding","slotCount","body","names","_","f","name","operandNames","arr","fill","toString","join","Function","flatten","_formula","flattened","dep","deduplicate","elementCounts","array","wrap","common","counts","next","factored","count","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","v1","v2","match","unmatch","list","accu","reset","nextContext","allSlotKeys","allArtifactSets","nonTravelerCharacterKeys","travelerKeys","filterFeasiblePerm","artSetPerm","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","baseValue","filterArtsVec2","filterVec","baseBuffer","filterIxs","slotVals","ix","filters","_artSets","artSets","available","kind","sets","s","exclusionToAllowed","exclusion","includes","populateShapes","indexOfShape","shape","check_free","remaining","rainbows","isolated","missing","rejected","required","allowedSet","allowedCounts","j","some","groupped","used","requiredRainbows","l","usableRainbows","sort","replacing","allowedRainbows","shapes","rainbow","slice","noFilter","sumM","monomials","prodM","monos","ret","nxt","coeff","terms","constantM","readM","tag","foldLikeTerms","mono","mon","m","termsA","termsB","ai","splice","pivotInplace","A","Aij","h","findPiv1","r","c","minloc","cmp","findPiv2","minMax","lower","upper","compute","n","handleResArg","flippedResOp","flipOps","branch","bval","ge","lt","log","resf","toLinearUpperBound","stat2tag","toPureRead","slope","mon1","intercept","rop","cop","thresh","minVal","maxVal","em","denom","minEM","maxEM","loc","sqrt","below","nodesToMap","t2","t","nt","lins","w","err","bounds","nVar","boundScale","scaleProd","soln","cons","coords","objective","Ab","rows","cols","tableau","Ai","cj","ijTrack","ij","targ","side","ncol","backtrack","solveLP","wi","lub","lin","foldSum","constVal","pv","foldProd","countBuildsU","tot","_count","unionFilterUpperLower","minw","maxw","applyLinearForm","wixs","ws","baseC","li","ixs0","w0","indexOf","accum","slotKey","art","buffer","ixsi","reduceSubProblem","subp","optimizationTarget","constraints","artSetExclusion","depth","mins","statsMin","statsMax","fixedStats","statKey","abs","tagNodePairs","reducedNodes","branchVal","ni","tagsToKill","newTerms","newNodes","reducePolynomial","toNumNode","active","newOptTarget","pop","newConstraints","newMins","newArtExcl","setKey","exclude","feasibleKeys","feasible4sets","feasible2sets","allowedCnts","cnt","reducedExcl","fi","newFilters","minww","maxww","slotUpperLowerVecW","cache","slotUpperLowerVec","statsUpperLowerVec","slotArts","slotUL","splitWorker","computeWorker","ComputeWorker","callback","artsVec","plotBase","maxBuilds","builds","buildValues","plotData","interimReport","refresh","command","tested","failed","skipped","this","optimize","newThreshold","subproblem","self","totalCount","reduceFormula","reaff","preArts","unionArts","permute","setKeyCounts","excl","num","nRainbow","checkArtSetExclusion","build","artifactIds","plot","force","plots","scale","round","mergePlot","SplitWorker","items","artSet","subproblems","splitcounter","maxEst","upperBound","minCount","maxIter","addSubProblem","initialProblemTotal","newProblemTotal","splitBNB","heur","branches0","filts","rest","floor","partition","ceil","filt","origBuilds","pruned","changed","toremove","minwSlot","maxwSlot","mv","cutoff","rm","newFilterVec","performSingletonPrune","newBuilds","makeBranches","branches","numBuilds","sub2","me","allIDs","flower","ids","plume","sands","goblet","circlet","setptr","aarts","filterArtsVec","decisionHeur","th","argMax","branchOn","branchOnSetKey","linToConsider","keysToConsider","shatterOn","kix","postShatterRangeReduction","rangeReduc","vals","minv","maxv","glb","targetBranchVal","target","left","right","branchSplitsIx","ababa","ixs","aa","x0","vi","feas","checkFeasible","breaks","score","p","bi","si","z","onesteps","twosteps","greedyStep","di","pr","dj","splitToTargetIx","branchArts","slots","toPush","branchOnValue","format","ixVec","arts2","middle","ixVec1","artIx","ixVec2","setCount","onmessage","splitID","computeID","interim","postMessage","source","split","ready","computeU","setPerm","perm","countBuilds","filterArts","oo","popOne","sender","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","fulfilled","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}