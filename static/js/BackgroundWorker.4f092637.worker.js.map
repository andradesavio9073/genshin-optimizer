{"version":3,"file":"static/js/BackgroundWorker.4f092637.worker.js","mappings":"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AG1J,MAG5B,IC5ZMqP,EAAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAIrDC,GAFkB,CAAI,YAAJ,OADJ,CAAC,QAAS,MAAO,UAAW,QAAS,OAAQ,SAGzC,CAC7B,aACA,eACA,YACA,kBACA,uBACA,aACA,uBACA,gBACA,qBACA,sBACA,UACA,mBACA,eACA,sBACA,aACA,aACA,WACA,gBACA,gBACA,iBACA,gBACA,YACA,oBACA,yBACA,mBACA,sBACA,wBACA,kBACA,UACA,yBACA,yBACA,WACA,iBACA,iBACA,cACA,kBACA,sBACA,qBACA,uBAgNwB,UAzJQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,iBACA,iBACA,WACA,aACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,eACA,yBCsIeC,IAAAA,EAAAA,IAAAA,KAoBAC,GA3VV,SAASC,EAASC,EAAkBC,GAAmG,IAA5EC,EAA2E,wDACrIC,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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","Formula/expandPoly.ts","Formula/solveLP_simplex.ts","Formula/linearUpperBound.ts","Formula/addedUtils.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/subproblemUtil.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/SplitWorker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nexport default function _regeneratorRuntime() {\n  \"use strict\";\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  };\n\n  var exports = {},\n      Op = Object.prototype,\n      hasOwn = Op.hasOwnProperty,\n      $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n      iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n      asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n      toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n        generator = Object.create(protoGenerator.prototype),\n        context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n      NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n            value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n\n      reject(record.arg);\n    }\n\n    var previousPromise;\n\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          for (; ++i < iterable.length;) {\n            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n          }\n\n          return next.value = undefined, next.done = !0, next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n            record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n              hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\n  if (validate(obj, keys)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map(t => map(t))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap(d => b.map(e => [d, [e]].flat())), [[]] as T[][])\n}\n\nexport function partition<T>(q: T[], length: number): T[][] {\n  let rest = q.length % length\n  let size = Math.floor(q.length / length)\n  let j = 0;\n  return Array.from({ length }, (_, i) => q.slice(j, j += size + (i < rest ? 1 : 0)));\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\n}\n\nexport function deepFreeze(obj: any, layers: number = 5) {\n  if (layers === 0) return\n  if (typeof obj === \"object\")\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\n/** v1 >= v2 ? pass : fail */\nexport function cmp(v1: Num, v2: Num, pass: Num, fail: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n\nexport function cmpNode(a: NumNode, b: NumNode): boolean {\n  if (a.operation !== b.operation) return false;\n  if (a.operands.length !== b.operands.length) return false;\n\n  switch (a.operation) {\n    case 'read':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.path.every((ai, i) => ai === b.path[i])\n    case 'const':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.value === b.value\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      let used = [] as number[]\n      return a.operands.every((ai, i) => b.operands.some((bj, j) => {\n        if (used.includes(j)) return false\n        if (cmpNode(ai, bj)) {\n          used.push(j)\n          return true\n        }\n        return false\n      }))\n    default:\n      return a.operands.every((ai, i) => cmpNode(ai as NumNode, b.operands[i] as NumNode))\n  }\n}\n\n// Hash function pulled from StackOverflow\n//   https://stackoverflow.com/a/52171480\nconst cyrb53 = function (str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n\n// I made these numbers up; we might get better performance with different choice.\nexport function hashNode(n: NumNode): number {\n  let hsh = Math.imul(cyrb53(n.operation), 5234543537);\n  switch (n.operation) {\n    case 'const':\n      return hsh ^ cyrb53(n.value.toString(2))\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      return n.operands.reduce((hsh, ni) => hsh ^ hashNode(ni), hsh)\n    default:\n      return (n.operands as NumNode[]).reduce((hsh, ni) => Math.imul(hsh ^ hashNode(ni), 9923429423), hsh)\n  }\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objectKeyMap, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): [compute: () => Float64Array, mapping: Dict<string, number>, buffer: Float64Array] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = new Float64Array(offset).fill(0)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return [() => {\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }, objectKeyMap(readStrings, (_, i) => readOffset + i), buffer]\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allReactionModes = [\"hydro_vaporize\", \"pyro_vaporize\", \"pyro_melt\", \"cryo_melt\",] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  \"DefendersWill\",\n  \"EchoesOfAnOffering\",\n  \"EmblemOfSeveredFate\",\n  \"Gambler\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  \"HuskOfOpulentDreams\",\n  \"Instructor\",\n  \"Lavawalker\",\n  \"LuckyDog\",\n  \"MaidenBeloved\",\n  \"MartialArtist\",\n  \"NoblesseOblige\",\n  \"OceanHuedClam\",\n  \"PaleFlame\",\n  \"PrayersForDestiny\",\n  \"PrayersForIllumination\",\n  \"PrayersForWisdom\",\n  \"PrayersToSpringtime\",\n  \"ResolutionOfSojourner\",\n  \"RetracingBolide\",\n  \"Scholar\",\n  \"ShimenawasReminiscence\",\n  \"TenacityOfTheMillelith\",\n  \"TheExile\",\n  \"ThunderingFury\",\n  \"Thundersoother\",\n  \"TinyMiracle\",\n  \"TravelingDoctor\",\n  \"VermillionHereafter\",\n  \"ViridescentVenerer\",\n  \"WanderersTroupe\",\n] as const\nexport const allCharacterKeys = [\n  \"Albedo\",\n  \"Amber\",\n  \"Barbara\",\n  \"Beidou\",\n  \"Bennett\",\n  \"Chongyun\",\n  \"Diluc\",\n  \"Diona\",\n  \"Fischl\",\n  \"Ganyu\",\n  \"HuTao\",\n  \"Jean\",\n  \"Kaeya\",\n  \"Keqing\",\n  \"Klee\",\n  \"KujouSara\",\n  \"KukiShinobu\",\n  \"Lisa\",\n  \"Mona\",\n  \"Ningguang\",\n  \"Noelle\",\n  \"Qiqi\",\n  \"Razor\",\n  \"Sucrose\",\n  \"Tartaglia\",\n  \"Traveler\",\n  \"RaidenShogun\",\n  \"Venti\",\n  \"Xiangling\",\n  \"Xiao\",\n  \"Xingqiu\",\n  \"Xinyan\",\n  \"Rosaria\",\n  \"Yanfei\",\n  \"Eula\",\n  \"KaedeharaKazuha\",\n  \"KamisatoAyaka\",\n  \"Sayu\",\n  \"Shenhe\",\n  \"Yoimiya\",\n  \"Aloy\",\n  \"SangonomiyaKokomi\",\n  \"Thoma\",\n  \"Gorou\",\n  \"AratakiItto\",\n  \"YaeMiko\",\n  \"YunJin\",\n  \"Zhongli\",\n  \"KamisatoAyato\",\n  \"Yelan\",\n] as const\n\nexport const allWeaponSwordKeys = [\n  \"AmenomaKageuchi\",\n  \"AquilaFavonia\",\n  \"BlackcliffLongsword\",\n  \"CinnabarSpindle\",\n  \"CoolSteel\",\n  \"DarkIronSword\",\n  \"DullBlade\",\n  \"FavoniusSword\",\n  \"FesteringDesire\",\n  \"FilletBlade\",\n  \"FreedomSworn\",\n  \"HaranGeppakuFutsu\",\n  \"HarbingerOfDawn\",\n  \"IronSting\",\n  \"LionsRoar\",\n  \"MistsplitterReforged\",\n  \"PrimordialJadeCutter\",\n  \"PrototypeRancour\",\n  \"RoyalLongsword\",\n  \"SacrificialSword\",\n  \"SilverSword\",\n  \"SkyriderSword\",\n  \"SkywardBlade\",\n  \"SummitShaper\",\n  \"SwordOfDescension\",\n  \"TheAlleyFlash\",\n  \"TheBlackSword\",\n  \"TheFlute\",\n  \"TravelersHandySword\",\n] as const\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\n\nexport const allWeaponClaymoreKeys = [\n  \"Akuoumaru\",\n  \"BlackcliffSlasher\",\n  \"BloodtaintedGreatsword\",\n  \"DebateClub\",\n  \"FavoniusGreatsword\",\n  \"FerrousShadow\",\n  \"KatsuragikiriNagamasa\",\n  \"LithicBlade\",\n  \"LuxuriousSeaLord\",\n  \"OldMercsPal\",\n  \"PrototypeArchaic\",\n  \"Rainslasher\",\n  \"RedhornStonethresher\",\n  \"RoyalGreatsword\",\n  \"SacrificialGreatsword\",\n  \"SerpentSpine\",\n  \"SkyriderGreatsword\",\n  \"SkywardPride\",\n  \"SnowTombedStarsilver\",\n  \"SongOfBrokenPines\",\n  \"TheBell\",\n  \"TheUnforged\",\n  \"WasterGreatsword\",\n  \"Whiteblind\",\n  \"WhiteIronGreatsword\",\n  \"WolfsGravestone\",\n] as const\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\n\nexport const allWeaponPolearmKeys = [\n  \"BeginnersProtector\",\n  \"BlackcliffPole\",\n  \"BlackTassel\",\n  \"CalamityQueller\",\n  \"CrescentPike\",\n  \"Deathmatch\",\n  \"DragonsBane\",\n  \"DragonspineSpear\",\n  \"EngulfingLightning\",\n  \"FavoniusLance\",\n  \"Halberd\",\n  \"IronPoint\",\n  \"KitainCrossSpear\",\n  \"LithicSpear\",\n  \"PrimordialJadeWingedSpear\",\n  \"PrototypeStarglitter\",\n  \"RoyalSpear\",\n  \"SkywardSpine\",\n  \"StaffOfHoma\",\n  \"TheCatch\",\n  \"VortexVanquisher\",\n  \"WavebreakersFin\",\n  \"WhiteTassel\",\n] as const\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\n\nexport const allWeaponBowKeys = [\n  \"AlleyHunter\",\n  \"AmosBow\",\n  \"AquaSimulacra\",\n  \"BlackcliffWarbow\",\n  \"CompoundBow\",\n  \"ElegyForTheEnd\",\n  \"FadingTwilight\",\n  \"FavoniusWarbow\",\n  \"Hamayumi\",\n  \"HuntersBow\",\n  \"Messenger\",\n  \"MitternachtsWaltz\",\n  \"MouunsMoon\",\n  \"PolarStar\",\n  \"Predator\",\n  \"PrototypeCrescent\",\n  \"RavenBow\",\n  \"RecurveBow\",\n  \"RoyalBow\",\n  \"Rust\",\n  \"SacrificialBow\",\n  \"SeasonedHuntersBow\",\n  \"SharpshootersOath\",\n  \"SkywardHarp\",\n  \"Slingshot\",\n  \"TheStringless\",\n  \"TheViridescentHunt\",\n  \"ThunderingPulse\",\n  \"WindblumeOde\",\n] as const\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\n\nexport const allWeaponCatalystKeys = [\n  \"ApprenticesNotes\",\n  \"BlackcliffAgate\",\n  \"DodocoTales\",\n  \"EmeraldOrb\",\n  \"EverlastingMoonglow\",\n  \"EyeOfPerception\",\n  \"FavoniusCodex\",\n  \"Frostbearer\",\n  \"HakushinRing\",\n  \"KagurasVerity\",\n  \"LostPrayerToTheSacredWinds\",\n  \"MagicGuide\",\n  \"MappaMare\",\n  \"MemoryOfDust\",\n  \"OathswornEye\",\n  \"OtherworldlyStory\",\n  \"PocketGrimoire\",\n  \"PrototypeAmber\",\n  \"RoyalGrimoire\",\n  \"SacrificialFragments\",\n  \"SkywardAtlas\",\n  \"SolarPearl\",\n  \"TheWidsith\",\n  \"ThrillingTalesOfDragonSlayers\",\n  \"TwinNephrite\",\n  \"WineAndSong\",\n] as const\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type ReactionModeKey = typeof allReactionModes[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\n","import { ArtSetExclusion } from \"../../../../Database/Data/BuildsettingData\";\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\n\ntype DynMinMax = { [key in string]: MinMax }\ntype MinMax = { min: number, max: number }\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nexport function reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\n\n  function visit(node: NumNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(_op => {\n      const op = _op as NumNode\n      affineNodes.has(op) && topLevelAffine.add(op)\n    })\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const operation = f.operation\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\":\n        if (typeof f.value === \"string\" || f.value === undefined)\n          throw new Error(`Found constant ${f.value} while compacting`)\n        visit(f as NumNode, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\n    Object.keys(arts.base).length === dynKeys.size)\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\n  let progress = false\n  const noRainbow = !exclusion.rainbow?.length\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return constant(0)\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter(key => arts.every(art => art.values[key]))\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\n  const range = new Map<NumNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, _f => {\n    const f = _f as NumNode\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"subscript\": current = computeMinMax(f.list); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = computeMinMax([0])\n        else current = computeMinMax([0], [operands[2]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      case \"data\": case \"lookup\": case \"match\":\n        throw new Error(`Unsupported ${operation} node`)\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\nexport function filterArtsVec(arts: ArtifactsBySlotVec, filters: RequestFilter): ArtifactsBySlotVec {\n  return {\n    keys: arts.keys, base: arts.base, baseBuffer: arts.baseBuffer,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\nexport function filterArts2(arts: ArtifactsBySlot, filterVec: StrictDict<SlotKey, number[]>): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filterIxs = filterVec[slot]\n      const slotVals = arts.values[slot]\n      return filterIxs.map(ix => slotVals[ix])\n    })\n  }\n}\nexport function filterArtsVec2(arts: ArtifactsBySlotVec, filterVec: StrictDict<SlotKey, number[]>): ArtifactsBySlotVec {\n  return {\n    keys: arts.keys, base: arts.base, baseBuffer: arts.baseBuffer,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filterIxs = filterVec[slot]\n      const slotVals = arts.values[slot]\n      return filterIxs.map(ix => slotVals[ix])\n    })\n  }\n}\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n\n\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\n        case \"id\": break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\n  return new Set(exclusion?.includes(2)\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length))\n        shapes.push(current)\n      return\n    }\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\n      return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\n        shape[replacing] = 5\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\n\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set()\n    let groupped: number[][] = [], rainbows: number[] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length)\n        return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set], count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find(x => x > count)! - count\n          missing.push(set)\n        }\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport const emptyfilter: RequestFilter = objectKeyMap(allSlotKeys, _ => ({ kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }));\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\n\n\nexport type ArtifactBuildDataVecDense = {\n  id: string\n  set?: ArtifactSetKey\n  values: number[]\n  buffer: number[]\n}\n// I dont *think* its worth it to implement sparse vectors n shit\n// export type ArtifactBuildDataVecSparse = {\n//   id: string\n//   set?: ArtifactSetKey\n//   values: number[][]\n// }\nexport type ArtifactsBySlotVec = { keys: string[], base: number[], values: StrictDict<SlotKey, ArtifactBuildDataVecDense[]>, baseBuffer: number[] }\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import { sum, prod, hashNode, cmpNode } from \"./utils\"\nimport { ConstantNode, NumNode } from \"./type\"\nimport { allArtifactSets } from \"../Types/consts\"\nimport { cartesian } from '../Util/Util'\nimport { forEachNodes } from \"./internal\"\nimport { makeid } from \"./optimize2\"\nimport { DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\n\nfunction countSlotUsage(node: NumNode): DynStat {\n  if (node.operation === 'add') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => {\n      Object.entries(b).forEach(([slotKey, n]) => a[slotKey] = Math.min(n, a[slotKey] ?? 0))\n      return a\n    }, {})\n  }\n  else if (node.operation === 'mul') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => {\n      Object.entries(b).forEach(([slotKey, n]) => a[slotKey] = Math.max(n, a[slotKey] ?? 0))\n      return a\n    }, {})\n  }\n  else if (node.operation === 'threshold') {\n    const branch = node.operands[0]\n    if (branch.operation === 'read' && (allArtifactSets as readonly string[]).includes(branch.path[1])) {\n      let con = node.operands[1] as ConstantNode<number>\n      return { [branch.path[1]]: con.value }\n    }\n  }\n  return {}\n}\n\nfunction filterProductPossible({ terms, nodes }: ExpandedPolynomial, slotsLeft = 5) {\n  let sCount = Object.fromEntries(Object.entries(nodes).map(([tag, n]) => [tag, countSlotUsage(n)]))\n\n  terms = terms.filter(({ terms }) => {\n    const slotUsage = terms.reduce((tot, s) => {\n      Object.entries(sCount[s]).forEach(([slotKey, n]) => tot[slotKey] = Math.max(n, tot[slotKey] ?? 0))\n      return tot\n    }, {} as DynStat)\n    return Object.values(slotUsage).reduce((a, b) => a + b, 0) <= slotsLeft\n  })\n  return { terms, nodes }\n}\n\nexport type Monomial = {\n  coeff: number,\n  terms: string[]\n}\nexport type ExpandedPolynomial = {\n  terms: Monomial[],\n  nodes: Dict<string, NumNode>,\n}\n\nexport function sumM(...monomials: Monomial[][]): Monomial[] {\n  return monomials.flat()\n}\nexport function prodM(...monomials: Monomial[][]): Monomial[] {\n  return cartesian(...monomials).map(monos => monos.reduce((ret, nxt) => {\n    ret.coeff *= nxt.coeff\n    ret.terms.push(...nxt.terms)\n    return ret\n  }, { coeff: 1, terms: [] }))\n}\nexport function constantM(v: number): Monomial[] {\n  return [{ coeff: v, terms: [] }]\n}\nexport function readM(tag: string): Monomial[] {\n  return [{ coeff: 1, terms: [tag] }]\n}\n\nexport function foldLikeTerms(mono: Monomial[]): Monomial[] {\n  let mon = [...mono]\n  mon.forEach(m => m.terms.sort())\n  mon.sort(({ terms: termsA }, { terms: termsB }) => {\n    if (termsA.length !== termsB.length) return termsA.length - termsB.length\n    for (let i = 0; i < termsA.length; i++) {\n      if (termsA[i] !== termsB[i]) return termsA[i] < termsB[i] ? -1 : 1\n    }\n    return 0\n  })\n\n  for (let i = mon.length - 2; i >= 0; i--) {\n    let a = mon[i].terms\n    let b = mon[i + 1].terms\n    if (a.length !== b.length) continue\n    if (a.every((ai, i) => ai === b[i])) {\n      mon[i].coeff = (mon[i].coeff ?? 0) + (mon[i + 1].coeff ?? 0)\n      mon.splice(i + 1, 1)\n    }\n  }\n  return mon\n}\n\n/**\n * Factors damage formula into sums of monomials in each variable.\n * For example:  (1700 * atk_ + atk) * (1 + cr * cd) * (1 + sum_frac(EM))\n *   -> 1700 * atk_ + 1700 * atk_ * cr * cd + 1700 * atk_ * sum_frac(EM) + 1700 * atk_ * cr * cd * sum_frac(EM)\n *            + atk +         atk * cr * cd +         atk * sum_frac(EM) +         atk * cr * cd * sum_frac(EM)\n *\n * For a total of 8 terms, since there are 3 pairs of additions, for 2^3 sum-of-product terms.\n *\n * isVar() is used to check whether any node should be considered a variable on its own.\n */\ntype NodeLinkedList = { n: NumNode, tag: string, next: NodeLinkedList | undefined }\nexport function expandPoly(node: NumNode, inheritTags?: string[]): ExpandedPolynomial {\n  let varMap = {} as Dict<number, NodeLinkedList> // my shitty hashmap\n  let tagMap = {} as Dict<string, NumNode>\n  const varTags = inheritTags ?? []\n  function lookup(n: NumNode) {\n    let hsh = hashNode(n)\n    let z = varMap[hsh]\n    while (z !== undefined) {\n      if (cmpNode(z.n, n)) return z.tag\n      z = z.next\n    }\n    const newTag = makeid(10, varTags)\n    varMap[hsh] = { n, tag: newTag, next: varMap[hsh] }\n    tagMap[newTag] = n\n    varTags.push(newTag)\n    return newTag\n  }\n\n  let stat2tag = {} as Dict<string, string>\n  forEachNodes([node], _ => { }, n => {\n    if (n.operation === 'read') stat2tag[n.path[1]] = lookup(n as NumNode)\n  })\n\n  function toSOP(n: NumNode): Monomial[] {\n    switch (n.operation) {\n      case 'add':\n        return sumM(...n.operands.map(toSOP))\n      case 'mul':\n        return prodM(...n.operands.map(toSOP))\n      case 'const':\n        return constantM(n.value)\n      default:\n        return readM(lookup(n))\n    }\n  }\n\n  // let sop = toSOP(node)\n  let sop = foldLikeTerms(toSOP(node))\n  return filterProductPossible({\n    terms: sop,\n    nodes: tagMap,\n  })\n}\n\n// Really should avoid using this function ever\nexport function toNumNode({ nodes, terms }: ExpandedPolynomial) {\n  return sum(...terms.map(({ coeff, terms }) => prod(coeff, ...terms.map(t => nodes[t]!))))\n}\n","function pivotInplace(A: number[][], { i, j }: { i: number, j: number }) {\n  const Aij = A[i][j]\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    for (let k = 0; k < A[0].length; k++) {\n      if (k === j) continue\n      A[h][k] -= A[i][k] * A[h][j] / Aij\n    }\n  }\n  for (let h = 0; h < A.length; h++) {\n    if (h === i) continue\n    A[h][j] = -A[h][j] / Aij\n  }\n  for (let k = 0; k < A[0].length; k++) {\n    if (k === j) continue\n    A[i][k] = A[i][k] / Aij\n  }\n  A[i][j] = 1 / Aij\n}\n\nfunction findPiv1(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= 0) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > 1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\nfunction findPiv2(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= 0) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\nfunction backtrack(tableau: number[][], ijTrack: { i: number, j: number }[], targ: number) {\n  let side = 1;  // 0 left, 1 right\n  ijTrack.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    }\n    else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to:\n *   https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* a problem for GO's use\n *   case. This algorithm is fairly numerically unstable though, use with care & always\n *   try to verify the solution. It's also a fair bit slower than it needs to be.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        the optimal solution x\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  let rows = Ab.length + 1\n  let cols = Ab[0].length\n\n  let tableau = Array(rows).fill(0).map(_ => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => tableau[i][j] = Aij))\n  // b.forEach((bi, i) => tableau[i][cols - 1] = bi)\n  c.forEach((cj, j) => tableau[rows - 1][j] = cj)\n  // console.log('tab', tableau)\n\n  let ijTrack: { i: number, j: number }[] = []\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < 0)) {\n    const ij = findPiv2(tableau)\n    ijTrack.push(ij)\n    // tableau = pivot(tableau, ij)\n    pivotInplace(tableau, ij)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < 0)) {\n    const ij = findPiv1(tableau)\n    ijTrack.push(ij)\n    // tableau = pivot(tableau, ij)\n    pivotInplace(tableau, ij)\n  }\n\n  return c.map((_, i) => backtrack(tableau, ijTrack, i))\n}\n","import { NumNode } from \"./type\"\nimport { ArtifactsBySlot, ArtifactsBySlotVec, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { constant, sum, prod, cmp } from \"./utils\"\nimport { ExpandedPolynomial, Monomial, sumM, prodM, constantM, readM, foldLikeTerms } from './expandPoly'\nimport { precompute, allOperations } from \"./optimization\"\nimport { solveLP } from './solveLP_simplex'\nimport { cartesian } from '../Util/Util'\nimport { fillBuffer } from \"./addedUtils\"\n\nexport type LinearForm = {\n  w: DynStat,\n  c: number,\n  err: number\n}\nexport type LinearFormVec = {\n  w: number[],\n  c: number,\n  err: number\n}\n\nfunction minMax(node: NumNode, lower: DynStat, upper: DynStat) {\n  let [compute, mapping, buffer] = precompute([node], n => n.path[1])\n  fillBuffer(lower, mapping, buffer)\n  const minval = compute()[0]\n  fillBuffer(upper, mapping, buffer)\n  const maxval = compute()[0]\n  return [minval, maxval]\n}\n\n/**\n * `res` is the ONE place where negative arguments & negative slopes are allowed.\n * @param node\n */\nfunction handleResArg(node: { 'operation': 'res', 'operands': NumNode[] }, lower: DynStat, upper: DynStat) {\n  function flipOps(n: NumNode): NumNode {\n    switch (n.operation) {\n      case 'add':\n        return sum(...n.operands.map(n => flipOps(n)))\n      case 'const':\n        return constant(-n.value)\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (ge.operation === 'const' && lt.operation === 'const') {\n          if (ge.value <= lt.value) {\n            return cmp(branch, bval, -ge.value, -lt.value)\n          }\n        }\n        console.log(n)\n        throw Error('(res neg slope): threshold. Something went wrong.')\n      default:\n        console.log(n)\n        throw Error('(res neg slope) Havent written logic to handle this')\n    }\n  }\n\n  const flippedResOp = flipOps(node.operands[0])\n\n  let [a, b] = minMax(flippedResOp, lower, upper)\n  let resf = allOperations['res']\n  let [c, d] = [resf([-a]), resf([-b])]\n\n  if (b > 0 && a > -1.75) {\n    // 1 + x / 2\n    return sum(1, prod(.5, flippedResOp))\n  }\n\n  const intercept = (b * c - a * d) / (b - a)\n  const slope = (c - d) / (b - a)\n  return sum(intercept, prod(slope, flippedResOp))\n}\n\n/**\n * First converts a product of variables (including max, min, sum_frac, threshold, etc.) to\n *   a pure product form consisting of only `read` and `const` nodes, guaranteeing the\n *   product form is an upper bound.\n *\n * Then on the product form, create a linear upper bound using `lub` and return it.\n *\n * @param node The formula to expand\n * @param lower Stat lower bounds\n * @param upper Stat upper bounds\n * @returns\n */\nexport function toLinearUpperBound({ nodes, terms }: ExpandedPolynomial, lower: DynStat, upper: DynStat): LinearForm {\n  let stat2tag = {} as Dict<string, string>\n  Object.entries(nodes).forEach(([tag, n]) => {\n    if (n.operation === 'read') stat2tag[n.path[1]] = tag\n  })\n\n  let linerr = 0\n  function toPureRead(n: NumNode): Monomial[] {\n    switch (n.operation) {\n      case 'const':\n        return constantM(n.value)\n      case 'read':\n        return readM(stat2tag[n.path[1]]!)\n      case 'add':\n        return sumM(...n.operands.map(toPureRead))\n      case 'mul':\n        return prodM(...n.operands.map(toPureRead))\n\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (branch.operation === 'read' && bval.operation === 'const'\n          && lt.operation === 'const' && ge.operation === 'const') {\n          if (ge.value < lt.value) {\n            console.log(n)\n            throw Error('Not Implemented (threshold must be increasing)')\n          }\n\n          let key = branch.path[1]\n          if (lower[key] >= bval.value) return constantM(ge.value)\n          if (upper[key] < bval.value) return constantM(lt.value)\n\n          const slope = (ge.value - lt.value) / (bval.value - lower[key])\n          const mon1 = prodM(constantM(slope), readM(stat2tag[branch.path[1]]!))\n          if (lt.value === 0) return mon1\n          return sumM(constantM(lt.value), mon1)\n        }\n        console.log(n)\n        throw Error('Not Implemented (threshold must branch between constants)')\n      case 'res':\n        let op = handleResArg(n as { 'operation': 'res', 'operands': NumNode[] }, lower, upper)\n        return toPureRead(op)\n\n      case 'min': case 'max':\n        let [rop, cop] = n.operands\n        if (cop.operation !== 'const')\n          [rop, cop] = [cop, rop]  // Assume min(const, read)\n        if (n.operation === 'min') return toPureRead(rop)\n\n        if (cop.operation === 'const') {\n          const thresh = cop.value\n          const [minVal, maxVal] = minMax(rop, lower, upper)\n          if (minVal > thresh) return toPureRead(rop)\n          if (thresh > maxVal) return constantM(thresh)\n\n          // rescale `rop` to be above thresh, since max(f, 0) is a convex function\n          const m = (maxVal - thresh) / (maxVal - minVal)\n          const b = thresh - minVal\n          return sumM(constantM(b), prodM(constantM(m), toPureRead(rop)))\n        }\n        console.log(n)\n        throw Error('Not Implemented (max between two non-constants)')\n\n      case 'sum_frac':\n        const [em, denom] = n.operands\n        if (denom.operation !== 'const') throw Error('Not Implemented (non-constant sum_frac denominator)')\n\n        const [minEM, maxEM] = minMax(em, lower, upper)\n        const k = denom.value\n        // The sum_frac form is concave, so any Taylor expansion of EM / (EM + k) gives an upper bound.\n        // We can solve for the best Taylor approximation location with the following formula.\n        let loc = Math.sqrt((minEM + k) * (maxEM + k)) - k\n        let below = (k + loc) * (k + loc)\n        let slope = k / below\n        let c = loc * loc / below\n\n        // TODO: update linerr\n        return sumM(constantM(c), prodM(constantM(slope), toPureRead(em)))\n\n      default:\n        console.log(n)\n        throw Error('Not Implemented')\n    }\n  }\n\n  // 1. Turn all nodes into linear upper bounds\n  const nodesToMap = Object.fromEntries(Object.entries(nodes).filter(([tag, n]) => n.operation !== 'read').map(([tag, n]) => [tag, toPureRead(n)]))\n\n  // 2. substitute into `terms` and construct a new SOPForm whose nodes are all pure read nodes\n  let t2 = terms.flatMap(({ coeff, terms }) => prodM(constantM(coeff), ...terms.map(t => nodesToMap[t] ?? readM(t))))\n  t2 = foldLikeTerms(t2)\n\n  // 2.5 Re-name all the tags to their read node version\n  t2 = t2.map(({ coeff, terms }) => {\n    terms = terms.map(t => {\n      const nt = nodes[t]\n      if (!nt || nt.operation !== 'read') throw Error('MUST be a read node.')\n      return nt.path[1]\n    })\n    return { coeff, terms }\n  })\n\n  // 3. call lub() on each term\n  const lins = t2.map(({ coeff, terms }) => {\n    if (terms.length === 0) return { w: {}, c: coeff, err: 0 }\n    if (terms.length === 1) return { w: { [terms[0]]: coeff }, c: 0, err: 0 }\n    const { w, c, err } = lub(terms.map(k => ({ lower: lower[k], upper: upper[k] })))\n    const retw = w.reduce((ret, wi, i) => {\n      ret[terms[i]] = wi * coeff + (ret[terms[i]] ?? 0)\n      return ret\n    }, {} as DynStat)\n    return { w: retw, c: coeff * c, err: coeff * err + linerr }\n  })\n\n  return lins.reduce((lin, l) => {\n    lin.c += l.c; lin.err += l.err\n    Object.entries(l.w).forEach(([k, v]) => lin.w[k] = v + (lin.w[k] ?? 0))\n    return lin\n  }, { w: {}, c: 0, err: 0 })\n}\n\n/**\n * Constructs an upper bounding linear form for a function x_1 * x_2 * ... * x_n\n * @param bounds upper and lower bounds for each x_i\n * @returns { w, c, err } with\n */\nfunction lub(bounds: { lower: number, upper: number }[]): { w: number[], c: number, err: number } {\n  if (bounds.length === 0) return { w: [], c: 0, err: 0 }\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ upper }) => upper)\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ lower, upper }) => ({ lower: lower / upper, upper: 1 }))\n\n  // Setting up the linear program in terms of constraints.\n  let cons = cartesian(...bounds.map(({ lower, upper }) => [lower, upper])).flatMap((coords) => {\n    const prod = coords.reduce((prod, v) => prod * v, 1)\n    return [\n      [...coords.map(v => -v), 1, 0, -prod],\n      [...coords, -1, -1, prod],\n    ]\n  })\n\n  // Force equality at upper & lower corners?\n  // cons.push([...bounds.map(lu => lu.lower), -1, 0, bounds.reduce((prod, { lower }) => prod * lower, 1)])\n  // cons.push([...bounds.map(lu => lu.upper), -1, 0, bounds.reduce((prod, { upper }) => prod * upper, 1)])\n\n  let soln: any\n  const objective = [...bounds.map(_ => 0), 0, 1]\n  try {\n    // TODO: verify solution\n    soln = solveLP(objective, cons)\n  }\n  catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    throw e\n  }\n  return {\n    w: soln.slice(0, nVar).map((wi, i) => wi * scaleProd / boundScale[i]),\n    c: -scaleProd * soln[nVar],\n    err: scaleProd * soln[nVar + 1]\n  }\n}\n\nexport function maxWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmulMax([lin], [a.base])[0] + lin.c\n\n  return baseVal + Object.entries(a.values)\n    .reduce((maxTotVal, [slotKey, slotArts]) => maxTotVal + sparseMatmulMax([lin], slotArts.map(a => a.values))[0], 0)\n}\nexport function minWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmulMin([lin], [a.base])[0] + lin.c\n\n  return baseVal + Object.entries(a.values)\n    .reduce((minTotVal, [slotKey, slotArts]) => minTotVal + sparseMatmulMin([lin], slotArts.map(a => a.values))[0], 0)\n}\n\nexport function maxWeightVec(a: ArtifactsBySlotVec, lin: LinearForm) {\n  const ixs: number[] = []\n  const w: number[] = []\n  Object.entries(lin.w).forEach(([k, ww]) => {\n    ixs.push(a.keys.indexOf(k))\n    w.push(ww)\n  })\n\n  const baseVal = ixs.reduce((accum, ix, i) => accum + a.base[ix] * w[i], lin.c)\n  return Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.max(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n}\nexport function minMaxWeightVec(a: ArtifactsBySlotVec, lin: LinearForm) {\n  const ixs: number[] = []\n  const w: number[] = []\n  Object.entries(lin.w).forEach(([k, ww]) => {\n    ixs.push(a.keys.indexOf(k))\n    w.push(ww)\n  })\n\n  const baseVal = ixs.reduce((accum, ix, i) => accum + a.base[ix] * w[i], lin.c)\n  const maxw = Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.max(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n\n  const minw = Object.values(a.values)\n    .reduce((wtot, arts) => wtot + Math.min(\n      ...arts.map(art => ixs.reduce((accum, ix, i) => accum + art.values[ix] * w[i], 0))\n    ), baseVal)\n  return { minw, maxw }\n}\n\n\n\n// Implement matrix multiply between row-major w's of LinearForm and col-major DynStats that represent artifacts.\n/**\n * Implements sparse matrix multiplication between A and x\n * @param A A list of row-major w's of some LinearForm\n * @param x A list of col-major DynStats that represent some artifacts\n * @returns A col-major 2d array number[][] with shape (A.length, x.length).\n *          ret[0] is [A1 @ x1, A2 @ x1, ..., An @ x1]\n */\nexport function sparseMatmul(A: LinearForm[], x: DynStat[]) {\n  return x.map(dyn => A.map(({ w }) => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0)))\n}\n\n/**\n * Sparse matrix multiplication between A and x, followed by a max() along the rows.\n */\nexport function sparseMatmulMax(A: LinearForm[], x: DynStat[]) {\n  return A.map(({ w }) => Math.max(...x.map(dyn => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0))))\n}\n\n/**\n * Sparse matrix multiplication between A and x, followed by a min() along the rows.\n */\nexport function sparseMatmulMin(A: LinearForm[], x: DynStat[]) {\n  return A.map(({ w }) => Math.min(...x.map(dyn => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0))))\n}\n","import { constant, sum, prod, cmp } from \"./utils\"\nimport { NumNode } from \"./type\"\nimport { allOperations } from \"./optimization\"\nimport { mapFormulas } from \"./internal\"\nimport { ArtifactBuildData, ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { LinearForm, maxWeight, toLinearUpperBound } from \"./linearUpperBound\"\nimport { foldLikeTerms, ExpandedPolynomial } from \"./expandPoly\"\nimport { ArtifactSetKey } from \"../Types/consts\"\nimport { ArtSetExclusion } from \"../Database/Data/BuildsettingData\"\n\nexport function foldSum(nodes: readonly NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n  nodes = nodes.flatMap(n => n.operation === 'add' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv + n.value : pv, 0)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 0) {\n    if (nodes.length === 1) return nodes[0]\n    return sum(...nodes)\n  }\n  return sum(...nodes, constant(constVal))\n}\n\nexport function foldProd(nodes: readonly NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n  nodes = nodes.flatMap(n => n.operation === 'mul' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv * n.value : pv, 1)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 1) return prod(...nodes)\n  return prod(...nodes, constant(constVal))\n}\n\nexport function slotUpperLower(a: ArtifactBuildData[]) {\n  if (a.length === 0) return { statsMin: {}, statsMax: {} }\n  // Assume keys are the same for all artifacts.\n  const keys = Object.keys(a[0].values)\n  let statsMin: DynStat = {}\n  let statsMax: DynStat = {}\n  let sets = new Set<ArtifactSetKey>()\n  keys.forEach(k => {\n    statsMin[k] = Infinity\n    statsMax[k] = -Infinity\n  })\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < keys.length; j++) {\n      const k = keys[j]\n      statsMin[k] = Math.min(a[i].values[k], statsMin[k])\n      statsMax[k] = Math.max(a[i].values[k], statsMax[k])\n    }\n    if (a[i].set) sets.add(a[i].set!)\n  }\n  sets.forEach(set => {\n    statsMax[set] = 1\n    statsMin[set] = 0\n  })\n  if (sets.size === 1) {\n    const [s] = sets\n    statsMin[s] = 1\n  }\n  return { statsMin, statsMax }\n}\n\nexport function statsUpperLower(a: ArtifactsBySlot) {\n  let statsMin: DynStat = { ...a.base }\n  let statsMax: DynStat = { ...a.base }\n  Object.entries(a.values).forEach(([slotKey, slotArts]) => {\n    const { statsMin: smin, statsMax: smax } = slotUpperLower(slotArts)\n    Object.keys(smin).forEach(sk => {\n      statsMin[sk] = smin[sk] + (statsMin[sk] ?? 0)\n      statsMax[sk] = smax[sk] + (statsMax[sk] ?? 0)\n    })\n  })\n  return { statsMin, statsMax }\n}\n\nexport function reduceFormula(f: NumNode[], lower: DynStat, upper: DynStat) {\n  const fixedStats = Object.keys(lower).filter(statKey => lower[statKey] === upper[statKey])\n  let f2 = mapFormulas(f, n => n, n => {\n    switch (n.operation) {\n      case 'add':\n        return foldSum(n.operands)\n      case 'mul':\n        return foldProd(n.operands)\n\n      case 'read':\n        if (fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n        return n\n      case 'threshold':\n        const [branch, branchVal, ge, lt] = n.operands\n        if (branch.operation === 'const' && branchVal.operation === 'const')\n          return branch.value >= branchVal.value ? ge : lt\n        if (branch.operation === 'read' && branchVal.operation === 'const') {\n          if (lower[branch.path[1]] >= branchVal.value) return ge\n          if (upper[branch.path[1]] < branchVal.value) return lt\n        }\n        return n\n      case 'min': case 'max':\n      case 'res': case 'sum_frac':\n        if (n.operands.every(ni => ni.operation === 'const')) {\n          const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n          return constant(out)\n        }\n        return n\n      default:\n        return n\n    }\n  })\n\n  // f2 = optimize(f2, {})\n  return f2\n}\n\nexport function reducePolynomial(f: ExpandedPolynomial[], lower: DynStat, upper: DynStat): ExpandedPolynomial[] {\n  const fixedStats = Object.keys(lower).filter(statKey => Math.abs(lower[statKey] - upper[statKey]) < 1e-6)\n  return f.map(({ nodes, terms }) => {\n    // 1. Reduce nodes by substituting constants\n    const tagNodePairs = Object.entries(nodes)\n    const reducedNodes = mapFormulas(tagNodePairs.map(([k, v]) => v), n => n, n => {\n      switch (n.operation) {\n        case 'read':\n          if (fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n          return n\n        case 'threshold':\n          const [branch, branchVal, ge, lt] = n.operands\n          if (branch.operation === 'const' && branchVal.operation === 'const')\n            return branch.value >= branchVal.value ? ge : lt\n          if (branch.operation === 'read' && branchVal.operation === 'const') {\n            if (lower[branch.path[1]] >= branchVal.value) return ge\n            if (upper[branch.path[1]] < branchVal.value) return lt\n          }\n          else throw Error('Branch between non-read and non-const!!!')\n          return n\n        case 'add':\n          return foldSum(n.operands)\n        case 'mul':\n          return foldProd(n.operands)\n        case 'res': case 'sum_frac':\n          if (n.operands.every(ni => ni.operation === 'const')) {\n            const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n            return constant(out)\n          }\n          return n\n        case 'min': case 'max':\n          // TODO: reduce min & max\n          if (n.operands.every(ni => ni.operation === 'const')) {\n            const out = allOperations[n.operation](n.operands.map(ni => ni.operation === 'const' ? ni.value : NaN))\n            return constant(out)\n          }\n          return n\n        default:\n          return n\n      }\n    })\n\n    // 2a. Find all the nodes that have been reduced to constants\n    let tagsToKill = {} as Dict<string, number>\n    reducedNodes.forEach((n, i) => {\n      if (n.operation !== 'const') return\n      const [tag] = tagNodePairs[i]\n      tagsToKill[tag] = n.value\n    })\n\n    // 2b. Substitute the constant nodes in where possible\n    let newTerms = terms.map(mon => {\n      let c = mon.coeff\n      const newTerms = mon.terms.filter(t => {\n        if (tagsToKill[t] !== undefined) {\n          c *= tagsToKill[t]!\n          return false\n        }\n        return true\n      })\n      if (c === 0) return { coeff: 0, terms: [] }\n      return { coeff: c, terms: newTerms }\n    })\n\n    // 3. Delete all the constant tags & add like terms together\n    let newNodes = Object.fromEntries(reducedNodes.map((n, i) => [tagNodePairs[i][0], n]))\n    Object.keys(tagsToKill).forEach(t => delete newNodes[t])\n    return { nodes: newNodes, terms: foldLikeTerms(newTerms) }\n  })\n}\n\n/**\n * Estimates maximum value across an array of formulas\n * @param f              Functions to maximize\n * @param a              Artifact set\n * @param cachedCompute  Optional Prior cached compute. If specified, will re-calculate `maxEst` assuming `lin, lower, upper` are correct.\n * @returns              CachedCompute\n */\ntype MaxEstQuery2 = { f: ExpandedPolynomial[], a: ArtifactsBySlot, cachedCompute: { lower: DynStat, upper: DynStat } }\n  | { f?: undefined, cachedCompute: { lin: LinearForm[], lower: DynStat, upper: DynStat }, a: ArtifactsBySlot }\nexport function estimateMaximum({ f, a, cachedCompute }: MaxEstQuery2) {\n  if (f === undefined) {\n    return { maxEst: cachedCompute.lin.map(l => maxWeight(a, l)), ...cachedCompute }\n  }\n\n  const { lower, upper } = cachedCompute\n  const est = f.map(fi => {\n    const lin = toLinearUpperBound(fi, lower, upper)\n    return { maxEst: maxWeight(a, lin), lin }\n  })\n\n  return {\n    maxEst: est.map(({ maxEst }) => maxEst),\n    lin: est.map(({ lin }) => lin),\n    lower, upper\n  }\n}\n\nexport function fillBuffer(stats: DynStat, mapping: Dict<string, number>, buffer: Float64Array) {\n  Object.entries(stats)\n    .filter(([k]) => mapping[k] !== undefined)\n    .forEach(([k, v]) => buffer[mapping[k]!] = v)\n}\n\nexport function thresholdExclusions(nodes: NumNode[], excl: ArtSetExclusion) {\n  nodes = mapFormulas(nodes, n => n, n => {\n    switch (n.operation) {\n      case 'threshold':\n        const [branch, branchVal, ge, lt] = n.operands\n        if (branch.operation === 'read' && branchVal.operation === 'const') {\n          const key = branch.path[1] as ArtifactSetKey\n          if (excl[key] !== undefined) {\n            const exc = excl[key] as (2 | 4)[]\n            // Based on exclusion, either return `lt` or shift `branchVal` to 4.\n            if (branchVal.value === 2 && exc.includes(2)) {\n              if (exc.includes(4)) return lt\n              return cmp(branch, 4, ge, lt)\n            }\n            if (branchVal.value === 4 && exc.includes(4))\n              return lt\n          }\n        }\n        return n\n      default:\n        return n\n    }\n  })\n  return nodes\n}\n","import { ArtSetExclusion } from \"../../../../Database/Data/BuildsettingData\"\nimport { fillBuffer, reducePolynomial } from \"../../../../Formula/addedUtils\"\nimport { ExpandedPolynomial, expandPoly, toNumNode } from \"../../../../Formula/expandPoly\"\nimport { LinearForm, minMaxWeightVec, toLinearUpperBound } from \"../../../../Formula/linearUpperBound\"\nimport { precompute } from \"../../../../Formula/optimization\"\nimport { NumNode } from \"../../../../Formula/type\"\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\"\nimport { objectKeyMap, objectKeyValueMap, range } from \"../../../../Util/Util\"\nimport { ArtifactBuildDataVecDense, ArtifactsBySlot, ArtifactsBySlotVec, DynStat, filterArtsVec2, RequestFilter } from \"./common\"\n\nexport type UnionFilter = {\n  uType: true\n  filters: StrictDict<SlotKey, { kind: \"id\", ids: Set<string> }>[]\n} | (RequestFilter & { uType: false })\n\nexport type RequestFilter2 = {\n  // filter: StrictDict<SlotKey, { kind: \"id\", ids: Set<string> }>,\n  filterVec: StrictDict<SlotKey, number[]>,  // dict of list of indices (for some particular ArtifactsBySetVec)\n  lower: number[],  // length `k` list of lower bound stats\n  upper: number[],  // length `k` list of upper bound stats\n  minw: number[],   // length `l` list of minimum upper bound estimates\n  maxw: number[],   // length `l` list of maximum upper bound weights\n}\nexport type UnionFilter2 = RequestFilter2[]\nexport type ArtSetExclusionFull = Dict<Exclude<ArtifactSetKey, \"PrayersForDestiny\" | \"PrayersForIllumination\" | \"PrayersForWisdom\" | \"PrayersToSpringtime\"> | \"uniqueKey\", number[]>\n// export type SubProblem = SubProblemNC | SubProblemWC\nexport type SubProblem = SubProblemWC\nexport type SubProblemNC = {\n  cache: false,\n  optimizationTarget: ExpandedPolynomial,\n  constraints: { value: ExpandedPolynomial, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filters: UnionFilter2,\n  depth: number,\n}\nexport type SubProblemWC = {\n  cache: true,\n  optimizationTarget: ExpandedPolynomial,\n  constraints: { value: ExpandedPolynomial, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filters: UnionFilter2,\n  lin: LinearForm[],\n  // cachedCompute: CachedCompute,\n  depth: number,\n}\nexport type CachedCompute = {\n  maxEst: number[],\n  lin: LinearForm[],\n  lower: DynStat,\n  upper: DynStat\n}\n\nexport function countBuildsU(f: UnionFilter2): number {\n  return f.reduce((tot, { filterVec }) => tot + allSlotKeys.reduce((_count, slot) => _count * filterVec[slot].length, 1), 0)\n}\n\nexport function unionFilterUpperLower(f: UnionFilter2) {\n  const lower = [...f[0].lower]\n  const upper = [...f[0].upper]\n  const minw = [...f[0].minw]\n  const maxw = [...f[0].maxw]\n\n  for (let i = 1; i < f.length; i++) {\n    for (let j = 0; j < lower.length; j++) {\n      lower[j] = Math.min(lower[j], f[i].lower[j])\n      upper[j] = Math.max(upper[j], f[i].upper[j])\n    }\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], f[i].minw[j])\n      maxw[j] = Math.max(maxw[j], f[i].maxw[j])\n    }\n  }\n\n  return { lower, upper, minw, maxw }\n}\n\nexport function applyLinearForm(arts: ArtifactsBySlotVec, lin: LinearForm[]) {\n  const wixs: number[][] = []\n  const ws: number[][] = []\n  const baseC: number[] = []\n  lin.forEach(li => {\n    const ixs0: number[] = []\n    const w0: number[] = []\n    Object.entries(li.w).forEach(([k, w]) => {\n      ixs0.push(arts.keys.indexOf(k))\n      w0.push(w)\n    })\n    wixs.push(ixs0)\n    ws.push(w0)\n\n    baseC.push(ixs0.reduce((accum, ix, i) => accum + arts.base[ix] * w0[i], li.c))\n  })\n\n  arts.baseBuffer = baseC\n  allSlotKeys.forEach(slotKey => arts.values[slotKey].forEach(art =>\n    art.buffer = wixs.map((ixsi, i) => ixsi.reduce((accum, ix, j) => accum + art.values[ix] * ws[i][j], 0))\n  ))\n}\n\nexport function reduceSubProblem(arts: ArtifactsBySlotVec, threshold: number, subp: SubProblem): SubProblemWC | undefined {\n  const { optimizationTarget, constraints, artSetExclusion, depth } = subp\n  let { filters } = subp\n  let nodes = [...constraints.map(({ value }) => value), optimizationTarget]\n  const mins = constraints.map(({ min }) => min)\n\n  // 0. Check for never-feasible constraints\n  filters = filters.filter(({ maxw }) => {\n    if (mins.some((min, j) => maxw[j] < min)) return false\n    if (maxw[mins.length] < threshold) return false\n    return true\n  })\n  if (filters.length === 0) return undefined\n\n  // 0b. Calculate stat bounding box\n  const { lower, upper } = unionFilterUpperLower(filters)\n  const statsMin: DynStat = Object.fromEntries(arts.keys.map((k, i) => ([k, lower[i]])))\n  const statsMax: DynStat = Object.fromEntries(arts.keys.map((k, i) => ([k, upper[i]])))\n\n  nodes = reducePolynomial(nodes, statsMin, statsMax)\n\n  // 1. Check for always-feasible constraints.\n  const [compute, mapping, buffer] = precompute(constraints.map(({ value }) => toNumNode(value)), n => n.path[1])\n  fillBuffer(statsMin, mapping, buffer)\n  const result = compute()\n  const active = mins.map((m, i) => m > result[i])\n\n  const newOptTarget = nodes.pop()!\n  const newConstraints = nodes.map((value, i) => ({ value, min: mins[i] })).filter((_, i) => active[i])\n  const newMins = newConstraints.map(({ min }) => min)\n\n  // 2. Check for never-active and always-active ArtSetExcl constraints.\n  const newArtExcl = {} as ArtSetExclusionFull\n  for (const [setKey, exclude] of Object.entries(artSetExclusion)) {\n    if (setKey === 'uniqueKey') {\n      // TODO: Check and exclude rainbow bullshit.\n      newArtExcl[setKey] = exclude\n      const feasibleKeys = allArtifactSets.filter(setKey => statsMax[setKey] > 0)\n      let feasible4sets = 0\n      let feasible2sets = 0\n      feasibleKeys.forEach(k => {\n        let allowedCnts = range(statsMin[k], statsMax[k])\n        if (artSetExclusion[k])\n          allowedCnts = allowedCnts.filter(cnt => !artSetExclusion[k].includes(cnt))\n\n        if (allowedCnts.includes(4) || allowedCnts.includes(5)) feasible4sets++\n        if (allowedCnts.includes(2) || allowedCnts.includes(3)) feasible2sets++\n      })\n\n      if (exclude.includes(5) && feasible4sets === 0) {\n        if (feasible2sets === 0) return; // No feasible 4sets or 2sets along with rainbow5 excluded is never satisfiable\n        if (exclude.includes(3) && feasible2sets < 2) return; // No 4sets, rainbow5 excluded, rainbow3 excluded means we need at least 2 2sets\n      }\n      continue\n    }\n    const reducedExcl = exclude.filter(n => statsMin[setKey] <= n && n <= statsMax[setKey])        // Cut away never-active\n    if (reducedExcl.includes(statsMin[setKey]) && reducedExcl.includes(statsMax[setKey])) return;  // Always active.\n    if (reducedExcl.length > 0) newArtExcl[setKey] = reducedExcl\n  }\n\n  // 3. Estimate Upper Bounds and re-check for never-feasible constraints\n  let f = [...newConstraints.map(({ value }) => value), newOptTarget]\n  const lin = f.map(fi => toLinearUpperBound(fi, statsMin, statsMax))\n  applyLinearForm(arts, lin)\n  const newFilters = filters\n    .map(filter => {\n      const { filterVec, lower, upper } = filter\n      const a = filterArtsVec2(arts, filter.filterVec)  // CANDIDATE for making this more efficient\n      const minww = [...a.baseBuffer]\n      const maxww = [...a.baseBuffer]\n      allSlotKeys.forEach(slotKey => {\n        const { minw, maxw } = slotUpperLowerVecW(a.values[slotKey])\n        for (let j = 0; j < minww.length; j++) {\n          minww[j] += minw[j]\n          maxww[j] += maxw[j]\n        }\n      })\n      return {\n        filterVec, lower, upper,\n        minw: minww, maxw: maxww,\n      }\n    })\n    .filter(({ maxw }) => {\n      if (newMins.some((min, j) => maxw[j] < min)) return false\n      if (maxw[mins.length] < threshold) return false\n      return true\n    })\n\n  return {\n    cache: true,\n    optimizationTarget: newOptTarget,\n    constraints: newConstraints,\n    artSetExclusion: newArtExcl,\n\n    depth, lin, filters: newFilters\n  }\n}\n\nexport function toArtifactBySlotVec(arts: ArtifactsBySlot): ArtifactsBySlotVec {\n  const allKeys = new Set(Object.keys(arts.base))\n  Object.values(arts.values).forEach(slotArts => {\n    slotArts.forEach(art => {\n      if (art.set) allKeys.add(art.set)\n      Object.keys(art.values).forEach(k => allKeys.add(k))\n    })\n  })\n\n  const allKeysList = [...allKeys]\n  const keys = [...allKeysList.filter(k => !(allArtifactSets as readonly string[]).includes(k)), ...allKeysList.filter(k => (allArtifactSets as readonly string[]).includes(k))]\n\n  return {\n    keys, baseBuffer: [],\n    base: keys.map(k => arts.base[k] ?? 0),\n    values: {\n      flower: arts.values.flower.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      plume: arts.values.plume.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      sands: arts.values.sands.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      goblet: arts.values.goblet.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n      circlet: arts.values.circlet.map(({ id, set, values }) => ({ id, set, values: keys.map(k => values[k] ?? (k === set ? 1 : 0)), buffer: [] })),\n    }\n  }\n}\n\ntype ProblemSetup = {\n  optimizationTargetNode: NumNode,\n  nodes: NumNode[],\n  minimum: number[],\n  artSetExclusion: ArtSetExclusion\n}\nexport function problemSetup(arts: ArtifactsBySlotVec, { optimizationTargetNode, nodes, minimum, artSetExclusion }: ProblemSetup): SubProblemWC {\n  const artSetExclFull = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n    if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n    return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n  })\n\n  const constraintsEP = nodes\n    .map((value, i) => ({ value: expandPoly(value), min: minimum[i] }))\n    .filter(x => x.min > -Infinity)\n  const opttargetEP = expandPoly(optimizationTargetNode)\n\n  const { lower, upper } = statsUpperLowerVec(arts)\n  const statsMin = Object.fromEntries(arts.keys.map((k, i) => [k, lower[i]]))\n  const statsMax = Object.fromEntries(arts.keys.map((k, i) => [k, upper[i]]))\n  let f = [...constraintsEP.map(({ value }) => value), opttargetEP]\n  const lin = f.map(fi => toLinearUpperBound(fi, statsMin, statsMax))\n  const minMaxEst = lin.map(li => minMaxWeightVec(arts, li))\n\n  console.log('-----------------------------------------------------------------------')\n  console.log('lin', lin)\n  console.log('-----------------------------------------------------------------------')\n\n  const filterVec = objectKeyMap(allSlotKeys, slotKey => {\n    return arts.values[slotKey].map((v, i) => i)\n  })\n\n  const initialProblem: SubProblemWC = {\n    cache: true,\n    optimizationTarget: opttargetEP,\n    constraints: constraintsEP,\n    artSetExclusion: artSetExclFull,\n\n    filters: [{\n      filterVec, lower, upper,\n      maxw: minMaxEst.map(({ maxw }) => maxw),\n      minw: minMaxEst.map(({ minw }) => minw),\n    }],\n    depth: 0,\n    lin,\n  }\n  const initialReducedProblem = reduceSubProblem(arts, -Infinity, initialProblem)\n  console.log(initialReducedProblem)\n  if (initialReducedProblem === undefined)\n    return initialProblem\n  return initialReducedProblem\n}\n\nexport function slotUpperLowerVec(arts: ArtifactBuildDataVecDense[]) {\n  const lower = [...arts[0].values]\n  const upper = [...arts[0].values]\n  const minw = [...arts[0].buffer]\n  const maxw = [...arts[0].buffer]\n  for (let i = 1; i < arts.length; i++) {\n    for (let j = 0; j < lower.length; j++) {\n      lower[j] = Math.min(lower[j], arts[i].values[j])\n      upper[j] = Math.max(upper[j], arts[i].values[j])\n    }\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], arts[i].buffer[j])\n      maxw[j] = Math.max(maxw[j], arts[i].buffer[j])\n    }\n  }\n  return { lower, upper, minw, maxw }\n}\nexport function slotUpperLowerVecW(arts: ArtifactBuildDataVecDense[]) {\n  const minw = [...arts[0].buffer]\n  const maxw = [...arts[0].buffer]\n  for (let i = 1; i < arts.length; i++) {\n    for (let j = 0; j < minw.length; j++) {\n      minw[j] = Math.min(minw[j], arts[i].buffer[j])\n      maxw[j] = Math.max(maxw[j], arts[i].buffer[j])\n    }\n  }\n  return { minw, maxw }\n}\nexport function statsUpperLowerVec(a: ArtifactsBySlotVec) {\n  const lower = [...a.base]\n  const upper = [...a.base]\n  const minw = [...a.baseBuffer]\n  const maxw = [...a.baseBuffer]\n  Object.values(a.values).forEach(slotArts => {\n    const slotUL = slotUpperLowerVec(slotArts)\n    for (let i = 0; i < lower.length; i++) {\n      lower[i] += slotUL.lower[i]\n      upper[i] += slotUL.upper[i]\n    }\n    for (let i = 0; i < minw.length; i++) {\n      minw[i] += slotUL.minw[i]\n      maxw[i] += slotUL.maxw[i]\n    }\n  })\n  return { lower, upper, minw, maxw }\n}\nexport function statsUpperLowerVecW(a: ArtifactsBySlotVec) {\n  const minw = [...a.baseBuffer]\n  const maxw = [...a.baseBuffer]\n  Object.values(a.values).forEach(slotArts => {\n    const slotUL = slotUpperLowerVecW(slotArts)\n    for (let i = 0; i < minw.length; i++) {\n      minw[i] += slotUL.minw[i]\n      maxw[i] += slotUL.maxw[i]\n    }\n  })\n  return { minw, maxw }\n}\n","import { reduceFormula, statsUpperLower } from '../../../../Formula/addedUtils';\nimport { optimize, precompute } from '../../../../Formula/optimization';\nimport type { NumNode } from '../../../../Formula/type';\nimport type { InterimResult, Setup } from './BackgroundWorker';\nimport { ArtifactsBySlot, ArtifactsBySlotVec, Build, countBuilds, DynStat, filterArts, filterArts2, mergePlot, PlotData, reaffine, RequestFilter } from './common';\nimport { ArtSetExclusionFull, countBuildsU, SubProblem, unionFilterUpperLower } from './subproblemUtil';\n\nfunction checkArtSetExclusion(setKeyCounts: DynStat, excl: ArtSetExclusionFull) {\n  let pass = Object.entries(setKeyCounts).every(([setKey, num]) => {\n    if (!excl[setKey]) return true\n    return !excl[setKey].includes(num)\n  })\n  if (!pass) return false\n\n  if (!excl['uniqueKey']) return true\n\n  const nRainbow = Object.values(setKeyCounts).reduce((a, b) => a + (b % 2), 0)\n  return !excl['uniqueKey'].includes(nRainbow)\n}\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] = []\n  plotData: PlotData | undefined\n  plotBase: NumNode | undefined\n  threshold: number = -Infinity\n  maxBuilds: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n  nodes: NumNode[]\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, artsVec, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.artsVec = artsVec\n    this.min = filters.map(x => x.min)\n    this.maxBuilds = maxBuilds\n    this.callback = callback\n    this.nodes = filters.map(x => x.value)\n    this.nodes.push(optimizationTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.plotBase = plotBase\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, _ => false)\n  }\n\n  computeU(newThreshold: number, subproblem: SubProblem) {\n    if (this.threshold < newThreshold) this.threshold = newThreshold\n    const { filters, artSetExclusion, depth } = subproblem\n    const self = this // `this` in nested functions means different things\n\n    const totalCount = countBuildsU(filters)\n    const { lower, upper, maxw } = unionFilterUpperLower(filters)\n    if (maxw[maxw.length - 1] < this.threshold) {\n      this.interimReport({ tested: 0, failed: 0, skipped: totalCount })\n      return\n    }\n\n    let nodes = [...this.nodes]\n    let min = [...this.min]\n    if (this.plotBase !== undefined) nodes.push(this.plotBase);\n    // let { statsMin, statsMax } = unionFilterUpperLower(this.arts, filter)\n    const statsMin: DynStat = Object.fromEntries(this.artsVec.keys.map((k, i) => ([k, lower[i]])))\n    const statsMax: DynStat = Object.fromEntries(this.artsVec.keys.map((k, i) => ([k, upper[i]])))\n    nodes = reduceFormula(nodes, statsMin, statsMax)\n    const reaff = reaffine(nodes, this.arts)\n    nodes = reaff.nodes\n    const preArts = reaff.arts\n\n    const [compute, mapping, buffer] = precompute(nodes, f => f.path[1])\n    const unionArts = filters.map(filter => {\n      const a = filterArts2(reaff.arts, filter.filterVec)\n      return Object.values(a.values)\n        .sort((a, b) => a.length - b.length)\n        .map(arts => arts.map(art => ({\n          id: art.id, set: art.set,\n          values: Object.entries(art.values)\n            .map(([key, value]) => ({ key: mapping[key]!, value, cache: 0 }))\n            .filter(({ key, value }) => key !== undefined && value !== 0)\n        })))\n    })\n\n    let count = { tested: 0, failed: 0, skipped: 0 }\n\n    let ids: string[] = []\n    function permute(i: number, j: number, setKeyCounts: DynStat) {\n      if (j < 0) {\n        const result = compute()\n        if (min.some((m, i) => m > result[i]) || !checkArtSetExclusion(setKeyCounts, artSetExclusion)) {\n          count.failed++\n          return\n        }\n\n        const value = result[min.length], { builds, buildValues, plotData, threshold } = self\n        let build: Build | undefined\n        if (value >= threshold) {\n          build = { value, artifactIds: [...ids] }\n          builds.push(build)\n          buildValues.push(value)\n        }\n        if (plotData) {\n          const x = result[min.length + 1]\n          if (!plotData[x] || plotData[x]!.value < value) {\n            if (!build) build = { value, artifactIds: [...ids] }\n            build.plot = x\n            plotData[x] = build\n          }\n        }\n        return\n      }\n\n      unionArts[i][j].forEach(art => {\n        ids[j] = art.id\n\n        for (const curr of art.values) {\n          const { key, value } = curr\n          curr.cache = buffer[key]\n          buffer[key] += value\n        }\n\n        setKeyCounts[art.set ?? ''] = 1 + (setKeyCounts[art.set ?? ''] ?? 0)\n        permute(i, j - 1, setKeyCounts)\n        setKeyCounts[art.set ?? ''] -= 1\n        if (setKeyCounts[art.set ?? ''] === 0) delete setKeyCounts[art.set ?? '']\n\n        for (const { key, cache } of art.values) buffer[key] = cache\n      })\n\n      if (j === 0) count.tested += unionArts[i][j].length\n    }\n\n    // 4. Set up buffer with `preArts.base`\n    for (const [key, value] of Object.entries(preArts.base)) {\n      const i = mapping[key]\n      if (i !== undefined) buffer[i] = value\n    }\n\n    // 5. permute all combinations\n    for (let i = 0; i < unionArts.length; i++) {\n      ids = Array(unionArts[0].length).fill(\"\")  // isnt this just Array(5)?\n      permute(i, unionArts[i].length - 1, {})\n    }\n\n    this.interimReport(count)\n    return this.threshold\n  }\n\n  refresh(force: boolean): void {\n    const { maxBuilds } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    // I need frequent updating of threshold\n    if (true || this.builds.length >= 100000 || force) {\n      this.builds = this.builds\n        .sort((a, b) => b.value - a.value)\n        .slice(0, maxBuilds)\n    }\n  }\n  interimReport = (count: { tested: number, failed: number, skipped: number }) => {\n    this.refresh(false)\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\n    this.buildValues = []\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { ArtSetExclusion } from '../../../../Database/Data/BuildsettingData'\nimport { NumNode } from '../../../../Formula/type'\nimport { assertUnreachable } from '../../../../Util/Util'\nimport { ArtifactsBySlot, ArtifactsBySlotVec, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData } from \"./common\"\nimport { ComputeWorker } from \"./ComputeWorker\"\nimport { SplitWorker } from \"./SplitWorker\"\nimport { SubProblem } from './subproblemUtil'\n\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nonmessage = ({ data }: { data: WorkerCommand }) => {\n  const command = data.command\n  let result: WorkerResult\n  switch (command) {\n    case \"setup\":\n      id = data.id\n      const callback = (interim: InterimResult) => postMessage({ id, ...interim })\n      splitWorker = new SplitWorker(data, callback)\n      computeWorker = new ComputeWorker(data, callback)\n      result = { command: \"iterate\" }\n      break\n    case \"split\":\n      result = { command: \"split\", subproblems: splitWorker.split(data), ready: splitWorker.subproblems.length === 0 }\n      // console.log(id, splitWorker.subproblems)\n      break\n    case \"iterate\":\n      const { threshold, subproblem } = data\n      computeWorker.computeU(threshold, subproblem)\n      result = { command: \"iterate\" }\n      break\n    case \"finalize\":\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      result = { command: \"finalize\", builds, plotData }\n      break\n    case \"count\":\n      {\n        const { exclusion } = data, arts = computeWorker.arts\n        const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\n        let counts = data.arts.map(_ => 0)\n        for (const perm of setPerm)\n          data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\n        result = { command: \"count\", counts }\n        break\n      }\n    case \"share\":\n      const oo = splitWorker.popOne()\n      result = { command: 'share', subproblem: oo, sender: data.sender }\n      break\n    default: assertUnreachable(command)\n  }\n  postMessage({ id, ...result });\n}\n\n\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Share | Count\nexport type WorkerResult = InterimResult | SplitResult | IterateResult | FinalizeResult | ShareResult | CountResult\n\nexport interface Setup {\n  command: \"setup\"\n\n  id: number\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n\n  optimizationTarget: NumNode\n  filters: { value: NumNode, min: number }[]\n  artSetExclusion: ArtSetExclusion\n  plotBase: NumNode | undefined,\n  maxBuilds: number\n}\nexport interface Split {\n  command: \"split\"\n  threshold: number\n  minCount: number\n  maxIter: number\n\n  subproblem?: SubProblem\n}\nexport interface Iterate {\n  command: \"iterate\"\n  threshold: number\n\n  subproblem: SubProblem\n}\nexport interface Finalize {\n  command: \"finalize\"\n}\nexport interface Share {\n  command: \"share\"\n  sender: number\n}\nexport interface Count {\n  command: \"count\"\n  arts: ArtifactsBySlot[]\n  exclusion: ArtSetExclusion\n}\n\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface IterateResult {\n  command: \"iterate\"\n}\nexport interface SplitResult {\n  command: \"split\"\n  ready: boolean\n  subproblems: SubProblem[]\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface ShareResult {\n  command: \"share\"\n  subproblem?: SubProblem\n  sender: number\n}\nexport interface CountResult {\n  command: \"count\"\n  counts: number[]\n}\n","import type { NumNode } from '../../../../Formula/type';\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey, SlotKey } from '../../../../Types/consts';\nimport type { InterimResult, Setup, Split } from './BackgroundWorker';\nimport { ArtifactsBySlot, ArtifactsBySlotVec, filterArtsVec, filterArtsVec2 } from './common';\nimport { cartesian, objectKeyMap, objectKeyValueMap, partition } from '../../../../Util/Util';\nimport { LinearForm } from '../../../../Formula/linearUpperBound';\nimport { applyLinearForm, countBuildsU, reduceSubProblem, RequestFilter2, slotUpperLowerVec, slotUpperLowerVecW, statsUpperLowerVec, SubProblem, SubProblemWC, UnionFilter2, unionFilterUpperLower } from './subproblemUtil';\n\nexport class SplitWorker {\n  min: number[]\n\n  arts: ArtifactsBySlot\n  artsVec: ArtifactsBySlotVec\n  nodes: NumNode[]\n  artSet: Dict<ArtifactSetKey | 'uniqueKey', number[]>\n\n  subproblems: { count: number, upperBound: number, subproblem: SubProblem }[] = []\n\n  splitcounter: number = 0\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, artsVec, optimizationTarget, filters, artSetExclusion }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.artsVec = artsVec  // buffer is volatile, shared memory problems?\n    this.min = filters.map(x => x.min)\n    this.nodes = filters.map(x => x.value)\n    this.callback = callback\n\n    this.min.push(-Infinity)\n    this.nodes.push(optimizationTarget)\n\n    this.artSet = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n      if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n      return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n    })\n  }\n\n  addSubProblem(subproblem: SubProblem) {\n    const count = countBuildsU(subproblem.filters)\n    if (count === 0) return\n    const maxEst = Math.max(...subproblem.filters.map(({ maxw }) => maxw[maxw.length - 1]))\n    this.subproblems.push({ count, upperBound: maxEst, subproblem })\n  }\n\n  /**\n   * Iteratively splits the subproblem (depth-first) into smaller chunks until it is small enough,\n   *   as determined by `minCount`. Repeat up to `maxIter` times before returning control to the main thread.\n   * @param minCount\n   * @param maxIter\n   * @returns Either ONE [subproblem] of size `minCount` or ZERO [] subproblems.\n   */\n  split({ threshold, minCount, maxIter, subproblem }: Split): SubProblem[] {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n    const initialProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n\n    let n = 0\n    while (n < maxIter && this.subproblems.length) {\n      n += 1\n      const { count, subproblem } = this.subproblems.pop()!\n      if (count <= minCount) {\n        const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0) + count\n        this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n        return [subproblem]\n      }\n\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n      // console.log('work queue', this.subproblems)\n    }\n    const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n    this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n    return []\n  }\n\n  popOne() {\n    // Yield largest subproblem (requests => level-order / prio queue order)\n    if (this.subproblems.length === 0) return undefined\n    let ret = { i: -1, heur: -Infinity }\n    for (let i = 1; i < this.subproblems.length; i++) {\n      const { upperBound: heur } = this.subproblems[i]\n      if (heur > ret.heur) ret = { i, heur }\n    }\n    if (ret.i < 0) return undefined\n    return this.subproblems.splice(ret.i, 1)[0].subproblem\n  }\n\n  /**\n   * splitBNB takes a SubProblem and tries to perform Branch and Bound (BnB) pruning to solve for the\n   *   optimal damage value. As the name states, there are two main phases: Branching and Bounding.\n   *   The bounding is handled by an `estimateMaximum()` function call, and the branching is done by `pickBranch()`.\n   *\n   * @param threshold  Objective function lower bound threshold\n   * @param subproblem The subproblem to split\n   * @returns An array of up to 32 splits of the input subproblem.\n   */\n  splitBNB(threshold: number, subproblem: SubProblem) {\n    // 1. check threshold\n    subproblem.filters = subproblem.filters.filter(({ maxw }) => maxw[maxw.length - 1] > threshold)\n    if (subproblem.filters.length === 0) return []\n\n    // 2. Pick branching method\n    let branches0: SubProblem[] = []\n    const maxFilters = 50\n    if (subproblem.filters.length > maxFilters) {\n      // console.log('large problem detected', subproblem.filters.length)\n      // too many filters; just split them somehow I guess?\n      const filts = subproblem.filters.sort((a, b) => a.maxw[a.maxw.length - 1] - b.maxw[b.maxw.length - 1])\n      const nsplit = Math.ceil(filts.length / maxFilters)\n      const newFilts = partition(filts, nsplit)\n\n      branches0 = newFilts.map(filt => ({\n        ...subproblem,\n        filters: filt\n      }))\n    }\n    else {\n      const origBuilds = countBuildsU(subproblem.filters)\n      const pruned = performSingletonPrune(this.artsVec, threshold, subproblem)\n      const newBuilds = countBuildsU(subproblem.filters)\n      if (pruned && countBuildsU(subproblem.filters) === 0) return []\n      if (pruned && (origBuilds - newBuilds) > .3 * origBuilds) {\n        // if more than a third got pruned due to buillshit\n        branches0 = [subproblem]\n      }\n      else {\n        branches0 = this.makeBranches(threshold, subproblem)\n      }\n    }\n\n    // 3. Perform branching. Check bounding during the branching phase as well.\n    let branches = [] as { numBuilds: number, heur: number, subproblem: SubProblemWC }[]\n    branches0.forEach(branch => {\n      let numBuilds = countBuildsU(branch.filters)\n      if (numBuilds === 0) return;\n\n      let sub2 = reduceSubProblem(this.artsVec, threshold, branch)\n      if (sub2 === undefined) return;\n      sub2.depth += 1\n\n      const me = Math.max(...sub2.filters.map(({ maxw }) => maxw[maxw.length - 1]))\n      const li = sub2.lin\n      branches.push({\n        numBuilds, heur: me - li[li.length - 1].err,\n        subproblem: sub2\n      })\n    })\n    // branches.sort((a, b) => a.heur - b.heur)  // Alternative: sort by increasing maxEst - err\n    branches.sort((a, b) => b.numBuilds - a.numBuilds)  // Alternative: sort by decreasing num builds\n\n    // console.log('adding branches', branches)\n    return branches.map(({ subproblem }) => subproblem)\n  }\n\n  makeBranches(threshold: number, subproblem: SubProblemWC): SubProblemWC[] {\n    const { constraints, lin, artSetExclusion, filters } = subproblem\n    // 1a. Get min & max upper bound estimates for objective & constraints\n    const { minw, maxw, lower, upper } = unionFilterUpperLower(filters)\n\n    // console.log('splitting info', { nsp: this.splitcounter, nfilt: filters.length, cnt: countBuildsU(filters) }, { max: maxw[maxw.length - 1], min: minw[minw.length - 1] })\n    this.splitcounter += 1\n\n    // 1b. Take subset of relevant artifacts\n    const allIDs = {\n      flower: { kind: 'id', ids: new Set<string>() },\n      plume: { kind: 'id', ids: new Set<string>() },\n      sands: { kind: 'id', ids: new Set<string>() },\n      goblet: { kind: 'id', ids: new Set<string>() },\n      circlet: { kind: 'id', ids: new Set<string>() },\n    } as StrictDict<SlotKey, { kind: 'id', ids: Set<string> }>\n    filters.forEach(filt => {\n      allSlotKeys.forEach(slotKey => {\n        const setptr = allIDs[slotKey].ids\n        filt.filterVec[slotKey].forEach(ix => setptr.add(this.arts.values[slotKey][ix].id))\n      })\n    })\n    const aarts = filterArtsVec(this.artsVec, allIDs)\n\n    const thr = [...constraints.map(({ min }) => min), threshold]\n    const decisionHeur = thr.map((th, i) => (th - minw[i]) / (maxw[i] - minw[i]))\n    let argMax = -1\n    for (let i = decisionHeur.length - 1; i >= 0; i--) {\n      if (Object.keys(lin[i].w).length === 0) continue  // don't branch on an empty `lin`\n      if (argMax < 0) argMax = i                        // by default, pick optTarget to branch on\n      if (decisionHeur[argMax] < .5) continue           // Discard constraints with low probability of violation\n      if (decisionHeur[i] > decisionHeur[argMax]) argMax = i\n    }\n\n    // TODO: figure out a heuristic for when to branch on artSetExclusion instead. Currently doing so\n    //  when no other options available.\n    let branches: UnionFilter2[];\n    if (argMax < 0) {\n      // Split on set exclusion by just picking the most popular set key.\n      const feasibleKeys = allArtifactSets.filter(setKey => upper[setKey] > 0)\n\n      var branchOn = { k: undefined as ArtifactSetKey | undefined, cnt: -1 }\n      feasibleKeys.forEach(k => {\n        let cnt = upper[k]\n        if (artSetExclusion[k] && artSetExclusion[k].includes(cnt))\n          cnt = Math.min(...artSetExclusion[k]) - 1\n\n        if (cnt > branchOn.cnt) branchOn = { k, cnt }\n      })\n\n      const k = this.artsVec.keys.indexOf(branchOn.k!)\n      applyLinearForm(this.artsVec, lin)\n      branches = branchOnSetKey(k, this.artsVec, filters, lin)\n    }\n    else {\n      let linToConsider = lin[argMax]\n      let keysToConsider = Object.keys(linToConsider.w)\n\n      let shatterOn = { k: '', heur: -1 }\n      keysToConsider.forEach(k => {\n        const kix = this.artsVec.keys.indexOf(k)\n        const postShatterRangeReduction = Object.entries(aarts.values).reduce((rangeReduc, [slot, arts]) => {\n          const vals = arts.map(a => a.values[kix])\n          const minv = Math.min(...vals)\n          const maxv = Math.max(...vals)\n          if (minv === maxv) return rangeReduc\n\n          const branchVal = (minv + maxv) / 2\n          const glb = Math.max(...vals.filter(v => v <= branchVal))\n          const lub = Math.min(...vals.filter(v => v > branchVal))\n          return rangeReduc + Math.min(maxv - glb, lub - minv)\n        }, 0)\n        const heur = linToConsider.w[k] * postShatterRangeReduction * ((allArtifactSets as readonly string[]).includes(k) ? 5 : 1)\n        if (heur > shatterOn.heur) shatterOn = { k, heur }\n      })\n\n      if (shatterOn.k === '') {\n        console.log('===================== SHATTER BROKE ====================', lin, aarts)\n        throw Error('Shatter broke...')\n      }\n      // console.log('shatterOn', shatterOn)\n\n      const k = this.artsVec.keys.indexOf(shatterOn.k)\n      const targetBranchVal = (lower[k] + upper[k]) / 2\n\n      applyLinearForm(this.artsVec, lin)\n      if ((allArtifactSets as readonly string[]).includes(shatterOn.k)) {\n        branches = branchOnSetKey(k, this.artsVec, filters, lin)\n      }\n      else {\n        branches = branchOnValue(k, targetBranchVal, this.artsVec, filters, lin)\n      }\n    }\n    return branches.map(filters => ({ ...subproblem, filters, cache: true }))\n  }\n}\n\nfunction branchOnValue(k: number, target: number, arts: ArtifactsBySlotVec, filts: UnionFilter2, lin: LinearForm[]) {\n  let left: UnionFilter2 = []\n  let right: UnionFilter2 = []\n  // let allSeparate: UnionFilter2[] = []\n  // const allSplits: RequestFilter2[] = []\n  filts.forEach(filt => {\n    const { filterVec } = filt\n    const branchSplitsIx = splitToTargetIx(arts, k, target, filt)  // returns array of 1-2 splits per slot\n\n    const branchArts = objectKeyMap(allSlotKeys, slotKey => branchSplitsIx[slotKey]\n      .filter(ixs => ixs.length > 0)\n      .map(ixs => {\n        // const slotArts = a.values[slotKey].filter(({ id }) => ids.includes(id))\n        const slotArts = filterVec[slotKey].map(ix => arts.values[slotKey][ix])\n        return { slotArts, ixs, ...slotUpperLowerVec(slotArts) }\n      }))\n\n    cartesian(branchArts.flower, branchArts.plume, branchArts.sands, branchArts.goblet, branchArts.circlet)\n      .forEach(slots => {\n        const [flower, plume, sands, goblet, circlet] = slots\n        const lower = flower.lower.map((_, i) => slots.reduce((tot, { lower }) => tot + lower[i], arts.base[i]))// np.sum(-, axis=1)\n        const upper = flower.upper.map((_, i) => slots.reduce((tot, { upper }) => tot + upper[i], arts.base[i]))\n        const maxw = flower.maxw.map((_, i) => slots.reduce((tot, { maxw }) => tot + maxw[i], arts.baseBuffer[i]))\n        const minw = flower.minw.map((_, i) => slots.reduce((tot, { minw }) => tot + minw[i], arts.baseBuffer[i]))\n\n        const toPush: RequestFilter2 = {\n          filterVec: {\n            flower: flower.ixs,\n            plume: plume.ixs,\n            sands: sands.ixs,\n            goblet: goblet.ixs,\n            circlet: circlet.ixs,\n          },\n          lower, upper, minw, maxw\n        }\n\n        if (upper[k] - target > target - lower[k]) {\n          left.push(toPush)\n        }\n        else {\n          right.push(toPush)\n        }\n      })\n  })\n\n  return [left, right]\n}\n\nfunction branchOnSetKey(k: number, arts: ArtifactsBySlotVec, filts: UnionFilter2, lin: LinearForm[]): UnionFilter2[] {\n  function format(slotKey: SlotKey, set: 0 | 1, ixVec: number[]) {\n    const arts2 = ixVec.map(ix => arts.values[slotKey][ix])\n    return { set, ...slotUpperLowerVec(arts2), ixs: ixVec }\n  }\n\n  let left: UnionFilter2 = []\n  let middle: UnionFilter2 = []\n  let right: UnionFilter2 = []\n  filts.forEach(({ filterVec }) => {\n    const branchArts = objectKeyMap(allSlotKeys, slotKey => {\n      const slotArts = arts.values[slotKey]\n      const ixVec1 = filterVec[slotKey].filter(artIx => slotArts[artIx].values[k] === 0)\n      const ixVec2 = filterVec[slotKey].filter(artIx => slotArts[artIx].values[k] === 1)\n\n      const ret: ReturnType<typeof format>[] = []\n      if (ixVec1.length > 0) ret.push(format(slotKey, 0, ixVec1))\n      if (ixVec2.length > 0) ret.push(format(slotKey, 1, ixVec2))\n      return ret\n    })\n\n    cartesian(branchArts.flower, branchArts.plume, branchArts.sands, branchArts.goblet, branchArts.circlet)\n      .forEach(slots => {\n        const [flower, plume, sands, goblet, circlet] = slots\n        const lower = flower.lower.map((_, i) => slots.reduce((tot, { lower }) => tot + lower[i], arts.base[i]))  // np.sum(-, axis=1)\n        const upper = flower.upper.map((_, i) => slots.reduce((tot, { upper }) => tot + upper[i], arts.base[i]))\n        const maxw = flower.maxw.map((_, i) => slots.reduce((tot, { maxw }) => tot + maxw[i], arts.baseBuffer[i]))\n        const minw = flower.minw.map((_, i) => slots.reduce((tot, { minw }) => tot + minw[i], arts.baseBuffer[i]))\n\n        const toPush: RequestFilter2 = {\n          filterVec: {\n            flower: flower.ixs,\n            plume: plume.ixs,\n            sands: sands.ixs,\n            goblet: goblet.ixs,\n            circlet: circlet.ixs,\n          },\n          lower, upper, minw, maxw\n        }\n\n        const setCount = slots.reduce((setCount, { set }) => setCount + set, 0)\n        switch (setCount) {\n          case 0: case 1:\n            left.push(toPush)\n            break\n          case 2: case 3:\n            middle.push(toPush)\n            break\n          case 4: case 5:\n            right.push(toPush)\n            break\n          default:\n            throw Error('Unreachable')\n        }\n      })\n  })\n  return [left, middle, right]\n}\n\nfunction splitToTargetIx(a: ArtifactsBySlotVec, k: number, targ: number, { filterVec }: RequestFilter2) {\n  const n = 5\n  targ = targ - a.base[k]\n\n  // 1. Convert artifacts to simpler form & sort them on each slot\n  const ababa0 = allSlotKeys.map(slotKey => filterVec[slotKey]\n    .map(ix => ({ ix, v: a.values[slotKey][ix].values[k] }))\n    .sort(({ v: v1 }, { v: v2 }) => v1 - v2))\n  // 1b. Collapse same-values\n  const ababa = ababa0.map(arts => arts.map(({ ix, v }) => ({ ixs: [ix], v })))\n  for (let i = 0; i < ababa.length; i += 1) {\n    const aa = ababa[i]\n    for (let j = aa.length - 1; j > 0; j -= 1) {\n      if (aa[j].v == aa[j - 1].v) {\n        aa[j - 1].ixs.push(...aa[j].ixs)\n        aa.splice(j, 1)\n      }\n    }\n  }\n\n  // 2. Find a feasible solution\n  const x0 = ababa.map(arts => arts[0].v)\n  const v = ababa.map(arts => arts[arts.length - 1].v - arts[0].v)\n  if (v.every(vi => vi === 0)) v.fill(1)\n  const coeff = (targ - x0.reduce((a, b) => a + b)) / v.reduce((a, b) => a + b)\n\n  let feas = [] as number[]\n  ababa.forEach((arts, si) => {\n    let z = -1\n    for (let i = 0; i < arts.length; i++) {\n      // This can be replaced with binary search.\n      // if v[si] === 0 theres an ambiguity...\n      if (arts[i].v >= x0[si] + coeff * v[si]) {\n        z = i\n        break\n      }\n    }\n    if (z < 0) z = arts.length\n    feas.push(z)\n  })\n\n  // 3a. Convenience functions for checking correctness and scoring breaking schemes\n  function checkFeasible(breaks: number[]) {\n    let glb = 0, lub = 0\n    for (let i = 0; i < n; i++) {\n      const b = breaks[i]\n      glb += ababa[i][b - 1]?.v ?? -Infinity\n      lub += ababa[i][b]?.v ?? Infinity\n    }\n    return glb - targ <= 1e-6 && targ - lub <= 1e-6  // numerical silliness\n  }\n  function score(breaks: number[]) {\n    return breaks.reduce((p, bi) => p * bi, 1) + breaks.reduce((p, bi, i) => p * (ababa[i].length - bi), 1)\n  }\n\n  // 3b. Verify the feasible solution actually works\n  if (!checkFeasible(feas)) {\n    console.log('feas', feas, checkFeasible(feas), score(feas))\n    console.log({ x0, v, coeff, targ })\n    console.log(ababa)\n    throw Error('hmmm feas not working')\n  }\n\n  // 4. Greedily take 1-step or 2-steps until we cannot improve further.\n  //    TODO: more intelligent way to search.\n  const onesteps: readonly number[][] = [[0, 1], [0, -1], [1, 1], [1, -1], [2, 1], [2, -1], [3, 1], [3, -1], [4, 1], [4, -1]]\n  const twosteps: readonly number[][] = [[0, 1, -1, -1], [0, 1, -1, 1], [0, 1, 1, -1], [0, 1, 1, 1], [0, 2, -1, -1], [0, 2, -1, 1], [0, 2, 1, -1], [0, 2, 1, 1], [0, 3, -1, -1], [0, 3, -1, 1], [0, 3, 1, -1], [0, 3, 1, 1], [0, 4, -1, -1], [0, 4, -1, 1], [0, 4, 1, -1], [0, 4, 1, 1], [1, 2, -1, -1], [1, 2, -1, 1], [1, 2, 1, -1], [1, 2, 1, 1], [1, 3, -1, -1], [1, 3, -1, 1], [1, 3, 1, -1], [1, 3, 1, 1], [1, 4, -1, -1], [1, 4, -1, 1], [1, 4, 1, -1], [1, 4, 1, 1], [2, 3, -1, -1], [2, 3, -1, 1], [2, 3, 1, -1], [2, 3, 1, 1], [2, 4, -1, -1], [2, 4, -1, 1], [2, 4, 1, -1], [2, 4, 1, 1], [3, 4, -1, -1], [3, 4, -1, 1], [3, 4, 1, -1], [3, 4, 1, 1]]\n  while (true) {  // This must terminate within O(ababa[i].length) steps\n    let greedyStep: { score: number, next?: number[] } = { score: score(feas) }\n    onesteps.forEach(([i, di]) => {\n      let breaks = [...feas]\n      breaks[i] += di\n      if (breaks[i] < 0 || breaks[i] >= ababa[i].length) return\n      if (!checkFeasible(breaks)) return\n      const score = breaks.reduce((pr, b) => pr * b, 1) + breaks.reduce((pr, b, i) => pr * (ababa[i].length - b), 1)\n      if (score > greedyStep.score) greedyStep = { score, next: breaks }\n    })\n    twosteps.forEach(([i, j, di, dj]) => {\n      let breaks = [...feas]\n      breaks[i] += di\n      breaks[j] += dj\n      if (breaks[i] < 0 || breaks[i] >= ababa[i].length) return\n      if (breaks[j] < 0 || breaks[j] >= ababa[j].length) return\n      if (!checkFeasible(breaks)) return\n      const score = breaks.reduce((pr, b) => pr * b, 1) + breaks.reduce((pr, b, i) => pr * (ababa[i].length - b), 1)\n      if (score > greedyStep.score) greedyStep = { score, next: breaks }\n    })\n\n    if (greedyStep.next === undefined) break\n    feas = greedyStep.next\n  }\n\n  return objectKeyMap(allSlotKeys, (slotKey, i) => ([ababa[i].slice(0, feas[i]).flatMap(({ ixs }) => ixs), ababa[i].slice(feas[i]).flatMap(({ ixs }) => ixs)]))\n}\n\nfunction performSingletonPrune(arts: ArtifactsBySlotVec, threshold: number, { constraints, filters, lin }: SubProblem) {\n  applyLinearForm(arts, lin)\n  const mins = [...constraints.map(({ min }) => min), threshold]\n\n  let changed = false\n  for (let i = filters.length - 1; i >= 0; i--) {\n    const { maxw, filterVec } = filters[i]\n\n    const toremove = objectKeyMap(allSlotKeys, slot => {\n      const slotArts = filterVec[slot].map(ix => arts.values[slot][ix])\n      const { minw: minwSlot, maxw: maxwSlot } = slotUpperLowerVecW(slotArts)\n\n      const toremove: number[] = []\n      maxw.forEach((mv, j) => {\n        const cutoff = mins[j] - maxw[j] + maxwSlot[j]\n        if (minwSlot[j] > cutoff) return\n\n        toremove.push(...filterVec[slot].filter(ix => arts.values[slot][ix].buffer[j] < cutoff))\n      })\n      return new Set(toremove)\n    })\n    if (Object.values(toremove).every(rm => rm.size === 0)) continue\n\n    changed = true\n    const newFilterVec = objectKeyMap(allSlotKeys, slot => filterVec[slot].filter(ix => !toremove[slot].has(ix)))\n\n    const numBuilds = allSlotKeys.reduce((tot, slot) => tot * newFilterVec[slot].length, 1)\n    if (numBuilds === 0) {\n      filters.splice(i, 1)\n      continue\n    }\n\n    filters[i] = {\n      filterVec: newFilterVec,\n      ...statsUpperLowerVec(filterArtsVec2(arts, newFilterVec))\n    }\n  }\n\n  return changed\n}\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","isArray","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","iter","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_typeof","_regeneratorRuntime","exports","Op","hasOwn","hasOwnProperty","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","undefined","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","_i","_s","_arr","_n","_d","objPathValue","console","reduce","a","k","objectKeyMap","map","fromEntries","objectMap","entries","v","rangeGen","to","range","assertUnreachable","cartesian","q","b","flatMap","d","flat","constant","NaN","percent","operation","operands","Number","MAX_VALUE","Infinity","sum","intoOps","prod","customRead","path","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","precompute","binding","uniqueReadStrings","uniqueNumbers","mapping","_","accu","ins","op","locations","readStrings","readOffset","constValues","computations","str","offset","ref","node","out","buff","fill","buffer","Float64Array","number","copyList","src","copyFormula","dst","j","flatten","_formula","flattened","dep","deduplicate","elementCounts","array","common","counts","factored","count","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","smallest","v1","v2","match","unmatch","list","nextContext","allSlotKeys","allArtifactSets","filterFeasiblePerm","artSetPerm","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","isAffine","_op","dynKeys","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","baseValue","filterArtsVec2","filterVec","baseBuffer","filterIxs","slotVals","ix","filters","_artSets","artSets","available","kind","sets","exclusionToAllowed","exclusion","includes","populateShapes","indexOfShape","shape","check_free","remaining","rainbows","isolated","missing","rejected","required","allowedSet","allowedCounts","some","groupped","used","requiredRainbows","l","usableRainbows","sort","replacing","allowedRainbows","shapes","rainbow","noFilter","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","sumM","monomials","prodM","monos","ret","nxt","coeff","terms","constantM","readM","tag","foldLikeTerms","mono","mon","m","termsA","termsB","ai","splice","pivotInplace","A","Aij","h","findPiv1","r","c","minloc","cmp","findPiv2","minMax","lower","upper","compute","fillBuffer","minval","handleResArg","flippedResOp","flipOps","branch","bval","ge","lt","log","resf","toLinearUpperBound","stat2tag","toPureRead","mon1","rop","cop","thresh","minVal","maxVal","em","denom","minEM","maxEM","sqrt","below","slope","nodesToMap","t2","t","nt","lins","w","bounds","nVar","boundScale","scaleProd","soln","cons","coords","objective","Ab","rows","cols","tableau","Ai","cj","ijTrack","ij","targ","side","ncol","backtrack","solveLP","wi","lub","lin","foldSum","constVal","pv","foldProd","stats","countBuildsU","tot","_count","unionFilterUpperLower","minw","maxw","applyLinearForm","wixs","ws","baseC","li","ixs0","w0","indexOf","accum","slotKey","art","ixsi","reduceSubProblem","subp","optimizationTarget","constraints","artSetExclusion","depth","mins","statsMin","statsMax","fixedStats","statKey","abs","tagNodePairs","reducedNodes","branchVal","ni","tagsToKill","newTerms","newNodes","reducePolynomial","toNumNode","active","newOptTarget","newConstraints","newMins","newArtExcl","setKey","exclude","feasibleKeys","feasible4sets","feasible2sets","allowedCnts","cnt","reducedExcl","fi","newFilters","minww","maxww","slotUpperLowerVecW","cache","slotUpperLowerVec","statsUpperLowerVec","slotArts","slotUL","splitWorker","computeWorker","ComputeWorker","callback","artsVec","plotBase","maxBuilds","builds","buildValues","plotData","interimReport","refresh","command","tested","failed","skipped","optimize","newThreshold","subproblem","totalCount","reduceFormula","reaff","preArts","unionArts","ids","permute","setKeyCounts","excl","num","nRainbow","checkArtSetExclusion","build","artifactIds","plot","curr","force","plots","scale","round","mergePlot","SplitWorker","items","artSet","subproblems","splitcounter","maxEst","upperBound","minCount","maxIter","addSubProblem","initialProblemTotal","newProblemTotal","splitBNB","heur","branches0","filts","rest","floor","partition","ceil","filt","origBuilds","pruned","changed","toremove","minwSlot","maxwSlot","mv","cutoff","rm","newFilterVec","performSingletonPrune","newBuilds","makeBranches","branches","numBuilds","sub2","me","allIDs","flower","plume","sands","goblet","circlet","setptr","aarts","filterArtsVec","decisionHeur","th","argMax","branchOn","branchOnSetKey","linToConsider","keysToConsider","shatterOn","kix","postShatterRangeReduction","rangeReduc","vals","minv","maxv","glb","targetBranchVal","left","right","branchSplitsIx","ababa","ixs","aa","x0","vi","feas","checkFeasible","breaks","score","p","bi","si","z","onesteps","twosteps","greedyStep","di","pr","dj","splitToTargetIx","branchArts","slots","toPush","branchOnValue","format","ixVec","middle","ixVec1","artIx","ixVec2","setCount","onmessage","interim","postMessage","split","ready","computeU","setPerm","perm","countBuilds","filterArts","oo","popOne","sender"],"sourceRoot":""}