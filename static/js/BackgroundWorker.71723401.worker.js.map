{"version":3,"file":"static/js/BackgroundWorker.71723401.worker.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","Util/Util.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","Formula/expandPoly.ts","Formula/solveLP_simplex.ts","Formula/linearUpperBound.ts","Formula/addedUtils.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/SplitWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj, keys, validate, cb) {\n  if (validate(obj)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map(t => map(t))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap(d => b.map(e => [d, [e]].flat())), [[]] as T[][])\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\n}\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\n/** v1 >= v2 ? pass : fail */\nexport function cmp(v1: Num, v2: Num, pass: Num, fail: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n\nexport function cmpNode(a: NumNode, b: NumNode): boolean {\n  if (a.operation !== b.operation) return false;\n  if (a.operands.length !== b.operands.length) return false;\n\n  switch (a.operation) {\n    case 'read':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.path.every((ai, i) => ai === b.path[i])\n    case 'const':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.value === b.value\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      let used = [] as number[]\n      return a.operands.every((ai, i) => b.operands.some((bj, j) => {\n        if (used.includes(j)) return false\n        if (cmpNode(ai, bj)) {\n          used.push(j)\n          return true\n        }\n        return false\n      }))\n    default:\n      return a.operands.every((ai, i) => cmpNode(ai as NumNode, b.operands[i] as NumNode))\n  }\n}\n\n// Hash function pulled from StackOverflow\n//   https://stackoverflow.com/a/52171480\nconst cyrb53 = function (str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n\n// I made these numbers up; we might get better performance with different choice.\nexport function hashNode(n: NumNode): number {\n  let hsh = Math.imul(cyrb53(n.operation), 5234543537);\n  switch (n.operation) {\n    case 'const':\n      return hsh ^ cyrb53(n.value.toString(2))\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      return n.operands.reduce((hsh, ni) => hsh ^ hashNode(ni), hsh)\n    default:\n      return (n.operands as NumNode[]).reduce((hsh, ni) => Math.imul(hsh ^ hashNode(ni), 9923429423), hsh)\n  }\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objectKeyMap, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): [compute: () => Float64Array, mapping: Dict<string, number>, buffer: Float64Array] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = new Float64Array(offset).fill(0)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return [() => {\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }, objectKeyMap(readStrings, (_, i) => readOffset + i), buffer]\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allReactionModes = [\"hydro_vaporize\", \"pyro_vaporize\", \"pyro_melt\", \"cryo_melt\",] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  \"DefendersWill\",\n  \"EchoesOfAnOffering\",\n  \"EmblemOfSeveredFate\",\n  \"Gambler\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  \"HuskOfOpulentDreams\",\n  \"Instructor\",\n  \"Lavawalker\",\n  \"LuckyDog\",\n  \"MaidenBeloved\",\n  \"MartialArtist\",\n  \"NoblesseOblige\",\n  \"OceanHuedClam\",\n  \"PaleFlame\",\n  \"PrayersForDestiny\",\n  \"PrayersForIllumination\",\n  \"PrayersForWisdom\",\n  \"PrayersToSpringtime\",\n  \"ResolutionOfSojourner\",\n  \"RetracingBolide\",\n  \"Scholar\",\n  \"ShimenawasReminiscence\",\n  \"TenacityOfTheMillelith\",\n  \"TheExile\",\n  \"ThunderingFury\",\n  \"Thundersoother\",\n  \"TinyMiracle\",\n  \"TravelingDoctor\",\n  \"VermillionHereafter\",\n  \"ViridescentVenerer\",\n  \"WanderersTroupe\",\n] as const\nexport const allCharacterKeys = [\n  \"Albedo\",\n  \"Amber\",\n  \"Barbara\",\n  \"Beidou\",\n  \"Bennett\",\n  \"Chongyun\",\n  \"Diluc\",\n  \"Diona\",\n  \"Fischl\",\n  \"Ganyu\",\n  \"HuTao\",\n  \"Jean\",\n  \"Kaeya\",\n  \"Keqing\",\n  \"Klee\",\n  \"KujouSara\",\n  \"Lisa\",\n  \"Mona\",\n  \"Ningguang\",\n  \"Noelle\",\n  \"Qiqi\",\n  \"Razor\",\n  \"Sucrose\",\n  \"Tartaglia\",\n  \"Traveler\",\n  \"RaidenShogun\",\n  \"Venti\",\n  \"Xiangling\",\n  \"Xiao\",\n  \"Xingqiu\",\n  \"Xinyan\",\n  \"Rosaria\",\n  \"Yanfei\",\n  \"Eula\",\n  \"KaedeharaKazuha\",\n  \"KamisatoAyaka\",\n  \"Sayu\",\n  \"Shenhe\",\n  \"Yoimiya\",\n  \"Aloy\",\n  \"SangonomiyaKokomi\",\n  \"Thoma\",\n  \"Gorou\",\n  \"AratakiItto\",\n  \"YaeMiko\",\n  \"YunJin\",\n  \"Zhongli\",\n  \"KamisatoAyato\",\n  \"Yelan\",\n  // \"KukiShinobu\"\n] as const\n\nexport const allWeaponSwordKeys = [\n  \"AmenomaKageuchi\",\n  \"AquilaFavonia\",\n  \"BlackcliffLongsword\",\n  \"CinnabarSpindle\",\n  \"CoolSteel\",\n  \"DarkIronSword\",\n  \"DullBlade\",\n  \"FavoniusSword\",\n  \"FesteringDesire\",\n  \"FilletBlade\",\n  \"FreedomSworn\",\n  \"HaranGeppakuFutsu\",\n  \"HarbingerOfDawn\",\n  \"IronSting\",\n  \"LionsRoar\",\n  \"MistsplitterReforged\",\n  \"PrimordialJadeCutter\",\n  \"PrototypeRancour\",\n  \"RoyalLongsword\",\n  \"SacrificialSword\",\n  \"SilverSword\",\n  \"SkyriderSword\",\n  \"SkywardBlade\",\n  \"SummitShaper\",\n  \"SwordOfDescension\",\n  \"TheAlleyFlash\",\n  \"TheBlackSword\",\n  \"TheFlute\",\n  \"TravelersHandySword\",\n] as const\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\n\nexport const allWeaponClaymoreKeys = [\n  \"Akuoumaru\",\n  \"BlackcliffSlasher\",\n  \"BloodtaintedGreatsword\",\n  \"DebateClub\",\n  \"FavoniusGreatsword\",\n  \"FerrousShadow\",\n  \"KatsuragikiriNagamasa\",\n  \"LithicBlade\",\n  \"LuxuriousSeaLord\",\n  \"OldMercsPal\",\n  \"PrototypeArchaic\",\n  \"Rainslasher\",\n  \"RedhornStonethresher\",\n  \"RoyalGreatsword\",\n  \"SacrificialGreatsword\",\n  \"SerpentSpine\",\n  \"SkyriderGreatsword\",\n  \"SkywardPride\",\n  \"SnowTombedStarsilver\",\n  \"SongOfBrokenPines\",\n  \"TheBell\",\n  \"TheUnforged\",\n  \"WasterGreatsword\",\n  \"Whiteblind\",\n  \"WhiteIronGreatsword\",\n  \"WolfsGravestone\",\n] as const\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\n\nexport const allWeaponPolearmKeys = [\n  \"BeginnersProtector\",\n  \"BlackcliffPole\",\n  \"BlackTassel\",\n  \"CalamityQueller\",\n  \"CrescentPike\",\n  \"Deathmatch\",\n  \"DragonsBane\",\n  \"DragonspineSpear\",\n  \"EngulfingLightning\",\n  \"FavoniusLance\",\n  \"Halberd\",\n  \"IronPoint\",\n  \"KitainCrossSpear\",\n  \"LithicSpear\",\n  \"PrimordialJadeWingedSpear\",\n  \"PrototypeStarglitter\",\n  \"RoyalSpear\",\n  \"SkywardSpine\",\n  \"StaffOfHoma\",\n  \"TheCatch\",\n  \"VortexVanquisher\",\n  \"WavebreakersFin\",\n  \"WhiteTassel\",\n] as const\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\n\nexport const allWeaponBowKeys = [\n  \"AlleyHunter\",\n  \"AmosBow\",\n  \"AquaSimulacra\",\n  \"BlackcliffWarbow\",\n  \"CompoundBow\",\n  \"ElegyForTheEnd\",\n  \"FadingTwilight\",\n  \"FavoniusWarbow\",\n  \"Hamayumi\",\n  \"HuntersBow\",\n  \"Messenger\",\n  \"MitternachtsWaltz\",\n  \"MouunsMoon\",\n  \"PolarStar\",\n  \"Predator\",\n  \"PrototypeCrescent\",\n  \"RavenBow\",\n  \"RecurveBow\",\n  \"RoyalBow\",\n  \"Rust\",\n  \"SacrificialBow\",\n  \"SeasonedHuntersBow\",\n  \"SharpshootersOath\",\n  \"SkywardHarp\",\n  \"Slingshot\",\n  \"TheStringless\",\n  \"TheViridescentHunt\",\n  \"ThunderingPulse\",\n  \"WindblumeOde\",\n] as const\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\n\nexport const allWeaponCatalystKeys = [\n  \"ApprenticesNotes\",\n  \"BlackcliffAgate\",\n  \"DodocoTales\",\n  \"EmeraldOrb\",\n  \"EverlastingMoonglow\",\n  \"EyeOfPerception\",\n  \"FavoniusCodex\",\n  \"Frostbearer\",\n  \"HakushinRing\",\n  \"KagurasVerity\",\n  \"LostPrayerToTheSacredWinds\",\n  \"MagicGuide\",\n  \"MappaMare\",\n  \"MemoryOfDust\",\n  \"OathswornEye\",\n  \"OtherworldlyStory\",\n  \"PocketGrimoire\",\n  \"PrototypeAmber\",\n  \"RoyalGrimoire\",\n  \"SacrificialFragments\",\n  \"SkywardAtlas\",\n  \"SolarPearl\",\n  \"TheWidsith\",\n  \"ThrillingTalesOfDragonSlayers\",\n  \"TwinNephrite\",\n  \"WineAndSong\",\n] as const\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type ReactionModeKey = typeof allReactionModes[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\n","import { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\nimport type { ArtSetExclusion } from \"./BuildSetting\";\n\ntype DynMinMax = { [key in string]: MinMax }\ntype MinMax = { min: number, max: number }\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\n\n  function visit(node: NumNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(_op => {\n      const op = _op as NumNode\n      affineNodes.has(op) && topLevelAffine.add(op)\n    })\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const operation = f.operation\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\":\n        if (typeof f.value === \"string\" || f.value === undefined)\n          throw new Error(`Found constant ${f.value} while compacting`)\n        visit(f as NumNode, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\n    Object.keys(arts.base).length === dynKeys.size)\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\n  let progress = false\n  const noRainbow = !exclusion.rainbow?.length\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return constant(0)\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter(key => arts.every(art => art.values[key]))\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\n  const range = new Map<NumNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, _f => {\n    const f = _f as NumNode\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"subscript\": current = computeMinMax(f.list); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = computeMinMax([0])\n        else current = computeMinMax([0], [operands[2]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      case \"data\": case \"lookup\": case \"match\":\n        throw new Error(`Unsupported ${operation} node`)\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n\n\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\n        case \"id\": break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\n  return new Set(exclusion?.includes(2)\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length))\n        shapes.push(current)\n      return\n    }\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\n      return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\n        shape[replacing] = 5\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\n\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set()\n    let groupped: number[][] = [], rainbows: number[] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length)\n        return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set], count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find(x => x > count)! - count\n          missing.push(set)\n        }\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport const emptyfilter: RequestFilter = objectKeyMap(allSlotKeys, _ => ({ kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }));\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n","import { optimize, precompute } from '../../../../Formula/optimization';\nimport type { NumNode } from '../../../../Formula/type';\nimport { ArtifactSetKey } from '../../../../Types/consts';\nimport type { InterimResult, Setup, SubProblem } from './BackgroundWorker';\nimport { ArtifactsBySlot, Build, countBuilds, filterArts, mergePlot, PlotData, pruneAll, RequestFilter } from './common';\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold: number = -Infinity\n  maxBuilds: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: NumNode[]\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.min = filters.map(x => x.min)\n    this.maxBuilds = maxBuilds\n    this.callback = callback\n    this.nodes = filters.map(x => x.value)\n    this.nodes.push(optimizationTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n  }\n\n  compute(newThreshold: number, subproblem: SubProblem) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n    const { optimizationTarget, constraints, filter, artSetExclusion } = subproblem\n    // TODO: check artSetExclusion stuff\n\n    const { min, interimReport } = this, self = this // `this` in nested functions means different things\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts)\n\n    let nodesReduced = optimize([...constraints.map(({ value }) => value), optimizationTarget], {}, _ => false);\n    // const min = [...constraints.map(({ min }) => min), -Infinity];\n\n    // console.log(this.arts)\n\n    let nodes = optimize(this.nodes, {}, _ => false);\n    // ({ nodes, arts: preArts } = pruneAll(nodes, min, preArts, this.maxBuilds, {}, {\n    //   pruneArtRange: true, pruneNodeRange: true,\n    // }))\n    const [compute, mapping, buffer] = precompute(nodes, f => f.path[1])\n    const [compute2, mapping2, buffer2] = precompute(nodesReduced, f => f.path[1])\n    const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length).map(arts => arts.map(art => ({\n      id: art.id, set: art.set, values: Object.entries(art.values)\n        // .map(([key, value]) => ({ key: mapping[key]!, value, cache: 0 }))\n        .map(([key, value]) => ({ key: mapping[key]!, key2: mapping2[key] ?? 0, value, cache: 0 }))\n        .filter(({ key, value }) => key !== undefined && value !== 0)\n    })))\n    // console.log(mapping)\n    // console.log(artSetExclusion)\n    // console.log(this.arts)\n    // throw Error('stop here')\n\n    const ids: string[] = Array(arts.length).fill(\"\")\n    let count = { tested: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\n\n    function permute(i: number, oddKeys: Set<ArtifactSetKey | undefined>) {\n      if (i < 0) {\n        const result = compute()\n        const result2 = compute2()\n        if (Math.abs(result[min.length] - result2[constraints.length]) > 1e-4) {\n          console.log('OOF COMPUTE NO MATCH')\n          console.log(preArts)\n          console.log(nodes)\n          console.log(nodesReduced)\n          console.log(buffer)\n          console.log(buffer2)\n          throw Error('what?')\n        }\n        let passArtExcl = !Object.entries(artSetExclusion).some(([setKey, vals]) => {\n          let bufloc = mapping[setKey]\n          if (!bufloc) return false\n          return vals.includes(buffer[bufloc])\n        })\n        // This checks rainbows\n        if (artSetExclusion['uniqueKey'] !== undefined) passArtExcl = artSetExclusion['uniqueKey'].every(v => v !== oddKeys.size)\n        if (passArtExcl && min.every((m, i) => (m <= result[i]))) {\n          const value = result[min.length], { builds, plotData, threshold } = self\n          let build: Build | undefined\n          if (value >= threshold) {\n            build = { value, artifactIds: [...ids] }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build) build = { value, artifactIds: [...ids] }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        }\n        else count.failed += 1\n        return\n      }\n      arts[i].forEach(art => {\n        ids[i] = art.id\n\n        for (const current of art.values) {\n          const { key, value } = current\n          current.cache = buffer[key]\n          buffer[key] += value\n          buffer2[current.key2] += value\n        }\n\n        if (oddKeys.has(art.set)) oddKeys.delete(art.set)\n        else oddKeys.delete(art.set)\n        permute(i - 1, oddKeys)\n        if (oddKeys.has(art.set)) oddKeys.delete(art.set)\n        else oddKeys.delete(art.set)\n\n        for (const { key, key2, cache } of art.values) {\n          buffer[key] = cache\n          buffer2[key2] = cache\n        }\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 8192)\n          interimReport(count)\n      }\n    }\n\n    for (const [key, value] of Object.entries(preArts.base)) {\n      const i = mapping[key]\n      if (i !== undefined)\n        buffer[i] = value\n\n      const i2 = mapping2[key]\n      if (i2 !== undefined)\n        buffer2[i2] = value\n    }\n\n    permute(arts.length - 1, new Set())\n    this.interimReport(count)\n    return this.threshold\n  }\n\n  refresh(force: boolean): void {\n    const { maxBuilds } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    // I need frequent updating of threshold\n    if (true || this.builds.length >= 100000 || force) {\n      this.builds = this.builds\n        .sort((a, b) => b.value - a.value)\n        .slice(0, maxBuilds)\n      this.buildValues = this.builds.map(x => x.value)\n      this.threshold = Math.max(this.threshold, this.buildValues[maxBuilds - 1] ?? -Infinity)\n    }\n  }\n  interimReport = (count: { tested: number, failed: number, skipped: number }) => {\n    this.refresh(false)\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { constant, sum, prod, hashNode, cmp, cmpNode } from \"./utils\"\nimport { ConstantNode, NumNode } from \"./type\"\nimport { allArtifactSets } from \"../Types/consts\"\nimport { cartesian } from '../Util/Util'\n\nexport function foldSum(nodes: NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n\n  nodes = nodes.flatMap(n => n.operation === 'add' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv + n.value : pv, 0)\n  nodes = nodes.filter(n => n.operation !== 'const')\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 0) return sum(...nodes)\n  return sum(...nodes, constant(constVal))\n}\n\nexport function foldProd(nodes: NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n\n  nodes = nodes.flatMap(n => n.operation === 'mul' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv * n.value : pv, 1)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 0) return sum(...nodes)\n  return prod(...nodes, constant(constVal))\n}\n\nfunction gatherSumOfProds(products: NumNode[], isVar: (n: NumNode) => boolean): NumNode[] {\n  // return products\n  type NodeLinkedList = { n: NumNode, ix: number, next: NodeLinkedList | undefined }\n  let varMap = {} as Dict<number, NodeLinkedList> // my shitty hashmap\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\n  let varCounter = 0\n  function lookup(n: NumNode) {\n    let hsh = hashNode(n)\n    let z = varMap[hsh]\n    while (z !== undefined) {\n      if (cmpNode(z.n, n)) return BigInt(z.ix)\n      z = z.next\n    }\n\n    const ix = primes[varCounter]\n    varMap[hsh] = { n, ix, next: varMap[hsh] }\n    varCounter += 1\n    return BigInt(ix)\n  }\n\n  let result: { [k: string]: { coeff: number, rhs: NumNode[] } } = {}\n  products.forEach(n => {\n    if (n.operation === 'const') {\n      result[1] = { coeff: n.value + (result[1]?.coeff ?? 0), rhs: [] }\n      return\n    }\n    else if (isVar(n)) {\n      let ix = lookup(n).toString()\n      result[ix] = { coeff: 1 + (result[ix]?.coeff ?? 0), rhs: [n] }\n      return\n    }\n    else if (n.operation === 'mul') {\n      const { coeff, ix, ops } = n.operands.reduce(({ coeff, ix, ops }, n) => {\n        if (n.operation === 'const') return { coeff: coeff * n.value, ix, ops }\n        ops.push(n)\n        return { coeff, ix: ix * lookup(n), ops: ops }\n      }, { coeff: 1, ix: BigInt(1), ops: [] as NumNode[] })\n      let ix2 = ix.toString()\n      result[ix2] = { coeff: coeff + (result[ix2]?.coeff ?? 0), rhs: ops }\n      return\n    }\n    console.log(n)\n    throw Error('Encountered unexpected node in `gatherSumOfProds`')\n  })\n  return Object.entries(result).map(([k, { coeff, rhs }]) => {\n    return foldProd([...rhs, constant(coeff)])\n  })\n}\n\n/**\n * Factors damage formula into pure polynomials of each variable.\n * For example:  (1700 * atk_ + atk) * (1 + cr * cd) * (1 + sum_frac(EM))\n *   -> 1700 * atk_ + 1700 * atk_ * cr * cd + 1700 * atk_ * sum_frac(EM) + 1700 * atk_ * cr * cd * sum_frac(EM)\n *            + atk +         atk * cr * cd +         atk * sum_frac(EM) +         atk * cr * cd * sum_frac(EM)\n *\n * For a total of 8 terms, since there are 3 pairs of additions, for 2^3 sum-of-product terms.\n *\n * isVar() is used to check whether any node should be considered a variable on its own.\n */\nexport function expandPoly(node: NumNode, isVar: (n: NumNode) => boolean): NumNode {\n  switch (node.operation) {\n    case 'mul':\n      let ops = node.operands.map(n => expandPoly(n, isVar))\n        .map(n => n.operation === 'add' ? n.operands : [n])\n        .map((ns, i) => {\n          const varExprs = ns.map(n => isVar(n) || (n.operation === 'mul' && n.operands.some(isVar)))\n          let vars = ns.filter((n, i) => varExprs[i])\n          let nonVars = ns.filter((n, i) => !varExprs[i])\n\n          if (nonVars.length === 0) return vars\n          return [...vars, foldSum(nonVars)]\n        })\n\n      const products = cartesian(...ops).map(ns => foldProd(ns))\n      return foldSum(gatherSumOfProds(products, isVar))\n\n    case 'add':\n      let newOps = node.operands.map(n => expandPoly(n, isVar))\n        .flatMap(n => n.operation === 'add' ? n.operands : n)\n\n      // TODO: Look for like factors and add their coefficients together\n      return foldSum(gatherSumOfProds(newOps, isVar))\n\n    default:\n      return node\n  }\n}\n\n/**\n * Assumes we've expanded the damage formula into sum-of-products form.\n * Prunes formulas that are unreachable due to not enough slots.\n */\nexport function productPossible(node: NumNode) {\n  // TODO: fix me? This might be over-eager currently.\n  return countSlotUsage(node) <= 5\n}\n\nexport function countSlotUsage(node: NumNode) {\n  if (node.operation === 'add') {\n    return Math.min(...node.operands.map(n => countSlotUsage(n)))\n  }\n  else if (node.operation === 'mul') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => a + b)\n  }\n  else if (node.operation === 'threshold') {\n    const branch = node.operands[0]\n    if (branch.operation === 'read' && (allArtifactSets as readonly string[]).includes(branch.path[1])) {\n      let con = node.operands[1] as ConstantNode<number>\n      return con.value\n    }\n  }\n  return 0\n}\n","function pivot(A: number[][], ij: { i: number, j: number }) {\n  const { i, j } = ij\n  const Aij = A[i][j]\n  return A.map((Ah, h) => Ah.map((Ahk, k) => {\n    if (h === i && k === j) return 1 / Aij;\n    if (h === i) return A[i][k] / Aij;\n    if (k === j) return -A[h][j] / Aij;\n    return Ahk - A[i][k] * A[h][j] / Aij;\n  }))\n}\n\nfunction findPiv1(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= 0) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > 1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\nfunction findPiv2(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= 0) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\nfunction backtrack(tableau: number[][], ijTrack: { i: number, j: number }[], targ: number) {\n  let side = 1;  // 0 left, 1 right\n  ijTrack.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    }\n    else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to:\n *   https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* a problem for GO's use\n *   case. This algorithm is fairly numerically unstable though, use with care & always\n *   try to verify the solution. It's also a fair bit slower than it needs to be.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        the optimal solution x\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  let rows = Ab.length + 1\n  let cols = Ab[0].length\n\n  let tableau = Array(rows).fill(0).map(_ => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => tableau[i][j] = Aij))\n  // b.forEach((bi, i) => tableau[i][cols - 1] = bi)\n  c.forEach((cj, j) => tableau[rows - 1][j] = cj)\n  // console.log('tab', tableau)\n\n  let ijTrack: { i: number, j: number }[] = []\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < 0)) {\n    const ij = findPiv2(tableau)\n    ijTrack.push(ij)\n    tableau = pivot(tableau, ij)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < 0)) {\n    const ij = findPiv1(tableau)\n    ijTrack.push(ij)\n    tableau = pivot(tableau, ij)\n  }\n\n  return c.map((_, i) => backtrack(tableau, ijTrack, i))\n}\n","import { NumNode, ComputeNode } from \"./type\"\nimport { ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { constant, sum, prod, cmp } from \"./utils\"\nimport { foldSum, foldProd, expandPoly } from './expandPoly'\nimport { precompute, allOperations } from \"./optimization\"\nimport { solveLP } from './solveLP_simplex'\nimport { cartesian } from '../Util/Util'\nimport { mapFormulas } from \"./internal\"\n\nexport type LinearForm = {\n  w: DynStat,\n  c: number,\n  err: number\n}\n\nfunction minMax(node: NumNode, lower: DynStat, upper: DynStat) {\n  let [compute, mapping, buffer] = precompute([node], n => n.path[1])\n  Object.entries(lower).forEach(([k, v]) => buffer[mapping[k] ?? 0] = v)\n  const minval = compute()[0]\n  Object.entries(upper).forEach(([k, v]) => buffer[mapping[k] ?? 0] = v)\n  const maxval = compute()[0]\n  return [minval, maxval]\n}\n\n/**\n * `res` is the ONE place where negative arguments & negative slopes are allowed.\n * @param node\n */\nfunction handleResArg(node: { 'operation': 'res', 'operands': NumNode[] }, lower: DynStat, upper: DynStat) {\n  function flipOps(n: NumNode): NumNode {\n    switch (n.operation) {\n      case 'add':\n        return sum(...n.operands.map(n => flipOps(n)))\n      case 'const':\n        return constant(-n.value)\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (ge.operation === 'const' && lt.operation === 'const') {\n          if (ge.value <= lt.value) {\n            return cmp(branch, bval, -ge.value, lt.value)\n          }\n        }\n        console.log(n)\n        throw Error('(res neg slope): threshold. Something went wrong.')\n      default:\n        console.log(n)\n        throw Error('(res neg slope) Havent written logic to handle this')\n    }\n  }\n\n  const flippedResOp = flipOps(node.operands[0])\n\n  let [a, b] = minMax(flippedResOp, lower, upper)\n  let resf = allOperations['res']\n  let [c, d] = [resf([-a]), resf([-b])]\n\n  if (b > 0 && a > -1.75) {\n    // 1 + x / 2\n    return sum(1, prod(.5, flippedResOp))\n  }\n\n  const intercept = (b * c - a * d) / (b - a)\n  const slope = (c - d) / (b - a)\n  return sum(intercept, prod(slope, flippedResOp))\n}\n\n/**\n * First converts a product of variables (including max, min, sum_frac, threshold, etc.) to\n *   a pure product form consisting of only `read` and `const` nodes, guaranteeing the\n *   product form is an upper bound.\n *\n * Then on the product form, create a linear upper bound using `lub` and return it.\n *\n * @param node The formula to expand\n * @param lower Stat lower bounds\n * @param upper Stat upper bounds\n * @returns\n */\nexport function toLinearUpperBound(node: NumNode, lower: DynStat, upper: DynStat): LinearForm | LinearForm[] {\n  if (node.operation === 'const')\n    return { w: {}, c: node.value, err: 0 }\n  if (node.operation === 'read')\n    return { w: { [node.path[1]]: 1 }, c: 0, err: 0 }\n  if (node.operation !== 'mul') {\n    throw Error('toLUB should only operate on product forms')\n  }\n\n  let l = { ...lower }\n  let u = { ...upper }\n  let linerr = 0\n\n  // Converts threshold(Glad) * ATK * min(CR, 1) => Glad * ATK * CR\n  // Also updates lower & upper limits to respect min, max, threshold.\n  // TODO: track linearization error for threshold(), min(), max(), sum_frac() nodes\n  function purePolyForm(node: NumNode) {\n    switch (node.operation) {\n      case 'const': case 'read':\n        return node\n      case 'add':\n        return foldSum(node.operands.map(n => purePolyForm(n)))\n      case 'mul':\n        return foldProd(node.operands.map(n => purePolyForm(n)))\n      case 'threshold':\n        const [branch, bval, ge, lt] = node.operands\n        if (branch.operation === 'read'\n          && bval.operation === 'const' && lt.operation === 'const' && ge.operation === 'const') {\n          let key = branch.path[1]\n          if (lower[key] >= bval.value) return constant(ge.value)\n          if (upper[key] < bval.value) return constant(lt.value)\n\n          if (ge.value < lt.value) {\n            console.log(node)\n            throw Error('Not Implemented (threshold must be increasing)')\n          }\n\n          const slope = (ge.value - lt.value) / bval.value\n          u[key] = bval.value\n          // TODO: update linerr\n          return sum(lt.value, prod(slope, branch))\n        }\n        console.log(node)\n        throw Error('Not Implemented (threshold must branch between constants)')\n      case 'res':\n        let op = handleResArg(node as { 'operation': 'res', 'operands': NumNode[] }, lower, upper)\n        op = expandPoly(op, n => n.operation !== 'const')\n        return purePolyForm(op)\n\n      case 'min':\n        let [rop, cop] = node.operands\n        if (cop.operation !== 'const')\n          [rop, cop] = [cop, rop]  // Assume min(const, read)\n\n        if (rop.operation === 'read' && cop.operation === 'const') {\n          if (cop.value < u[rop.path[1]]) {\n            // TODO: update linerr\n            u[rop.path[1]] = cop.value\n          }\n          return purePolyForm(rop)\n        }\n\n        // TODO: update linerr\n        // If it's not a simple min() node, returning either value is still UB.\n        return purePolyForm(rop)\n\n      case 'max':\n        let [varop, constop] = node.operands\n        if (constop.operation !== 'const')\n          [varop, constop] = [constop, varop]\n\n        if (cop.operation === 'const') {\n          const thresh = cop.value\n          const [minVal, maxVal] = minMax(varop, lower, upper)\n          if (minVal > thresh) return varop\n          if (thresh > maxVal) return constant(thresh)\n\n          // rescale `varop` to be above thresh.\n          let m = (maxVal - thresh) / (maxVal - minVal)\n          let b = thresh - minVal\n          return sum(prod(m, purePolyForm(varop)), b)\n        }\n        console.log(node)\n        throw Error('Not Implemented (max)')\n\n      case 'sum_frac':\n        const [em, denom] = node.operands\n        if (denom.operation !== 'const') throw Error('Not Implemented (non-constant sum_frac denominator)')\n\n        const [minEM, maxEM] = minMax(em, lower, upper)\n        const k = denom.value\n        // The sum_frac form is concave, so any Taylor expansion of EM / (EM + k) gives an upper bound.\n        // We can solve for the best Taylor approximation location with the following formula.\n        let loc = Math.sqrt((minEM + k) * (maxEM + k)) - k\n        let below = (k + loc) * (k + loc)\n        let slope = k / below\n        let c = loc * loc / below\n\n        // TODO: update linerr\n        return purePolyForm(sum(c, prod(slope, em)))\n      default:\n        console.log(node)\n        throw Error('Not Implemented')\n    }\n  }\n\n  // `lpf` *should* be a product of read() and const() nodes. Maybe a sum of these products.\n  const lpf = expandPoly(purePolyForm(node), n => n.operation !== 'const')\n  if (lpf.operation === 'const')\n    return { w: {} as DynStat, c: lpf.value, err: linerr }\n\n  function toLUB(n: NumNode) {\n    if (n.operation === 'read') {\n      return { w: { [n.path[1]]: 1 }, c: 0, err: 0 }\n    }\n    if (n.operation === 'const') {\n      return { w: {}, c: n.value, err: 0 }\n    }\n    if (n.operation !== 'mul') {\n      console.log(n)\n      throw Error('toLUB takes only mul nodes.')\n    }\n    let coeff = 1\n    // TODO: handle duplicity in the vars\n    const vars = n.operands.reduce((vars, op) => {\n      if (op.operation === 'read') vars.push(op.path[1])\n      if (op.operation === 'const') coeff *= op.value\n      return vars\n    }, [] as string[])\n    const bounds = vars.map(v => ({ lower: lower[v], upper: upper[v] }))\n    const { w, c, err } = lub(bounds)\n\n    const retw = w.reduce((ret, wi, i) => {\n      ret[vars[i]] = wi * coeff + (ret[vars[i]] ?? 0)\n      return ret\n    }, {} as DynStat)\n    return { w: retw, c: c * coeff, err: err * coeff + linerr }\n  }\n\n  if (lpf.operation === 'add') return lpf.operands.map(n => toLUB(n))\n  return toLUB(lpf)\n}\n\n/**\n * Constructs an upper bounding linear form for a function x_1 * x_2 * ... * x_n\n * @param bounds upper and lower bounds for each x_i\n * @returns { w, c, err } with\n */\nfunction lub(bounds: { lower: number, upper: number }[]): { w: number[], c: number, err: number } {\n  if (bounds.length === 0) return { w: [], c: 0, err: 0 }\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ upper }) => upper)\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ lower, upper }) => ({ lower: lower / upper, upper: 1 }))\n\n  // Setting up the linear program in terms of constraints.\n  let cons = cartesian(...bounds.map(({ lower, upper }) => [lower, upper])).flatMap((coords) => {\n    const prod = coords.reduce((prod, v) => prod * v, 1)\n    return [\n      [...coords.map(v => -v), 1, 0, -prod],\n      [...coords, -1, -1, prod],\n    ]\n  })\n\n  // Force equality at upper & lower corners?\n  // cons.push([...bounds.map(lu => lu.lower), -1, 0, bounds.reduce((prod, { lower }) => prod * lower, 1)])\n  // cons.push([...bounds.map(lu => lu.upper), -1, 0, bounds.reduce((prod, { upper }) => prod * upper, 1)])\n\n  let soln: any\n  const objective = [...bounds.map(_ => 0), 0, 1]\n  try {\n    // TODO: verify solution\n    soln = solveLP(objective, cons)\n  }\n  catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    throw e\n  }\n  return {\n    w: soln.slice(0, nVar).map((wi, i) => wi * scaleProd / boundScale[i]),\n    c: -scaleProd * soln[nVar],\n    err: scaleProd * soln[nVar + 1]\n  }\n}\n\nexport function maxWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = Object.entries(lin.w).reduce((dotProd, [statKey, w]) => dotProd + w * a.base[statKey], lin.c)\n  const maxTot = Object.entries(a.values).reduce((maxTotVal, [slotKey, slotArts]) => {\n    const maxSlot = slotArts.reduce((maxArt, art) => {\n      const artVal = Object.entries(lin.w).reduce((dotProd, [statkey, w]) => dotProd + w * art.values[statkey], 0)\n      return maxArt.v > artVal ? maxArt : { v: artVal, id: art.id }\n    }, { v: 0, id: '' })\n    maxTotVal.v += maxSlot.v\n    maxTotVal.ids.push(maxSlot.id)\n    return maxTotVal\n  }, { v: baseVal, ids: [] as string[] })\n  return maxTot.v\n}\n","import { constant, prod, cmp } from \"./utils\"\nimport { NumNode } from \"./type\"\nimport { optimize } from \"./optimization\"\nimport { mapFormulas } from \"./internal\"\nimport { ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { LinearForm, maxWeight, toLinearUpperBound } from \"./linearUpperBound\"\nimport { expandPoly, productPossible } from \"./expandPoly\"\n\nexport function statsUpperLower(a: ArtifactsBySlot) {\n  let minStats = Object.entries(a.values).reduce((pv, [slotKey, slotArts]) => {\n    let minStatSlot: DynStat = {}\n    slotArts.forEach(art => {\n      for (const statKey in art.values) minStatSlot[statKey] = Math.min(art.values[statKey], minStatSlot[statKey] ?? Infinity)\n    })\n    Object.entries(minStatSlot).forEach(([k, v]) => pv[k] = v + (pv[k] ?? 0))\n    return pv\n  }, { ...a.base })\n  let maxStats = Object.entries(a.values).reduce((pv, [slotKey, slotArts]) => {\n    let maxStatSlot: DynStat = {}\n    slotArts.forEach(art => {\n      for (const statKey in art.values) maxStatSlot[statKey] = Math.max(art.values[statKey], maxStatSlot[statKey] ?? 0)\n    })\n    Object.entries(maxStatSlot).forEach(([k, v]) => pv[k] = v + (pv[k] ?? 0))\n    return pv\n  }, { ...a.base })\n  return { statsMin: minStats, statsMax: maxStats }\n}\n\nexport function reduceFormula(f: NumNode[], lower: DynStat, upper: DynStat) {\n  const fixedStats = Object.fromEntries(Object.entries(lower).filter(([statKey, v]) => v === upper[statKey]))\n  let f2 = mapFormulas(f, n => n, n => {\n    if (n.operation === 'read' && n.path[1] in fixedStats) return constant(fixedStats[n.path[1]])\n    if (n.operation === 'threshold') {\n      const [branch, branchVal, ge, lt] = n.operands\n      if (branch.operation === 'read' && branchVal.operation === 'const') {\n        if (lower[branch.path[1]] >= branchVal.value) return n.operands[2]\n        if (upper[branch.path[1]] < branchVal.value) return n.operands[3]\n      }\n\n      if (ge.operation !== 'const') {\n        if (lt.operation === 'const' && lt.value === 0) {\n          return prod(cmp(branch, branchVal, 1, 0), ge)\n        }\n        throw Error('Threshold between non-const `pass` and non-zero `fail` not supported.')\n      }\n    }\n    return n\n  })\n\n  return optimize(f2, {})\n}\n\nfunction estimateMaximumOnce(func: NumNode, a: ArtifactsBySlot, { statsMin, statsMax }: { statsMin: DynStat, statsMax: DynStat }): { maxEst: number, lin: LinearForm } {\n  // const { statsMin, statsMax } = statsUpperLower(a)\n\n  if (func.operation === 'const') {\n    return { maxEst: func.value, lin: toLinearUpperBound(func, statsMin, statsMax) as LinearForm }\n  }\n  if (func.operation === 'read') {\n    return { maxEst: statsMax[func.path[1]], lin: toLinearUpperBound(func, statsMin, statsMax) as LinearForm }\n  }\n\n  function isVariable(n: NumNode) {\n    switch (n.operation) {\n      case 'read': case 'max': case 'min': case 'sum_frac': case 'threshold': return true\n      default: return false\n    }\n  }\n\n  let expandedFunc = expandPoly(func, isVariable)\n  let products = (expandedFunc.operands as NumNode[]).filter(productPossible)\n  let linUBs = products.flatMap(n => toLinearUpperBound(n, statsMin, statsMax))\n\n  let linUBtot = linUBs.reduce((pv, lin) => {\n    Object.entries(lin.w).forEach(([k, v]) => pv.w[k] = v + (pv.w[k] ?? 0))\n    return { w: pv.w, c: pv.c + lin.c, err: pv.err + lin.err }\n  }, { w: {}, c: 0, err: 0 })\n\n  return { maxEst: maxWeight(a, linUBtot), lin: linUBtot }\n}\n\n/**\n * Estimates maximum value across an array of formulas\n * @param f              Functions to maximize\n * @param a              Artifact set\n * @param cachedCompute  Optional Prior cached compute. If specified, will re-calculate `maxEst` assuming `lin, lower, upper` are correct.\n * @returns              CachedCompute\n */\ntype MaxEstQuery = { f: NumNode[], a: ArtifactsBySlot, cachedCompute?: undefined } | { f?: undefined, cachedCompute: { lin: LinearForm[], lower: DynStat, upper: DynStat }, a: ArtifactsBySlot }\nexport function estimateMaximum({ f, a, cachedCompute }: MaxEstQuery) {\n  // function estimateMaximum(f: NumNode[], a: ArtifactsBySlot, cachedCompute?: CachedCompute) {\n  if (cachedCompute === undefined) {\n    const { statsMin, statsMax } = statsUpperLower(a)\n    const est = f.map(fi => estimateMaximumOnce(fi, a, { statsMin, statsMax }))\n\n    return {\n      maxEst: est.map(({ maxEst }) => maxEst),\n      lin: est.map(({ lin }) => lin),\n      lower: statsMin,\n      upper: statsMax\n    }\n  }\n\n  let { lin, lower, upper } = cachedCompute\n  return {\n    maxEst: lin.map(l => maxWeight(a, l)),\n    lin, lower, upper\n  }\n}\n","import type { NumNode } from '../../../../Formula/type';\nimport { precompute } from '../../../../Formula/optimization';\nimport { toLinearUpperBound, maxWeight, LinearForm } from '../../../../Formula/linearUpperBound';\nimport { allArtifactSets, allSlotKeys, ArtifactSetKey } from '../../../../Types/consts';\nimport { estimateMaximum, reduceFormula, statsUpperLower } from '../../../../Formula/addedUtils';\nimport type { CachedCompute, InterimResult, Setup, Split, SplitWork, SubProblem, SubProblemNC, SubProblemWC } from './BackgroundWorker';\nimport { ArtifactsBySlot, countBuilds, DynStat, filterArts, RequestFilter } from './common';\nimport { cartesian, objectKeyMap, objectKeyValueMap } from '../../../../Util/Util';\n\ntype SplitRequest = {\n  threshold: number,\n  minCount: number,\n  maxIter: number,\n  filter?: RequestFilter,\n}\n\nexport class SplitWorker {\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: NumNode[]\n  artSet: Dict<ArtifactSetKey | 'uniqueKey', number[]>\n\n  subproblems: { count: number, subproblem: SubProblem }[] = []\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, optimizationTarget, filters, artSetExclusion }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.min = filters.map(x => x.min)\n    this.nodes = filters.map(x => x.value)\n    this.callback = callback\n\n    this.min.push(-Infinity)\n    this.nodes.push(optimizationTarget)\n\n    this.artSet = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n      if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n      return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n    })\n  }\n  addSubProblem(subproblem: SubProblem) {\n    const count = countBuilds(filterArts(this.arts, subproblem.filter))\n    if (count === 0) return\n    this.subproblems.push({ count, subproblem })\n  }\n  split({ threshold, minCount, maxIter, subproblem }: Split): SubProblem[] {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n\n    console.log('split', this.min[this.min.length - 1], {\n      todo: this.subproblems.length, buildsleft: this.subproblems.reduce((a, { count }) => a + count, 0)\n    })\n\n    let n = 0\n    while (n < maxIter && this.subproblems.length) {\n      n += 1\n      const { count, subproblem } = this.subproblems.pop()!\n      if (count <= minCount) return [subproblem]\n\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n      // console.log('[bnb iter]', this.min[this.min.length - 1], {\n      //   todo: this.filters.length, buildsleft: this.filters.reduce((a, { count }) => a + count, 0)\n      // })\n    }\n    return []\n  }\n  splitWork({ threshold, numSplits, subproblem }: SplitWork) {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n\n    while (this.subproblems.length > 0 && this.subproblems.length <= numSplits) {\n      const { subproblem } = this.subproblems.shift()!\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n    }\n    console.log('exit splitWork. Filters pre-exit', this.subproblems)\n    return this.subproblems.splice(0, numSplits).map(({ subproblem }) => subproblem)\n  }\n\n  splitBNB(threshold: number, subproblem: SubProblem) {\n    const a = filterArts(this.arts, subproblem.filter)\n\n    // 1. check constraints & simplify formula.\n    if (subproblem.cache === false) {\n      const { statsMin, statsMax } = statsUpperLower(a)\n\n      // 1a. Simplify formula, cut off always-satisfied constraints, and validate setExclusion stuff.\n      let sub2 = reduceSubProblem(subproblem, statsMin, statsMax)\n      if (sub2 === undefined) return []\n\n      // 1b. Check that remaining constraints are satisfiable\n      let f = [...sub2.constraints.map(({ value }) => value), sub2.optimizationTarget]\n      const cachedCompute = estimateMaximum({ f, a })\n      if (sub2.constraints.some(({ min }, i) => cachedCompute.maxEst[i] < min)) return []\n      if (cachedCompute.maxEst[cachedCompute.maxEst.length - 1] < threshold) return []\n\n      subproblem = { ...sub2, cache: true, cachedCompute }\n    }\n\n    // 2. Pick branching parameter\n    const { k } = pickBranch(a, subproblem.cachedCompute)\n    const branchVals = Object.fromEntries(Object.entries(a.values).map(([slotKey, arts]) => {\n      const vals = arts.map(a => a.values[k])\n      return [slotKey, (Math.min(...vals) + Math.max(...vals)) / 2]\n    }))\n    const branchArts = Object.fromEntries(Object.entries(a.values).map(([slotKey, arts]) => {\n      const above = arts.filter(art => art.values[k] < branchVals[slotKey] ? true : false)\n      const below = arts.filter(art => art.values[k] < branchVals[slotKey] ? false : true)\n      return [slotKey, [below, above]]\n    }))\n\n\n    const { optimizationTarget, cachedCompute } = subproblem\n    if (cachedCompute.maxEst[cachedCompute.maxEst.length - 1] < threshold) return []\n\n    // 3. Perform branching\n    // let { f, thr } = cachedCompute\n    // let cachedCompute = cachedCompute\n    let results = [] as { numBuilds: number, subproblem: SubProblemWC }[]\n    cartesian([0, 1], [0, 1], [0, 1], [0, 1], [0, 1]).forEach(([s1, s2, s3, s4, s5]) => {\n      let z = {\n        base: { ...a.base },\n        values: {\n          flower: branchArts.flower[s1],\n          plume: branchArts.plume[s2],\n          sands: branchArts.sands[s3],\n          goblet: branchArts.goblet[s4],\n          circlet: branchArts.circlet[s5],\n        }\n      }\n\n      let numBuilds = Object.values(z.values).reduce((tot, arts) => tot * arts.length, 1)\n      if (numBuilds === 0) return;\n      const { statsMin, statsMax } = statsUpperLower(z)\n\n      // 1a. Simplify formula, cut off always-satisfied constraints, and validate setExclusion stuff.\n      let sub2 = reduceSubProblem(subproblem, statsMin, statsMax)\n      if (sub2 === undefined) return;\n\n      // 1b. (fast) Check that existing constraints are satisfiable\n      let { maxEst } = estimateMaximum({ a: z, cachedCompute })\n      if (sub2.constraints.some(({ min }, i) => maxEst[i] < min)) return;\n      if (maxEst[maxEst.length - 1] < threshold) return;\n\n      // 1b. (slow) Check that existing constraints are satisfiable\n      let f = [...sub2.constraints.map(({ value }) => value), sub2.optimizationTarget]\n      let cc2 = estimateMaximum({ a: z, f })\n      if (sub2.constraints.some(({ min }, i) => cc2.maxEst[i] < min)) return;\n      if (cc2.maxEst[cc2.maxEst.length - 1] < threshold) return;\n\n      let newFilter: RequestFilter = objectKeyMap(allSlotKeys, slot => ({ kind: 'id' as 'id', ids: new Set(z.values[slot].map(art => art.id)) }))\n      results.push({\n        numBuilds,\n        subproblem: {\n          ...sub2,\n          filter: newFilter,\n          cache: true,\n          cachedCompute: cc2\n        }\n      })\n    })\n    results.sort((a, b) => b.numBuilds - a.numBuilds)\n    return results.map(({ subproblem }) => subproblem)\n  }\n\n\n\n}\n\ntype BNBSplitRequest = {\n  filter: RequestFilter,\n  bnbCompute?: CachedCompute\n}\ntype BNBHelper = {\n  a: ArtifactsBySlot,\n  statsMin: DynStat,\n  statsMax: DynStat,\n\n  threshold: number\n}\n\nfunction reduceSubProblem(sub: SubProblem, statsMin: DynStat, statsMax: DynStat): SubProblemNC | undefined {\n  const { optimizationTarget, constraints, artSetExclusion } = sub\n  let subnodes = [optimizationTarget, ...constraints.map(({ value }) => value)]\n  const submin = constraints.map(({ min }) => min)\n\n  subnodes = reduceFormula(subnodes, statsMin, statsMax)\n\n  // 1. Check for always-feasible constraints.\n  const [compute, mapping, buffer] = precompute(subnodes, n => n.path[1])\n  Object.entries(statsMin).forEach(([k, v]) => buffer[mapping[k] ?? 0] = v)\n  const result = compute()\n\n  const newOptTarget = subnodes.shift()!\n  const active = submin.map((m, i) => m > result[i])\n  active[0] = true  // Always preserve main dmg formula\n  const newConstraints = subnodes.map((value, i) => ({ value, min: submin[i] })).filter((_, i) => active[i])\n\n  // 2. Check for never-active and always-active ArtSetExcl constraints.\n  let newArtExcl = {} as Dict<ArtifactSetKey, number[]>\n  for (const [setKey, exclude] of Object.entries(artSetExclusion)) {\n    if (setKey === 'uniqueKey') {\n      // let minSets = Object.fromEntries(Object.entries(statsMin).filter(([statKey, v]) => v > 0 && allArtifactSets.includes(statKey as any)))\n      // let numSets = Object.keys(minSets).length\n      // let numSlotsUsed = Object.values(minSets).reduce((a, b) => a + b)\n\n      // TODO: Check and exclude rainbow bullshit.\n      newArtExcl[setKey] = exclude\n      continue\n    }\n    const reducedExcl = exclude.filter(n => statsMin[setKey] <= n && n <= statsMax[setKey])        // Cut away never-active\n    if (reducedExcl.includes(statsMin[setKey]) && reducedExcl.includes(statsMax[setKey])) return;  // Always active.\n    if (reducedExcl.length > 0) newArtExcl[setKey] = reducedExcl\n  }\n\n  return {\n    cache: false,\n    optimizationTarget: newOptTarget,\n    constraints: newConstraints,\n    artSetExclusion: newArtExcl,\n\n    filter: sub.filter\n  }\n\n  // const newArtExcl = Object.entries(artSetExclusion)\n  //   .reduce((ret, [setKey, exclude]) => {\n  //     if (setKey === 'uniqueKey') {\n  //       let minSets = Object.fromEntries(Object.entries(statsMin).filter(([statKey, v]) => v > 0 && allArtifactSets.includes(statKey as any)))\n  //       let numSets = Object.keys(minSets).length\n  //       let numSlotsUsed = Object.values(minSets).reduce((a, b) => a + b)\n  //       ret[setKey] = exclude.filter(v => {\n  //         // TODO: logic for checking if never active\n  //         return true\n  //       })\n  //       return ret\n  //     }\n  //     const reducedExcl = [...exclude].filter(n => statsMin[setKey] <= n && n <= statsMax[setKey])\n  //     if (reducedExcl.length > 0) ret[setKey] = reducedExcl\n  //     return ret\n  //   }, {} as Dict<ArtifactSetKey | 'uniqueKey', number[]>\n  //   )\n\n  // 3. Check for always-active ArtSetExcle constraints. (problem is never feasible)\n}\n\n/**\n * Decides how to split between different branches.\n * TODO: Branch values should also be calculated & returned here\n * @param a     Artifact set\n * @param lin   Linear form from compute\n * @returns     The key to branch on.\n */\nfunction pickBranch(a: ArtifactsBySlot, { lin }: CachedCompute) {\n  // TODO: Experiment with\n  let linToConsider = lin[lin.length - 1]\n  let keysToConsider = Object.keys(linToConsider.w)\n\n  let shatterOn = { k: '', heur: -1 }\n  keysToConsider.forEach(k => {\n    const postShatterRangeReduction = Object.entries(a.values).reduce((rangeReduc, [slot, arts]) => {\n      const vals = arts.map(a => a.values[k])\n      const minv = Math.min(...vals)\n      const maxv = Math.max(...vals)\n      if (minv === maxv) return rangeReduc\n\n      const branchVal = (minv + maxv) / 2\n      const glb = Math.max(...vals.filter(v => v <= branchVal))\n      const lub = Math.min(...vals.filter(v => v > branchVal))\n      return rangeReduc + Math.min(maxv - glb, lub - minv)\n    }, 0)\n    const heur = linToConsider.w[k] * postShatterRangeReduction\n    if (heur > shatterOn.heur) shatterOn = { k, heur }\n  })\n\n  if (shatterOn.k === '') throw Error('Shatter broke...')\n  return shatterOn\n}\n\n\n\n\n\n\n\n\n\n\n\nfunction splitBySetOrID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\n  const arts = filterArts(_arts, filter)\n\n  const candidates = allSlotKeys\n    .map(slot => ({ slot, sets: new Set(arts.values[slot].map(x => x.set)) }))\n    .filter(({ sets }) => sets.size > 1)\n  if (!candidates.length)\n    return splitByID(arts, filter, limit)\n  const { sets, slot } = candidates.reduce((a, b) => a.sets.size < b.sets.size ? a : b)\n  return [...sets].map(set => ({ ...filter, [slot]: { kind: \"required\", sets: new Set([set]) } }))\n}\nfunction splitByID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\n  const arts = filterArts(_arts, filter)\n  const count = countBuilds(arts)\n\n  const candidates = allSlotKeys\n    .map(slot => ({ slot, length: arts.values[slot].length }))\n    .filter(x => x.length > 1)\n  const { slot, length } = candidates.reduce((a, b) => a.length < b.length ? a : b)\n\n  const numChunks = Math.ceil(count / limit)\n  const boundedNumChunks = Math.min(numChunks, length)\n  const chunk = Array(boundedNumChunks).fill(0).map(_ => new Set<string>())\n  arts.values[slot].forEach(({ id }, i) => chunk[i % boundedNumChunks].add(id))\n  return chunk.map(ids => ({ ...filter, [slot]: { kind: \"id\", ids } }))\n}\n//\n","import { LinearForm } from '../../../../Formula/linearUpperBound'\nimport { NumNode } from '../../../../Formula/type'\nimport { ArtifactSetKey } from '../../../../Types/consts'\nimport { assertUnreachable } from '../../../../Util/Util'\nimport { ArtSetExclusion } from './BuildSetting'\nimport { ArtifactsBySlot, artSetPerm, Build, countBuilds, DynStat, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\nimport { ComputeWorker } from \"./ComputeWorker\"\nimport { SplitWorker } from \"./SplitWorker\"\n\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nonmessage = ({ data }: { data: WorkerCommand }) => {\n  const command = data.command\n  let result: WorkerResult\n  switch (command) {\n    case \"setup\":\n      id = data.id\n      const callback = (interim: InterimResult) => postMessage({ id, ...interim })\n      splitWorker = new SplitWorker(data, callback)\n      computeWorker = new ComputeWorker(data, callback)\n      result = { command: \"iterate\" }\n      break\n    case \"split\":\n      result = { command: \"split\", subproblems: splitWorker.split(data), ready: splitWorker.subproblems.length === 0 }\n      break\n    case \"splitwork\":\n      result = { command: 'split', subproblems: splitWorker.splitWork(data), ready: splitWorker.subproblems.length === 0 }\n      break\n    case \"iterate\":\n      const { threshold, subproblem } = data\n      computeWorker.compute(threshold, subproblem)\n      result = { command: \"iterate\" }\n      break\n    case \"finalize\":\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      result = { command: \"finalize\", builds, plotData }\n      break\n    // case \"count\":\n    //   {\n    //     const { exclusion } = data, arts = computeWorker.arts\n    //     const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\n    //     let counts = data.arts.map(_ => 0)\n    //     for (const perm of setPerm)\n    //       data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\n    //     result = { command: \"count\", counts }\n    //     break\n    //   }\n    default: assertUnreachable(command)\n  }\n  postMessage({ id, ...result });\n}\n\n\nexport type SubProblem = SubProblemNC | SubProblemWC\nexport type SubProblemNC = {\n  cache: false,\n  optimizationTarget: NumNode,\n  constraints: { value: NumNode, min: number }[],\n  artSetExclusion: Dict<ArtifactSetKey | 'uniqueKey', number[]>,\n\n  filter: RequestFilter,\n}\nexport type SubProblemWC = {\n  cache: true,\n  optimizationTarget: NumNode,\n  constraints: { value: NumNode, min: number }[],\n  artSetExclusion: Dict<ArtifactSetKey | 'uniqueKey', number[]>,\n\n  filter: RequestFilter,\n  cachedCompute: CachedCompute\n}\nexport type CachedCompute = {\n  maxEst: number[],\n  lin: LinearForm[],\n  lower: DynStat,\n  upper: DynStat\n}\n\nexport type WorkerCommand = Setup | Split | SplitWork | Iterate | Finalize\n// export type WorkerResult = InterimResult | SplitResult | IterateResult | FinalizeResult | CountResult\nexport type WorkerResult = InterimResult | SplitResult | IterateResult | FinalizeResult\n\nexport interface Setup {\n  command: \"setup\"\n\n  id: number\n  arts: ArtifactsBySlot\n\n  optimizationTarget: NumNode\n  filters: { value: NumNode, min: number }[]\n  artSetExclusion: ArtSetExclusion\n  plotBase: NumNode | undefined,\n  maxBuilds: number\n}\nexport interface Split {\n  command: \"split\"\n  threshold: number\n  minCount: number\n  maxIter: number\n\n  subproblem?: SubProblem\n}\nexport interface SplitWork {\n  command: \"splitwork\"\n  threshold: number\n  numSplits: number\n\n  subproblem?: SubProblem\n}\nexport interface Iterate {\n  command: \"iterate\"\n  threshold: number\n\n  subproblem: SubProblem\n}\nexport interface Finalize {\n  command: \"finalize\"\n}\n\n\n// export interface Count {\n//   command: \"count\"\n//   arts: ArtifactsBySlot[]\n//   exclusion: ArtSetExclusion\n// }\n\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface IterateResult {\n  command: \"iterate\"\n}\nexport interface SplitResult {\n  command: \"split\"\n  ready: boolean\n  subproblems: SubProblem[]\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface CountResult {\n  command: \"count\"\n  counts: number[]\n}\n"],"names":["obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","name","from","test","isArray","iter","Symbol","iterator","TypeError","_i","_s","_e","_arr","_n","_d","next","done","err","objPathValue","console","error","reduce","a","k","objectKeyMap","map","fromEntries","assertUnreachable","Error","cartesian","q","b","flatMap","d","e","flat","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","_e2","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","constant","NaN","percent","info","operation","operands","Number","MAX_VALUE","Infinity","sum","values","intoOps","prod","cmp","v1","v2","pass","fail","intoV","cmpNode","path","every","ai","used","some","bj","j","includes","cyrb53","str","ch","seed","h1","h2","charCodeAt","Math","imul","hashNode","hsh","ni","mapFormulas","formulas","topDownMap","bottomUpMap","visiting","Set","topDownMapped","Map","bottomUpMapped","check","formula","topDown","get","bottomUp","has","add","arrayEqual","traverse","delete","set","result","undefined","allCommutativeMonoidOperations","min","x","max","mul","allOperations","res","sum_frac","threshold","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","precompute","binding","uniqueReadStrings","uniqueNumbers","mapping","visited","forEachNodes","_","type","accu","ins","op","locations","readStrings","readOffset","constValues","computations","offset","ref","node","out","buff","fill","buffer","Float64Array","number","copyList","src","copyFormula","dst","flattened","dep","elementCounts","array","wrap","common","counts","factored","count","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","entries","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","origin","data","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","smallest","match","unmatch","list","reset","nextContext","allSlotKeys","allArtifactSets","filterArts","arts","filters","base","slot","kind","art","ids","id","sets","countBuilds","_count","ComputeWorker","callback","optimizationTarget","plotBase","maxBuilds","builds","buildValues","plotData","nodes","interimReport","refresh","command","tested","failed","skipped","this","newThreshold","subproblem","constraints","artSetExclusion","self","preArts","totalCount","nodesReduced","compute","compute2","mapping2","buffer2","sort","key2","cache","i2","permute","oddKeys","result2","abs","log","passArtExcl","setKey","vals","bufloc","v","size","m","build","artifactIds","plot","current","force","plots","scale","round","mergePlot","foldSum","constVal","pv","foldProd","gatherSumOfProds","products","isVar","varMap","primes","varCounter","lookup","z","BigInt","ix","coeff","rhs","ops","ix2","expandPoly","ns","varExprs","vars","nonVars","productPossible","countSlotUsage","branch","pivot","A","ij","Aij","Ah","h","Ahk","findPiv1","r","c","minloc","findPiv2","minMax","lower","upper","minval","toLinearUpperBound","w","u","lpf","purePolyForm","bval","ge","lt","slope","flippedResOp","flipOps","resf","handleResArg","rop","cop","varop","constop","thresh","minVal","maxVal","em","denom","minEM","maxEM","loc","sqrt","below","toLUB","bounds","nVar","boundScale","scaleProd","soln","cons","coords","objective","Ab","rows","cols","tableau","Ai","cj","ijTrack","t","targ","side","ncol","backtrack","solveLP","wi","lub","ret","maxWeight","lin","baseVal","dotProd","statKey","maxTotVal","maxSlot","maxArt","artVal","statkey","statsUpperLower","statsMin","slotArts","minStatSlot","statsMax","maxStatSlot","estimateMaximum","cachedCompute","est","fi","func","maxEst","linUBtot","estimateMaximumOnce","l","splitWorker","computeWorker","SplitWorker","items","artSet","subproblems","minCount","maxIter","addSubProblem","todo","buildsleft","pop","splitBNB","subp","numSplits","shift","splice","sub2","reduceSubProblem","linToConsider","keysToConsider","shatterOn","heur","postShatterRangeReduction","rangeReduc","minv","maxv","branchVal","glb","pickBranch","branchVals","slotKey","branchArts","above","results","s1","s2","s3","s4","s5","flower","plume","sands","goblet","circlet","numBuilds","tot","cc2","newFilter","sub","subnodes","submin","fixedStats","reduceFormula","newOptTarget","active","newConstraints","newArtExcl","exclude","reducedExcl","onmessage","interim","postMessage","split","ready","splitWork"],"sourceRoot":""}