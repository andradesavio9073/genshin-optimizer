{"version":3,"file":"static/js/BackgroundWorker.af0b638a.worker.js","mappings":"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BACA,mBACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,iBACA,iBACA,WACA,aACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,eACA,gBCjMF,SAASC,EAASC,EAAkBC,GAAmG,IAA5EC,EAA2E,wDAC9HC,EAAc,IAAInG,IAAgBoG,EAAiB,IAAIpG,IAE7D,SAASqG,EAAMC,EAAeC,GACxBA,EAAUJ,EAAY9F,IAAIiG,GACzBA,EAAKtH,SAASlC,SAAQ,SAAA0J,GACzB,IAAMxB,EAAKwB,EACXL,EAAY/F,IAAI4E,IAAOoB,EAAe/F,IAAI2E,MAI9C,IAAMyB,EAAU,IAAIzG,IA6BpB,GA3BAL,EAAaqG,GAAO,SAAAU,OAAU,SAAAnJ,GAC5B,IAAMwB,EAAYxB,EAAEwB,UACpB,OAAQA,GACN,IAAK,OACH,GAAe,WAAXxB,EAAEmC,MAAmC,QAAdnC,EAAEkC,KAAK,IAA2B,QAAXlC,EAAEgI,KAClD,MAAM,IAAI7G,MAAJ,4BAA+BK,EAA/B,yBAAyDxB,EAAEkC,KAA3D,iCACRgH,EAAQpG,IAAI9C,EAAEkC,KAAK,IACnB4G,EAAM9I,GAAG,GACT,MACF,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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/background.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj, keys, validate, cb) {\n  if (validate(obj)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map(t => map(t))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap(d => b.map(e => [d, [e]].flat())), [[]] as T[][])\n}\n","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\n/** v1 >= v2 ? pass : fail */\nexport function cmp(v1: Num, v2: Num, pass: Num, fail: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = Array(offset).fill(0)\n  buffer.forEach((_, i, array) => array[i] = NaN)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return values => {\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","import { optimize, precompute } from '../../../../Formula/optimization';\nimport type { NumNode } from '../../../../Formula/type';\nimport type { MainStatKey, SubstatKey } from '../../../../Types/artifact';\nimport { ArtifactSetKey, SlotKey } from '../../../../Types/consts';\nimport { countBuilds, filterArts, mergePlot, pruneAll } from './common';\n\nlet id: string\nlet builds: Build[]\nlet buildValues: number[] | undefined\nlet plotData: PlotData | undefined\nlet threshold: number\n\ntype WorkerStat = {\n  arts: ArtifactsBySlot\n  nodes: NumNode[]\n\n  maxBuilds: number\n  min: number[]\n\n  callback: (interim: InterimResult) => void\n}\nlet shared: WorkerStat = undefined as any\n\nexport function setup(msg: Setup, callback: WorkerStat[\"callback\"]): RequestResult {\n  shared = { ...msg } as any\n  shared.nodes = msg.filters.map(x => x.value)\n  shared.min = msg.filters.map(x => x.min)\n  shared.callback = callback\n  shared.nodes.push(msg.optimizationTarget)\n  if (msg.plotBase) {\n    plotData = {}\n    shared.nodes.push(msg.plotBase)\n  }\n  id = msg.id\n  builds = []\n  buildValues = undefined\n  threshold = -Infinity\n\n  return { command: \"request\", id }\n}\n\nexport function request({ threshold: newThreshold, filter: filters }: Request): RequestResult & { total: number } {\n  if (threshold > newThreshold) threshold = newThreshold\n  let preArts = filterArts(shared.arts, filters)\n  const totalCount = countBuilds(preArts)\n\n  let nodes = optimize(shared.nodes, {}, _ => false);\n  ({ nodes, arts: preArts } = pruneAll(nodes, shared.min, preArts, shared.maxBuilds, new Set(), {\n    pruneArtRange: true, pruneNodeRange: true,\n  }))\n  const compute = precompute(nodes, f => f.path[1])\n  const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\n\n  const ids: string[] = Array(arts.length).fill(\"\")\n  let count = { build: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\n\n  function permute(i: number, stats: Stats) {\n    if (i < 0) {\n      const result = compute(stats)\n      if (shared.min.every((m, i) => (m <= result[i]))) {\n        const value = result[shared.min.length]\n        let build: Build | undefined\n        if (value >= threshold) {\n          build = { value, artifactIds: [...ids] }\n          builds.push(build)\n        }\n        if (plotData) {\n          const x = result[shared.min.length + 1]\n          if (!plotData[x] || plotData[x]!.value < value) {\n            if (!build) build = { value, artifactIds: [...ids] }\n            build.plot = x\n            plotData[x] = build\n          }\n        }\n      }\n      else count.failed += 1\n      return\n    }\n    arts[i].forEach(art => {\n      ids[i] = art.id\n\n      const newStats = { ...stats }\n      Object.entries(art.values).forEach(([key, value]) =>\n        newStats[key] = (newStats[key] ?? 0) + value)\n\n      permute(i - 1, newStats)\n    })\n    if (i === 0) {\n      count.build += arts[0].length\n      if (count.build > 8192)\n        interimReport(count)\n    }\n  }\n\n  permute(arts.length - 1, preArts.base)\n  interimReport(count)\n  return { command: \"request\", id, total: totalCount }\n}\nexport function finalize(): FinalizeResult {\n  refresh(true)\n  return { command: \"finalize\", id, builds, plotData }\n}\n\nexport let interimReport = (count: { build: number, failed: number, skipped: number }): void => {\n  refresh(false)\n  shared.callback({\n    command: \"interim\", id, buildValues,\n    buildCount: count.build, failedCount: count.failed, skippedCount: count.skipped\n  })\n  buildValues = undefined\n  count.build = 0\n  count.failed = 0\n  count.skipped = 0\n}\nfunction refresh(force: boolean): void {\n  if (plotData && Object.keys(plotData).length >= 100000)\n    plotData = mergePlot([plotData])\n\n  if (builds.length >= 100000 || force) {\n    builds = builds\n      .sort((a, b) => b.value - a.value)\n      .slice(0, shared.maxBuilds)\n    buildValues = builds.map(x => x.value)\n    threshold = Math.max(threshold, buildValues[shared.maxBuilds - 1] ?? -Infinity)\n  }\n}\n\ntype Stats = { [key in MainStatKey | SubstatKey]?: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\n\nexport type Command = Setup | Request | Finalize\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\nexport type DynStat = { [key in string]: number }\nexport interface Setup {\n  command: \"setup\"\n\n  id: string\n  arts: ArtifactsBySlot\n\n  optimizationTarget: NumNode\n  filters: { value: NumNode, min: number }[]\n  plotBase: NumNode | undefined,\n  maxBuilds: number\n}\nexport interface Request {\n  command: \"request\"\n  threshold: number\n  filter: RequestFilter\n}\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport type PlotData = Dict<number, Build>\n\nexport type ChartData = {\n  valueNode: NumNode,\n  plotNode: NumNode,\n  data: Build[]\n}\nexport interface Finalize {\n  command: \"finalize\"\n}\n\nexport type WorkerResult = InterimResult | RequestResult | FinalizeResult | DebugMsg\nexport interface InterimResult {\n  command: \"interim\"\n  id: string\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  buildCount: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failedCount: number\n  skippedCount: number\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  id: string\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface RequestResult {\n  command: \"request\"\n  id: string\n}\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\nexport interface DebugMsg {\n  command: \"debug\"\n  id: string\n  value: any\n}\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allReactionModes = [\"hydro_vaporize\", \"pyro_vaporize\", \"pyro_melt\", \"cryo_melt\",] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  \"DefendersWill\",\n  \"EchoesOfAnOffering\",\n  \"EmblemOfSeveredFate\",\n  \"Gambler\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  \"HuskOfOpulentDreams\",\n  \"Instructor\",\n  \"Lavawalker\",\n  \"LuckyDog\",\n  \"MaidenBeloved\",\n  \"MartialArtist\",\n  \"NoblesseOblige\",\n  \"OceanHuedClam\",\n  \"PaleFlame\",\n  \"PrayersForDestiny\",\n  \"PrayersForIllumination\",\n  \"PrayersForWisdom\",\n  \"PrayersToSpringtime\",\n  \"ResolutionOfSojourner\",\n  \"RetracingBolide\",\n  \"Scholar\",\n  \"ShimenawasReminiscence\",\n  \"TenacityOfTheMillelith\",\n  \"TheExile\",\n  \"ThunderingFury\",\n  \"Thundersoother\",\n  \"TinyMiracle\",\n  \"TravelingDoctor\",\n  \"VermillionHereafter\",\n  \"ViridescentVenerer\",\n  \"WanderersTroupe\",\n] as const\nexport const allCharacterKeys = [\n  \"Albedo\",\n  \"Amber\",\n  \"Barbara\",\n  \"Beidou\",\n  \"Bennett\",\n  \"Chongyun\",\n  \"Diluc\",\n  \"Diona\",\n  \"Fischl\",\n  \"Ganyu\",\n  \"HuTao\",\n  \"Jean\",\n  \"Kaeya\",\n  \"Keqing\",\n  \"Klee\",\n  \"KujouSara\",\n  \"Lisa\",\n  \"Mona\",\n  \"Ningguang\",\n  \"Noelle\",\n  \"Qiqi\",\n  \"Razor\",\n  \"Sucrose\",\n  \"Tartaglia\",\n  \"Traveler\",\n  \"RaidenShogun\",\n  \"Venti\",\n  \"Xiangling\",\n  \"Xiao\",\n  \"Xingqiu\",\n  \"Xinyan\",\n  \"Rosaria\",\n  \"Yanfei\",\n  \"Eula\",\n  \"KaedeharaKazuha\",\n  \"KamisatoAyaka\",\n  \"Sayu\",\n  \"Shenhe\",\n  \"Yoimiya\",\n  \"Aloy\",\n  \"SangonomiyaKokomi\",\n  \"Thoma\",\n  \"Gorou\",\n  \"AratakiItto\",\n  \"YaeMiko\",\n  \"YunJin\",\n  \"Zhongli\",\n  \"KamisatoAyato\",\n  \"Yelan\",\n  // \"KukiShinobu\"\n] as const\n\nexport const allWeaponSwordKeys = [\n  \"AmenomaKageuchi\",\n  \"AquilaFavonia\",\n  \"BlackcliffLongsword\",\n  \"CinnabarSpindle\",\n  \"CoolSteel\",\n  \"DarkIronSword\",\n  \"DullBlade\",\n  \"FavoniusSword\",\n  \"FesteringDesire\",\n  \"FilletBlade\",\n  \"FreedomSworn\",\n  \"HaranGeppakuFutsu\",\n  \"HarbingerOfDawn\",\n  \"IronSting\",\n  \"LionsRoar\",\n  \"MistsplitterReforged\",\n  \"PrimordialJadeCutter\",\n  \"PrototypeRancour\",\n  \"RoyalLongsword\",\n  \"SacrificialSword\",\n  \"SilverSword\",\n  \"SkyriderSword\",\n  \"SkywardBlade\",\n  \"SummitShaper\",\n  \"SwordOfDescension\",\n  \"TheAlleyFlash\",\n  \"TheBlackSword\",\n  \"TheFlute\",\n  \"TravelersHandySword\",\n] as const\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\n\nexport const allWeaponClaymoreKeys = [\n  \"Akuoumaru\",\n  \"BlackcliffSlasher\",\n  \"BloodtaintedGreatsword\",\n  \"DebateClub\",\n  \"FavoniusGreatsword\",\n  \"FerrousShadow\",\n  \"KatsuragikiriNagamasa\",\n  \"LithicBlade\",\n  \"LuxuriousSeaLord\",\n  \"OldMercsPal\",\n  \"PrototypeArchaic\",\n  \"Rainslasher\",\n  \"RedhornStonethresher\",\n  \"RoyalGreatsword\",\n  \"SacrificialGreatsword\",\n  \"SerpentSpine\",\n  \"SkyriderGreatsword\",\n  \"SkywardPride\",\n  \"SnowTombedStarsilver\",\n  \"SongOfBrokenPines\",\n  \"TheBell\",\n  \"TheUnforged\",\n  \"WasterGreatsword\",\n  \"Whiteblind\",\n  \"WhiteIronGreatsword\",\n  \"WolfsGravestone\",\n] as const\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\n\nexport const allWeaponPolearmKeys = [\n  \"BeginnersProtector\",\n  \"BlackcliffPole\",\n  \"BlackTassel\",\n  \"CalamityQueller\",\n  \"CrescentPike\",\n  \"Deathmatch\",\n  \"DragonsBane\",\n  \"DragonspineSpear\",\n  \"EngulfingLightning\",\n  \"FavoniusLance\",\n  \"Halberd\",\n  \"IronPoint\",\n  \"KitainCrossSpear\",\n  \"LithicSpear\",\n  \"PrimordialJadeWingedSpear\",\n  \"PrototypeStarglitter\",\n  \"RoyalSpear\",\n  \"SkywardSpine\",\n  \"StaffOfHoma\",\n  \"TheCatch\",\n  \"VortexVanquisher\",\n  \"WavebreakersFin\",\n  \"WhiteTassel\",\n] as const\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\n\nexport const allWeaponBowKeys = [\n  \"AlleyHunter\",\n  \"AmosBow\",\n  \"AquaSimulacra\",\n  \"BlackcliffWarbow\",\n  \"CompoundBow\",\n  \"ElegyForTheEnd\",\n  \"FadingTwilight\",\n  \"FavoniusWarbow\",\n  \"Hamayumi\",\n  \"HuntersBow\",\n  \"Messenger\",\n  \"MitternachtsWaltz\",\n  \"MouunsMoon\",\n  \"PolarStar\",\n  \"Predator\",\n  \"PrototypeCrescent\",\n  \"RavenBow\",\n  \"RecurveBow\",\n  \"RoyalBow\",\n  \"Rust\",\n  \"SacrificialBow\",\n  \"SeasonedHuntersBow\",\n  \"SharpshootersOath\",\n  \"SkywardHarp\",\n  \"Slingshot\",\n  \"TheStringless\",\n  \"TheViridescentHunt\",\n  \"ThunderingPulse\",\n  \"WindblumeOde\",\n] as const\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\n\nexport const allWeaponCatalystKeys = [\n  \"ApprenticesNotes\",\n  \"BlackcliffAgate\",\n  \"DodocoTales\",\n  \"EmeraldOrb\",\n  \"EverlastingMoonglow\",\n  \"EyeOfPerception\",\n  \"FavoniusCodex\",\n  \"Frostbearer\",\n  \"HakushinRing\",\n  \"KagurasVerity\",\n  \"LostPrayerToTheSacredWinds\",\n  \"MagicGuide\",\n  \"MappaMare\",\n  \"MemoryOfDust\",\n  \"OathswornEye\",\n  \"OtherworldlyStory\",\n  \"PocketGrimoire\",\n  \"PrototypeAmber\",\n  \"RoyalGrimoire\",\n  \"SacrificialFragments\",\n  \"SkywardAtlas\",\n  \"SolarPearl\",\n  \"TheWidsith\",\n  \"ThrillingTalesOfDragonSlayers\",\n  \"TwinNephrite\",\n  \"WineAndSong\",\n] as const\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type ReactionModeKey = typeof allReactionModes[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\n","import { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap } from \"../../../../Util/Util\";\nimport type { ArtifactBuildData, ArtifactsBySlot, Build, DynStat, PlotData, RequestFilter } from \"./background\";\n\ntype DynMinMax = { [key in string]: MinMax }\ntype MinMax = { min: number, max: number }\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, keepArtifacts: Set<ArtifactSetKey>, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, keepArtifacts)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\n\n  function visit(node: NumNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(_op => {\n      const op = _op as NumNode\n      affineNodes.has(op) && topLevelAffine.add(op)\n    })\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const operation = f.operation\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\":\n        if (typeof f.value === \"string\" || f.value === undefined)\n          throw new Error(`Found constant ${f.value} while compacting`)\n        visit(f as NumNode, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\n    Object.keys(arts.base).length === dynKeys.size)\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, keepArtifacts: Set<ArtifactSetKey>): ArtifactsBySlot {\n  let progress = false\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          (!keepArtifacts.has(art.set!) || art.set === other.set))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return constant(0)\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter(key => arts.every(art => art.values[key]))\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\n  const range = new Map<NumNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, _f => {\n    const f = _f as NumNode\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"subscript\": current = computeMinMax(f.list); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = computeMinMax([0])\n        else current = computeMinMax([0], [operands[2]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      case \"data\": case \"lookup\": case \"match\":\n        throw new Error(`Unsupported ${operation} node`)\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n","import { Command, setup, request, finalize } from \"./background\"\nimport { assertUnreachable } from '../../../../Util/Util';\n\nonmessage = ({ data }: { data: Command }) => {\n  const command = data.command\n  switch (command) {\n    case \"setup\": postMessage(setup(data, interim => postMessage(interim, undefined))); break\n    case \"request\": postMessage(request(data)); break\n    case \"finalize\": postMessage(finalize()); break\n    default: assertUnreachable(command)\n  }\n}\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","iter","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","objPathValue","console","error","reduce","a","k","objectKeyMap","map","fromEntries","objectMap","fn","entries","v","assertUnreachable","Error","constant","NaN","percent","info","operation","operands","Number","MAX_VALUE","Infinity","min","values","intoOps","max","customRead","path","type","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","b","undefined","every","allCommutativeMonoidOperations","x","Math","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","wrap","common","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","v1","v2","match","unmatch","list","accu","reset","nextContext","id","builds","buildValues","plotData","allSlotKeys","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","_","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","offsets","baseValue","pruneOrder","numTop","keepArtifacts","progress","newList","art","other","greaterEqual","greater","some","pruneArtRange","minimum","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","pruneNodeRange","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","range","reads","_f","computeMinMax","c","sum","minMaxes","countBuilds","_count","shared","request","newThreshold","filters","preArts","kind","ids","sets","filterArts","totalCount","optimize","forced","should","deps","newArts","newNodes","pruneAll","maxBuilds","compute","binding","uniqueReadStrings","uniqueNumbers","mapping","ins","locations","readStrings","readOffset","constValues","computations","str","offset","ref","out","buff","buffer","number","copyList","src","copyFormula","dst","precompute","sort","build","failed","skipped","permute","stats","m","artifactIds","plot","newStats","interimReport","command","refresh","callback","buildCount","failedCount","skippedCount","force","plots","scale","round","mergePlot","onmessage","msg","postMessage","interim","optimizationTarget","plotBase"],"sourceRoot":""}