{"version":3,"file":"static/js/BackgroundWorker.f36f17cc.worker.js","mappings":"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xBA,EAGT,IAAMoF,EAAU,CAAEJ,KAAM,CAAC/D,GAAegE,UAAW,IAAI9F,KAGvD,OAFA+F,EAAenF,IAAIqF,EAAS,IAAIjG,KAChC+F,EAAe1F,IAAIuF,GAAShF,IAAIkB,EAAcmE,GACvCvG,EAAS/C,KAAI,SAAAuE,GAAC,OAAI8E,EAAK9E,EAAG+E,MAG5B,IC5ZMqB,EAAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAIrDC,GAFkB,CAAI,YAAJ,OADJ,CAAC,QAAS,MAAO,UAAW,QAAS,OAAQ,SAGzC,CAC7B,aACA,eACA,YACA,kBACA,uBACA,aACA,uBACA,gBACA,qBACA,sBACA,UACA,mBACA,eACA,sBACA,aACA,aACA,WACA,gBACA,gBACA,iBACA,gBACA,YACA,oBACA,yBACA,mBACA,sBACA,wBACA,kBACA,UACA,yBACA,yBACA,WACA,iBACA,iBACA,cACA,kBACA,sBACA,qBACA,oBAgNwB,UAzJQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,iBACA,iBACA,WACA,aACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,g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","sources":["../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","Util/Util.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","Formula/expandPoly.ts","Formula/solveLP_simplex.ts","Formula/linearUpperBound.ts","Formula/addedUtils.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/SplitWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\nexport function getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n}\nexport function getRandomArbitrary(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * Assumes that the object entries are all primitives + objects\n * shallow copy the object,\n * deep copy the\n * @param obj\n * @returns\n */\nexport function deepClone<T>(obj: T): T {\n  if (!obj) return obj\n  if (!Object.keys(obj).length) return {} as T\n  const ret = { ...obj }\n  Object.entries(obj).forEach(([k, v]: any) => {\n    if (typeof v !== \"object\") return\n    ret[k] = JSON.parse(JSON.stringify(v))\n  })\n  return ret\n}\n\nexport const clamp = (val, low, high) => {\n  if (val < low) return low;\n  if (val > high) return high;\n  return val\n}\nexport const getArrLastElement = (arr) =>\n  arr.length ? arr[arr.length - 1] : null\n\nexport const clamp01 = (val) => clamp(val, 0, 1)\nexport const clampPercent = (val) => clamp(val, 0, 100)\n\n//use to pretty print timestamps, or anything really.\nexport function strPadLeft(string, pad, length) {\n  return (new Array(length + 1).join(pad) + string).slice(-length);\n}\n\n//fuzzy compare strings. longer the distance, the higher the mismatch.\nexport function hammingDistance(str1, str2) {\n  var dist = 0;\n  str1 = str1.toLowerCase();\n  str2 = str2.toLowerCase();\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\n    let match = true\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\n      match = false\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\n      match = true\n    if (!match) dist++\n  }\n  return dist;\n}\n\n//multiplies every numerical value in the obj by a multiplier.\nexport function objMultiplication(obj, multi) {\n  if (multi === 1) return obj\n  Object.keys(obj).forEach((prop: any) => {\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\n  })\n  return obj\n}\n\n//assign obj.[keys...] = value\nexport function layeredAssignment(obj, keys: readonly string[], value) {\n  keys.reduce((accu, key, i, arr) => {\n    if (i === arr.length - 1) return (accu[key] = value)\n    if (!accu[key]) accu[key] = {}\n    return accu[key]\n  }, obj)\n  return obj\n}\n//get the value in a nested object, giving array of path\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\n  if (!obj || !keys) return undefined;\n  !Array.isArray(keys) && console.error(keys)\n  return keys.reduce((a, k) => a?.[k], obj)\n}\n//delete the value denoted by the path. Will also delete empty objects as well.\nexport function deletePropPath(obj, path) {\n  const tempPath = [...path]\n  const lastKey = tempPath.pop()\n  const objPathed = objPathValue(obj, tempPath)\n  delete objPathed?.[lastKey];\n}\n\nexport function objClearEmpties(o) {\n  for (const k in o) {\n    if (typeof o[k] !== \"object\") continue\n    objClearEmpties(o[k])\n    if (!Object.keys(o[k]).length) delete o[k];\n  }\n}\nexport function crawlObject(obj, keys, validate, cb) {\n  if (validate(obj)) cb(obj, keys)\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\n}\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\n\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\n  return typeof value === \"function\" ? (value as any)(arg) : value\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\n}\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\n  return Object.fromEntries(items.map(t => map(t))) as any\n}\n\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\n  return Object.fromEntries(Object.entries(obj).map(\n    ([k, v], i) => [k, fn(v, k, i)]\n  )) as any\n}\n\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\n  for (let i = from; i <= to; i++) yield i;\n};\n\n/** range of [from, to], inclusive */\nexport function range(from: number, to: number): number[] {\n  return [...rangeGen(from, to)]\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Should not reach this with value ${value}`)\n}\n\n// cartesian product of list of arrays\nexport function cartesian<T>(...q: T[][]): T[][] {\n  return q.reduce((a, b) => a.flatMap(d => b.map(e => [d, [e]].flat())), [[]] as T[][])\n}\n\n/** Will change `arr` in-place */\nexport function toggleInArr<T>(arr: T[], value: T) {\n  const ind = arr.indexOf(value)\n  if (ind < 0) arr.push(value)\n  else arr.splice(ind, 1)\n}\n\nexport function toggleArr<T>(arr: T[], value: T) {\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\n}\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","\nimport { objectKeyMap } from \"../Util/Util\"\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\n\ntype Num = number | NumNode\ntype Str = string | undefined | StrNode\ntype Any = Num | Str\n\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\nexport const one = percent(1), naught = percent(0)\n\nexport function constant(value: number, info?: Info): NumNode\nexport function constant(value: string | undefined, info?: Info): StrNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\n  return { operation: \"const\", operands: [], value, info }\n}\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\nexport function percent(value: number, info?: Info): NumNode {\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\n  return constant(value, { key: \"_\", ...info })\n}\n/** Inject `info` to the node in-place */\nexport function infoMut(node: NumNode, info: Info): NumNode\nexport function infoMut(node: StrNode, info: Info): StrNode\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\n  if (info) node.info = { ...node.info, ...info }\n  return node\n}\n\n/** `table[string] ?? defaultNode` */\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\n  return { operation: \"lookup\", operands, table, info }\n}\n\n/** min( x1, x2, ... ) */\nexport function min(...values: Num[]): NumNode {\n  return { operation: \"min\", operands: intoOps(values) }\n}\n/** max( x1, x2, ... ) */\nexport function max(...values: Num[]): NumNode {\n  return { operation: \"max\", operands: intoOps(values) }\n}\n/** x1 + x2 + ... */\nexport function sum(...values: Num[]): NumNode {\n  return { operation: \"add\", operands: intoOps(values) }\n}\n/** x1 * x2 * ... */\nexport function prod(...values: Num[]): NumNode {\n  return { operation: \"mul\", operands: intoOps(values) }\n}\n/** x / (x + c) */\nexport function frac(x: Num, c: Num): NumNode {\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\n}\nexport function res(base: Num): NumNode {\n  return { operation: \"res\", operands: intoOps([base]) }\n}\n\n/** v1 == v2 ? pass : 0 */\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\n}\n/** v1 == v2 ? pass : `undefined` */\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\n}\n/** v1 != v2 ? pass : 0 */\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\n}\n/** v1 >= v2 ? pass : 0 */\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 >= v2 ? pass : `undefined` */\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\n}\n/** v1 < v2 ? pass : 0 */\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\n}\n\n/** v1 >= v2 ? pass : fail */\nexport function cmp(v1: Num, v2: Num, pass: Num, fail: Num, info?: Info): NumNode {\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(fail)] as any\n  return { operation: \"threshold\", operands, info }\n}\n\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\n  if (nodeList.operation) {\n    if (nodeList.operation !== \"read\")\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\n    return { ...nodeList, path: prefix }\n  } else {\n    return objectKeyMap(Object.keys(nodeList), key =>\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\n  }\n}\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\n  return { operation: \"data\", operands: [base], data }\n}\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\n  return { operation: \"data\", operands: [base], data, reset: true, info }\n}\n\n\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\n}\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\n  return { operation: \"read\", operands: [], path, type: \"string\" }\n}\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\n}\n/**\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\n */\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\n}\nexport function stringPrio(...operands: Str[]): StrNode {\n  return { operation: \"prio\", operands: intoOps(operands) }\n}\n/** list[index] */\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\n  return { operation: \"subscript\", operands: [index], list, info }\n}\n\nfunction intoOps(values: Num[]): NumNode[]\nfunction intoOps(values: Str[]): StrNode[]\nfunction intoOps(values: Any[]): AnyNode[]\nfunction intoOps(values: Any[]): AnyNode[] {\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\n}\nfunction intoV(value: Num): NumNode\nfunction intoV(value: Str): StrNode\nfunction intoV(value: Num | Str): NumNode | StrNode\nfunction intoV(value: Any): AnyNode {\n  return (typeof value !== \"object\") ? constant(value) : value\n}\n\ntype _NodeList = {\n  [key: string]: NodeList\n} & {\n  operation?: never\n}\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\n\n/**\n * `v1` === `v2` ? `match` : `unmatch`\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\n */\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\n}\n\nexport function cmpNode(a: NumNode, b: NumNode): boolean {\n  if (a.operation !== b.operation) return false;\n  if (a.operands.length !== b.operands.length) return false;\n\n  switch (a.operation) {\n    case 'read':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.path.every((ai, i) => ai === b.path[i])\n    case 'const':\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      return a.value === b.value\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      if (b.operation !== a.operation) return false; // just doing this so typescript stops yelling at me\n      let used = [] as number[]\n      return a.operands.every((ai, i) => b.operands.some((bj, j) => {\n        if (used.includes(j)) return false\n        if (cmpNode(ai, bj)) {\n          used.push(j)\n          return true\n        }\n        return false\n      }))\n    default:\n      return a.operands.every((ai, i) => cmpNode(ai as NumNode, b.operands[i] as NumNode))\n  }\n}\n\n// Hash function pulled from StackOverflow\n//   https://stackoverflow.com/a/52171480\nconst cyrb53 = function (str: string, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\n\n// I made these numbers up; we might get better performance with different choice.\nexport function hashNode(n: NumNode): number {\n  let hsh = Math.imul(cyrb53(n.operation), 5234543537);\n  switch (n.operation) {\n    case 'const':\n      return hsh ^ cyrb53(n.value.toString(2))\n    case 'mul': case 'add': case 'min': case 'max':  // commutative ops.\n      return n.operands.reduce((hsh, ni) => hsh ^ hashNode(ni), hsh)\n    default:\n      return (n.operands as NumNode[]).reduce((hsh, ni) => Math.imul(hsh ^ hashNode(ni), 9923429423), hsh)\n  }\n}\n","import { AnyNode, NumNode, StrNode } from \"./type\"\nimport { constant } from \"./utils\"\n\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\n\n  function traverse(formula: (NumNode | StrNode)) {\n    if (visited.has(formula)) return\n\n    if (visiting.has(formula)) {\n      console.error(\"Found cyclical dependency during formula traversal\")\n      return\n    }\n    visiting.add(formula)\n\n    topDown(formula)\n\n    formula.operands.forEach(traverse)\n\n    bottomUp(formula)\n\n    visiting.delete(formula)\n    visited.add(formula)\n  }\n\n  formulas.forEach(traverse)\n}\n\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\n  const visiting = new Set<(NumNode | StrNode)>()\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\n\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    let topDown = topDownMapped.get(formula)\n    if (topDown) return topDown\n    topDown = topDownMap(formula)\n\n    let bottomUp = bottomUpMapped.get(topDown)\n    if (bottomUp) return bottomUp\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n    visiting.add(topDown)\n\n    bottomUp = bottomUpMap(traverse(topDown), formula)\n\n    visiting.delete(topDown)\n\n    topDownMapped.set(formula, bottomUp)\n    bottomUpMapped.set(topDown, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\n    const operands = formula.operands.map(check)\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\n  }\n\n  const result = formulas.map(check)\n  return arrayEqual(result, formulas) ? formulas : result\n}\n\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\n  const visiting = new Set<AnyNode>()\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\n\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\n    let topDownMapping = topDownByContext.get(parentContextId)\n    if (!topDownMapping) {\n      topDownMapping = new Map()\n      topDownByContext.set(parentContextId, topDownMapping)\n    }\n\n    let topDown = topDownMapping.get(formula)\n    if (topDown) return topDown\n    let topDownContextId: number\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\n\n    if (visiting.has(topDown)) {\n      console.error(\"Found cyclical dependency during formula mapping\")\n      return constant(NaN)\n    }\n\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\n    if (!bottomUpMapping) {\n      bottomUpMapping = new Map()\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\n    }\n\n    let bottomUp = bottomUpMapping.get(topDown)\n    if (bottomUp) return bottomUp\n\n    visiting.add(topDown)\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\n    visiting.delete(topDown)\n\n    bottomUpMapping.set(topDown, bottomUp)\n    topDownMapping.set(formula, bottomUp)\n    return bottomUp\n  }\n\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\n    const operands = formula.operands.map(f => check(f, contextId))\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\n  }\n\n  const result = formulas.map(f => check(f, baseContextId))\n  return arrayEqual(formulas, result) ? formulas : result\n}\n\ntype ContextID = number\n\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\n  if (a === undefined) return b === undefined\n  if (b === undefined) return false\n\n  return a.length === b.length && a.every((value, i) => value === b[i])\n}\n","import { assertUnreachable, objectKeyMap, objPathValue } from \"../Util/Util\"\nimport { forEachNodes, mapFormulas } from \"./internal\"\nimport { constant } from \"./utils\"\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\n\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\n  min: (x: number[]): number => Math.min(...x),\n  max: (x: number[]): number => Math.max(...x),\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\n}\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\n  ...allCommutativeMonoidOperations,\n  res: ([res]: number[]): number => {\n    if (res < 0) return 1 - res / 2\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\n    return 1 - res\n  },\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\n}\n\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\n\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  formulas = constantFold(formulas, topLevelData, shouldFold)\n  formulas = flatten(formulas)\n  formulas = deduplicate(formulas)\n  return formulas\n}\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): [compute: () => Float64Array, mapping: Dict<string, number>, buffer: Float64Array] {\n  // TODO: Use min-cut to minimize the size of interim array\n  type Reference = string | number | { ins: Reference[] }\n\n  const uniqueReadStrings = new Set<string>()\n  const uniqueNumbers = new Set<number>()\n  const mapping = new Map<NumNode, Reference>()\n\n  forEachNodes(formulas, _ => { }, f => {\n    const { operation } = f\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\n          throw new Error(`Unsupported ${operation} node in precompute`)\n        const name = binding(f)\n        uniqueReadStrings.add(name)\n        mapping.set(f, name)\n        break\n      case \"add\": case \"min\": case \"max\": case \"mul\":\n      case \"threshold\": case \"res\": case \"sum_frac\":\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\n        break\n      case \"const\":\n        if (typeof f.value !== \"number\")\n          throw new Error(\"Found string constant while precomputing\")\n        const value = f.value\n        uniqueNumbers.add(value)\n        mapping.set(f as ConstantNode<number>, value)\n        break\n      case \"match\": case \"lookup\": case \"subscript\":\n      case \"prio\": case \"small\":\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  /**\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\n   *\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\n   * in the same order as formulas even when they are duplicated. Inputs\n   * are arranged in the same order as the read strings, even when they\n   * overlap with outputs. If an output is a constant or a compute node,\n   * only put the data in the output region.\n   */\n  const locations = new Map<NumNode | number | string, number>()\n\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\n  const constValues = [...uniqueNumbers]\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\n\n  formulas.forEach((f, i) => {\n    locations.set(f, i)\n    if (f.operation === \"const\") locations.set(f.value, i)\n  })\n  // After this line, if some outputs are also read node, `locations`\n  // will point to the one in the read node portion instead.\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\n  let offset = formulas.length + readStrings.length\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\n\n  // `locations` is stable from this point on. We now only append new values.\n  // There is no change to existing values.\n  //\n  // DO NOT read from `location` prior to this line.\n  mapping.forEach((ref, node) => {\n    if (typeof ref !== \"object\") {\n      locations.set(node, locations.get(ref)!)\n      return\n    }\n    if (!locations.has(node)) locations.set(node, offset++)\n    computations.push({\n      out: locations.get(node)!,\n      ins: node.operands.map(op => locations.get(op)!),\n      op: allOperations[node.operation],\n      buff: Array(node.operands.length).fill(0),\n    })\n  })\n\n  const buffer = new Float64Array(offset).fill(0)\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\n\n  // Copy target for when some outputs are duplicated\n  const copyList = formulas.map((node, i) => {\n    const src = locations.get(node)!\n    return src !== i ? [src, i] : undefined!\n  }).filter(x => x)\n  const copyFormula = copyList.length ? () => {\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\n  } : undefined\n\n  return [() => {\n    computations.forEach(({ out, ins, op, buff }) => {\n      ins.forEach((i, j) => buff[j] = buffer[i])\n      buffer[out] = op(buff)\n    })\n    copyFormula?.()\n    return buffer\n  }, objectKeyMap(readStrings, (_, i) => readOffset + i), buffer]\n}\n\nfunction flatten(formulas: NumNode[]): NumNode[] {\n  return mapFormulas(formulas, f => f, _formula => {\n    let result = _formula\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\n      const formula = _formula as ComputeNode\n      const { operation } = formula\n\n      let flattened = false\n      const operands = formula.operands.flatMap(dep =>\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\n      result = flattened ? { ...formula, operands } : formula\n    }\n\n    return result\n  })\n}\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\n    const result = new Map<T, number>()\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\n    return result\n  }\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\n  }\n\n  const wrap = {\n    common: {\n      counts: new Map<NumNode, number>(),\n      formulas: new Set<NumNode>(),\n      operation: \"add\" as Operation\n    }\n  }\n\n  while (true) {\n    let next: typeof wrap.common | undefined\n\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\n\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\n      candidatesByOperation.set(operation, [])\n\n    formulas = mapFormulas(formulas, _formula => {\n      if (wrap.common.formulas.has(_formula as NumNode)) {\n        const formula = _formula as ComputeNode\n        const remainingCounts = new Map(wrap.common.counts)\n        const operands = formula.operands.filter(dep => {\n          const count = remainingCounts.get(dep)\n          if (count) {\n            remainingCounts.set(dep, count - 1)\n            return false\n          }\n          return true\n        })\n\n        if (!operands.length)\n          return factored\n        operands.push(factored)\n        return { ...formula, operands }\n      }\n      return _formula\n    }, _formula => {\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\n      const formula = _formula as ComputeNode\n\n      if (next) {\n        if (next.operation === formula.operation) {\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\n          const nextCounts = next.counts\n          let total = 0\n\n          for (const [dependency, currentCount] of currentCounts.entries()) {\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\n            if (commonCount) {\n              commonCounts.set(dependency, commonCount)\n              total += commonCount\n            } else commonCounts.delete(dependency)\n          }\n          if (total > 1) {\n            next.counts = commonCounts\n            next.formulas.add(formula)\n          }\n        }\n      } else {\n        const candidates = candidatesByOperation.get(formula.operation)!\n        const counts = elementCounts(formula.operands)\n\n        for (const [candidate, candidateCounts] of candidates) {\n          let total = 0\n\n          const commonCounts = new Map<NumNode, number>()\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\n            if (count) {\n              commonCounts.set(dependency, count)\n              total += count\n            }\n          }\n          if (total > 1) {\n            next = {\n              counts: commonCounts,\n              formulas: new Set([formula, candidate]),\n              operation: formula.operation\n            }\n            candidatesByOperation.clear()\n            break\n          }\n        }\n        if (!next) candidates.push([formula, counts])\n      }\n\n      return formula\n    })\n\n    if (next) wrap.common = next\n    else break\n  }\n\n  return formulas\n}\n\n/**\n * Replace nodes with known values with appropriate constants,\n * avoiding removal of any nodes that pass `isFixed` predicate\n */\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\n  const origin: Context = { data: [], processed: new Map() }\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\n\n  function fold(formula: StrNode, context: Context): StrNode\n  function fold(formula: NumNode, context: Context): NumNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\n    const old = context.processed.get(formula)\n    if (old) return old\n\n    const { operation } = formula\n    let result: NumNode | StrNode\n    switch (operation) {\n      case \"const\": return formula\n      case \"add\": case \"mul\": case \"max\": case \"min\":\n        const f = allOperations[operation]\n        const numericOperands: number[] = []\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\n          const folded = fold(formula, context)\n          return (folded.operation === \"const\")\n            ? (numericOperands.push(folded.value), false)\n            : true\n        }).map(x => fold(x, context))\n        const numericValue = f(numericOperands)\n\n        // Fold degenerate cases. This may incorrectly compute NaN\n        // results, which shouldn't appear under expected usage.\n        // - zero\n        //   - 0 * ... = 0\n        // - infinity\n        //   - max(infinity, ...) = infinity\n        //   - infinity + ... = infinity\n        // - (-infinity)\n        //   - min(-infinity, ...) - infinity\n        //   - (-infinity) + ... = -infinity\n        // - NaN\n        //   - operation(NaN, ...) = NaN\n        if (!isFinite(numericValue)) {\n          if ((operation !== \"mul\") &&\n            (operation !== \"max\" || numericValue > 0) &&\n            (operation !== \"min\" || numericValue < 0)) {\n            result = constant(numericValue)\n            break\n          }\n        } else if (operation === \"mul\" && numericValue === 0) {\n          result = constant(numericValue)\n          break\n        }\n\n        if (numericValue !== f([])) // Skip vacuous values\n          formulaOperands.push(constant(numericValue))\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\n        else result = { operation, operands: formulaOperands }\n        break\n      case \"res\": case \"sum_frac\": {\n        const operands = formula.operands.map(x => fold(x, context))\n        const f = allOperations[operation]\n        if (operands.every(x => x.operation === \"const\"))\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\n        else result = { ...formula, operands }\n        break\n      }\n      case \"lookup\": {\n        const index = fold(formula.operands[0], context)\n        if (index.operation === \"const\") {\n          const selected = formula.table[index.value!] ?? formula.operands[1]\n          if (selected) {\n            result = fold(selected, context)\n            break\n          }\n        }\n        throw new Error(`Unsupported ${operation} node while folding`)\n      }\n      case \"prio\": {\n        const first = formula.operands.find(op => {\n          const folded = fold(op, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          return folded.value !== undefined\n        })\n        result = first ? fold(first, context) : constant(undefined)\n        break\n      }\n      case \"small\": {\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\n        for (const operand of formula.operands) {\n          const folded = fold(operand, context)\n          if (folded.operation !== \"const\")\n            throw new Error(`Unsupported ${operation} node while folding`)\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\n            smallest = folded\n        }\n        result = smallest ?? constant(undefined)\n        break\n      }\n      case \"match\": {\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\n          throw new Error(`Unsupported ${operation} node while folding`)\n        result = (v1.value === v2.value) ? match : unmatch\n        break\n      }\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\n        if (value.operation === \"const\" && threshold.operation === \"const\")\n          result = value.value >= threshold.value ? pass : fail\n        else\n          result = { ...formula, operands: [value, threshold, pass, fail] }\n        break\n      }\n      case \"subscript\": {\n        const [index] = formula.operands.map(x => fold(x, context))\n        result = (index.operation === \"const\")\n          ? constant(formula.list[index.value])\n          : { ...formula, operands: [index] }\n        break\n      }\n      case \"read\": {\n        const operands = context.data\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\n          .filter(x => x)\n\n        if (operands.length === 0) {\n          if (shouldFold(formula)) {\n            const { accu } = formula\n            if (accu === undefined || accu === \"small\")\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\n            else result = constant(allOperations[accu]([]))\n          } else result = formula\n        } else if (formula.accu === undefined || operands.length === 1)\n          result = fold(operands[operands.length - 1], context)\n        else\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\n        break\n      }\n      case \"data\":\n        if (formula.reset) context = origin\n        const map = nextContextMap.get(context)!\n        let nextContext = map.get(formula.data)\n        if (!nextContext) {\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\n          nextContextMap.set(nextContext, new Map())\n          map.set(formula.data, nextContext)\n        }\n        result = fold(formula.operands[0], nextContext)\n        break\n      default: assertUnreachable(operation)\n    }\n\n    context.processed.set(formula, result)\n    return result\n  }\n\n  const context = { data: [topLevelData], processed: new Map() }\n  nextContextMap.set(context, new Map())\n  nextContextMap.get(origin)!.set(topLevelData, context)\n  return formulas.map(x => fold(x, context))\n}\n\nexport const testing = {\n  constantFold, flatten, deduplicate\n}\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\nexport const allReactionModes = [\"hydro_vaporize\", \"pyro_vaporize\", \"pyro_melt\", \"cryo_melt\",] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allRarities = [5, 4, 3, 2, 1] as const\nexport const allArtifactRarities = [5, 4, 3] as const\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo'] as const\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allArtifactSets = [\n  \"Adventurer\",\n  \"ArchaicPetra\",\n  \"Berserker\",\n  \"BlizzardStrayer\",\n  \"BloodstainedChivalry\",\n  \"BraveHeart\",\n  \"CrimsonWitchOfFlames\",\n  \"DefendersWill\",\n  \"EchoesOfAnOffering\",\n  \"EmblemOfSeveredFate\",\n  \"Gambler\",\n  \"GladiatorsFinale\",\n  \"HeartOfDepth\",\n  \"HuskOfOpulentDreams\",\n  \"Instructor\",\n  \"Lavawalker\",\n  \"LuckyDog\",\n  \"MaidenBeloved\",\n  \"MartialArtist\",\n  \"NoblesseOblige\",\n  \"OceanHuedClam\",\n  \"PaleFlame\",\n  \"PrayersForDestiny\",\n  \"PrayersForIllumination\",\n  \"PrayersForWisdom\",\n  \"PrayersToSpringtime\",\n  \"ResolutionOfSojourner\",\n  \"RetracingBolide\",\n  \"Scholar\",\n  \"ShimenawasReminiscence\",\n  \"TenacityOfTheMillelith\",\n  \"TheExile\",\n  \"ThunderingFury\",\n  \"Thundersoother\",\n  \"TinyMiracle\",\n  \"TravelingDoctor\",\n  \"VermillionHereafter\",\n  \"ViridescentVenerer\",\n  \"WanderersTroupe\",\n] as const\nexport const allCharacterKeys = [\n  \"Albedo\",\n  \"Amber\",\n  \"Barbara\",\n  \"Beidou\",\n  \"Bennett\",\n  \"Chongyun\",\n  \"Diluc\",\n  \"Diona\",\n  \"Fischl\",\n  \"Ganyu\",\n  \"HuTao\",\n  \"Jean\",\n  \"Kaeya\",\n  \"Keqing\",\n  \"Klee\",\n  \"KujouSara\",\n  \"Lisa\",\n  \"Mona\",\n  \"Ningguang\",\n  \"Noelle\",\n  \"Qiqi\",\n  \"Razor\",\n  \"Sucrose\",\n  \"Tartaglia\",\n  \"Traveler\",\n  \"RaidenShogun\",\n  \"Venti\",\n  \"Xiangling\",\n  \"Xiao\",\n  \"Xingqiu\",\n  \"Xinyan\",\n  \"Rosaria\",\n  \"Yanfei\",\n  \"Eula\",\n  \"KaedeharaKazuha\",\n  \"KamisatoAyaka\",\n  \"Sayu\",\n  \"Shenhe\",\n  \"Yoimiya\",\n  \"Aloy\",\n  \"SangonomiyaKokomi\",\n  \"Thoma\",\n  \"Gorou\",\n  \"AratakiItto\",\n  \"YaeMiko\",\n  \"YunJin\",\n  \"Zhongli\",\n  \"KamisatoAyato\",\n  \"Yelan\",\n  // \"KukiShinobu\"\n] as const\n\nexport const allWeaponSwordKeys = [\n  \"AmenomaKageuchi\",\n  \"AquilaFavonia\",\n  \"BlackcliffLongsword\",\n  \"CinnabarSpindle\",\n  \"CoolSteel\",\n  \"DarkIronSword\",\n  \"DullBlade\",\n  \"FavoniusSword\",\n  \"FesteringDesire\",\n  \"FilletBlade\",\n  \"FreedomSworn\",\n  \"HaranGeppakuFutsu\",\n  \"HarbingerOfDawn\",\n  \"IronSting\",\n  \"LionsRoar\",\n  \"MistsplitterReforged\",\n  \"PrimordialJadeCutter\",\n  \"PrototypeRancour\",\n  \"RoyalLongsword\",\n  \"SacrificialSword\",\n  \"SilverSword\",\n  \"SkyriderSword\",\n  \"SkywardBlade\",\n  \"SummitShaper\",\n  \"SwordOfDescension\",\n  \"TheAlleyFlash\",\n  \"TheBlackSword\",\n  \"TheFlute\",\n  \"TravelersHandySword\",\n] as const\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\n\nexport const allWeaponClaymoreKeys = [\n  \"Akuoumaru\",\n  \"BlackcliffSlasher\",\n  \"BloodtaintedGreatsword\",\n  \"DebateClub\",\n  \"FavoniusGreatsword\",\n  \"FerrousShadow\",\n  \"KatsuragikiriNagamasa\",\n  \"LithicBlade\",\n  \"LuxuriousSeaLord\",\n  \"OldMercsPal\",\n  \"PrototypeArchaic\",\n  \"Rainslasher\",\n  \"RedhornStonethresher\",\n  \"RoyalGreatsword\",\n  \"SacrificialGreatsword\",\n  \"SerpentSpine\",\n  \"SkyriderGreatsword\",\n  \"SkywardPride\",\n  \"SnowTombedStarsilver\",\n  \"SongOfBrokenPines\",\n  \"TheBell\",\n  \"TheUnforged\",\n  \"WasterGreatsword\",\n  \"Whiteblind\",\n  \"WhiteIronGreatsword\",\n  \"WolfsGravestone\",\n] as const\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\n\nexport const allWeaponPolearmKeys = [\n  \"BeginnersProtector\",\n  \"BlackcliffPole\",\n  \"BlackTassel\",\n  \"CalamityQueller\",\n  \"CrescentPike\",\n  \"Deathmatch\",\n  \"DragonsBane\",\n  \"DragonspineSpear\",\n  \"EngulfingLightning\",\n  \"FavoniusLance\",\n  \"Halberd\",\n  \"IronPoint\",\n  \"KitainCrossSpear\",\n  \"LithicSpear\",\n  \"PrimordialJadeWingedSpear\",\n  \"PrototypeStarglitter\",\n  \"RoyalSpear\",\n  \"SkywardSpine\",\n  \"StaffOfHoma\",\n  \"TheCatch\",\n  \"VortexVanquisher\",\n  \"WavebreakersFin\",\n  \"WhiteTassel\",\n] as const\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\n\nexport const allWeaponBowKeys = [\n  \"AlleyHunter\",\n  \"AmosBow\",\n  \"AquaSimulacra\",\n  \"BlackcliffWarbow\",\n  \"CompoundBow\",\n  \"ElegyForTheEnd\",\n  \"FadingTwilight\",\n  \"FavoniusWarbow\",\n  \"Hamayumi\",\n  \"HuntersBow\",\n  \"Messenger\",\n  \"MitternachtsWaltz\",\n  \"MouunsMoon\",\n  \"PolarStar\",\n  \"Predator\",\n  \"PrototypeCrescent\",\n  \"RavenBow\",\n  \"RecurveBow\",\n  \"RoyalBow\",\n  \"Rust\",\n  \"SacrificialBow\",\n  \"SeasonedHuntersBow\",\n  \"SharpshootersOath\",\n  \"SkywardHarp\",\n  \"Slingshot\",\n  \"TheStringless\",\n  \"TheViridescentHunt\",\n  \"ThunderingPulse\",\n  \"WindblumeOde\",\n] as const\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\n\nexport const allWeaponCatalystKeys = [\n  \"ApprenticesNotes\",\n  \"BlackcliffAgate\",\n  \"DodocoTales\",\n  \"EmeraldOrb\",\n  \"EverlastingMoonglow\",\n  \"EyeOfPerception\",\n  \"FavoniusCodex\",\n  \"Frostbearer\",\n  \"HakushinRing\",\n  \"KagurasVerity\",\n  \"LostPrayerToTheSacredWinds\",\n  \"MagicGuide\",\n  \"MappaMare\",\n  \"MemoryOfDust\",\n  \"OathswornEye\",\n  \"OtherworldlyStory\",\n  \"PocketGrimoire\",\n  \"PrototypeAmber\",\n  \"RoyalGrimoire\",\n  \"SacrificialFragments\",\n  \"SkywardAtlas\",\n  \"SolarPearl\",\n  \"TheWidsith\",\n  \"ThrillingTalesOfDragonSlayers\",\n  \"TwinNephrite\",\n  \"WineAndSong\",\n] as const\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\n\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type Region = typeof allRegions[number]\nexport type ReactionModeKey = typeof allReactionModes[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type Rarity = typeof allRarities[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\nexport type SlotKey = typeof allSlotKeys[number]\nexport type ElementKey = typeof allElements[number]\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type ArtifactSetKey = typeof allArtifactSets[number]\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\n","import { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\nimport type { ArtSetExclusion } from \"./BuildSetting\";\n\ntype DynMinMax = { [key in string]: MinMax }\ntype MinMax = { min: number, max: number }\n\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  let should = forced\n  /** If `key` makes progress, all operations in `value` should be performed */\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\n    pruneOrder: { pruneNodeRange: true },\n    pruneArtRange: { pruneNodeRange: true },\n    pruneNodeRange: { reaffine: true },\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\n  }\n  let count = 0\n  while (Object.values(should).some(x => x) && count++ < 20) {\n    if (should.pruneOrder) {\n      delete should.pruneOrder\n      const newArts = pruneOrder(arts, numTop, exclusion)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneOrder }\n      }\n    }\n    if (should.pruneArtRange) {\n      delete should.pruneArtRange\n      const newArts = pruneArtRange(nodes, arts, minimum)\n      if (arts !== newArts) {\n        arts = newArts\n        should = { ...should, ...deps.pruneArtRange }\n      }\n    }\n    if (should.pruneNodeRange) {\n      delete should.pruneNodeRange\n      const newNodes = pruneNodeRange(nodes, arts)\n      if (nodes !== newNodes) {\n        nodes = newNodes\n        should = { ...should, ...deps.pruneNodeRange }\n      }\n    }\n    if (should.reaffine) {\n      delete should.reaffine\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\n      if (nodes !== newNodes || arts !== newArts) {\n        nodes = newNodes\n        arts = newArts\n        should = { ...should, ...deps.reaffine }\n      }\n    }\n  }\n  return { nodes, arts }\n}\n\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\n\n  function visit(node: NumNode, isAffine: boolean) {\n    if (isAffine) affineNodes.add(node)\n    else node.operands.forEach(_op => {\n      const op = _op as NumNode\n      affineNodes.has(op) && topLevelAffine.add(op)\n    })\n  }\n\n  const dynKeys = new Set<string>()\n\n  forEachNodes(nodes, _ => { }, f => {\n    const operation = f.operation\n    switch (operation) {\n      case \"read\":\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\n        dynKeys.add(f.path[1])\n        visit(f, true)\n        break\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\n      case \"mul\": {\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\n        break\n      }\n      case \"const\":\n        if (typeof f.value === \"string\" || f.value === undefined)\n          throw new Error(`Found constant ${f.value} while compacting`)\n        visit(f as NumNode, true); break\n      case \"res\": case \"threshold\": case \"sum_frac\":\n      case \"max\": case \"min\": visit(f, false); break\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\n      default: assertUnreachable(operation)\n    }\n  })\n\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\n    Object.keys(arts.base).length === dynKeys.size)\n    return { nodes, arts }\n\n  let current = -1\n  function nextDynKey(): string {\n    while (dynKeys.has(`${++current}`));\n    return `${current}`\n  }\n\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\n  const affineMap = new Map(affine.map(node => [node,\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\n      ? node\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\n\n  function reaffineArt(stat: DynStat): DynStat {\n    const values = constantFold([...affineMap.keys()], {\n      dyn: objectMap(stat, (value) => constant(value))\n    } as any, _ => true)\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\n  }\n  const result = {\n    nodes, arts: {\n      base: reaffineArt(arts.base),\n      values: objectKeyMap(allSlotKeys, slot =>\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\n    }\n  }\n  const offsets = Object.entries(reaffineArt({}))\n  for (const arts of Object.values(result.arts.values))\n    for (const { values } of arts)\n      for (const [key, baseValue] of offsets)\n        values[key] -= baseValue\n  return result\n}\n/** Remove artifacts that cannot be in top `numTop` builds */\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\n  let progress = false\n  const noRainbow = !exclusion.rainbow?.length\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\n  const values = objectKeyMap(allSlotKeys, slot => {\n    const list = arts.values[slot]\n    const newList = list.filter(art => {\n      let count = 0\n      return list.every(other => {\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\n        if (greaterEqual && (greater || other.id > art.id) &&\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\n          count++\n        return count < numTop\n      })\n    })\n    if (newList.length !== list.length) progress = true\n    return newList\n  })\n  return progress ? { base: arts.base, values } : arts\n}\n/** Remove artifacts that cannot reach `minimum` in any build */\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const wrap = { arts }\n  while (true) {\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\n\n    let progress = false\n    const values = objectKeyMap(allSlotKeys, slot => {\n      const result = wrap.arts.values[slot].filter(art => {\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\n        const newRange = computeNodeRange(nodes, read)\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\n      })\n      if (result.length !== wrap.arts.values[slot].length)\n        progress = true\n      return result\n    })\n    if (!progress) break\n    wrap.arts = { base: wrap.arts.base, values }\n  }\n  return wrap.arts\n}\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\n  const nodeRange = computeNodeRange(nodes, reads)\n\n  return mapFormulas(nodes, f => {\n    const { operation } = f\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\n    switch (operation) {\n      case \"threshold\": {\n        const [value, threshold, pass, fail] = operandRanges\n        if (value.min >= threshold.max) return f.operands[2]\n        else if (value.max < threshold.min) return constant(0)\n        if (pass.max === pass.min &&\n          fail.max === fail.min &&\n          pass.min === fail.min && isFinite(pass.min))\n          return constant(pass.max)\n        break\n      }\n      case \"min\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\n        })\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\n        break\n      }\n      case \"max\": {\n        const newOperands = f.operands.filter((_, i) => {\n          const op1 = operandRanges[i]\n          return operandRanges.every(op2 => op1.max >= op2.min)\n        })\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\n        break\n      }\n    }\n    return f\n  }, f => f)\n}\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\n  const result: DynMinMax = {}\n  ranges.forEach(range => {\n    Object.entries(range).forEach(([key, value]) => {\n      if (result[key]) {\n        result[key].min += value.min\n        result[key].max += value.max\n      } else result[key] = { ...value }\n    })\n  })\n  return result\n}\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\n  const result: DynMinMax = {}\n  if (arts.length) {\n    Object.keys(arts[0].values)\n      .filter(key => arts.every(art => art.values[key]))\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\n    arts.forEach(({ values }) => {\n      for (const [key, value] of Object.entries(values)) {\n        if (!result[key]) result[key] = { min: 0, max: value }\n        else {\n          if (result[key].max < value) result[key].max = value\n          if (result[key].min > value) result[key].min = value\n        }\n      }\n    })\n  }\n  return result\n}\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\n  const range = new Map<NumNode, MinMax>()\n\n  forEachNodes(nodes, _ => { }, _f => {\n    const f = _f as NumNode\n    const { operation } = f\n    const operands = f.operands.map(op => range.get(op)!)\n    let current: MinMax\n    switch (operation) {\n      case \"read\":\n        if (f.path[0] !== \"dyn\")\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\n        break\n      case \"const\": current = computeMinMax([f.value]); break\n      case \"subscript\": current = computeMinMax(f.list); break\n      case \"add\": case \"min\": case \"max\":\n        current = {\n          min: allOperations[operation](operands.map(x => x.min)),\n          max: allOperations[operation](operands.map(x => x.max)),\n        }; break\n      case \"res\": current = {\n        min: allOperations[operation]([operands[0].max]),\n        max: allOperations[operation]([operands[0].min]),\n      }; break\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\n        accu.min * current.min, accu.min * current.max,\n        accu.max * current.min, accu.max * current.max,\n      ])); break\n      case \"threshold\":\n        if (operands[0].min >= operands[1].max) current = operands[2]\n        else if (operands[0].max < operands[1].min) current = computeMinMax([0])\n        else current = computeMinMax([0], [operands[2]])\n        break\n      case \"sum_frac\": {\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\n        if (sum.min <= 0 && sum.max >= 0)\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\n        else\n          // TODO: Check this\n          current = computeMinMax([\n            x.min / sum.min, x.min / sum.max,\n            x.max / sum.min, x.max / sum.max\n          ])\n        break\n      }\n      case \"data\": case \"lookup\": case \"match\":\n        throw new Error(`Unsupported ${operation} node`)\n      default: assertUnreachable(operation)\n    }\n    range.set(f, current)\n  })\n  return range\n}\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\n  return { min, max }\n}\n\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\n  return {\n    base: arts.base,\n    values: objectKeyMap(allSlotKeys, slot => {\n      const filter = filters[slot]\n      switch (filter.kind) {\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\n      }\n    })\n  }\n}\n\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\n}\nexport function mergePlot(plots: PlotData[]): PlotData {\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\n  while (keys.size > maxCount) {\n    scale *= reductionScaling\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\n  }\n  const result: PlotData = {}\n  for (const plot of plots)\n    for (const build of Object.values(plot)) {\n      const x = Math.round(build.plot! / scale) * scale\n      if (!result[x] || result[x]!.value < build.value)\n        result[x] = build\n    }\n  return result\n}\n\nexport function countBuilds(arts: ArtifactsBySlot): number {\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\n}\n\n\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\n  filter_loop: for (const filter of filters) {\n    for (const [slot, f] of Object.entries(filter)) {\n      const available = artSets[slot]!\n      switch (f.kind) {\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\n        case \"id\": break\n      }\n    }\n    yield filter\n  }\n}\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\n  return new Set(exclusion?.includes(2)\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\n}\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\n  /**\n   * This generation algorithm is separated into two parts:\n   * - \"Shape\" generation\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\n   * - Shape filling\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\n   */\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\n  let shapes: number[][] = []\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\n    if (current.length === 5) {\n      if (allowedRainbows.has(rainbows.length))\n        shapes.push(current)\n      return\n    }\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\n  }\n  populateShapes([0], new Set([0]), [0])\n  function indexOfShape(shape: number[], replacing: number) {\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\n      return undefined\n    shape = [...shape]\n    shape[replacing] = 5\n    return shape.reduce((a, b) => a * 6 + b, 0)\n  }\n  for (let replacing = 4; replacing >= 0; replacing--) {\n    const required: Map<number, number> = new Map()\n    for (const shape of shapes) {\n      const id = indexOfShape(shape, replacing)\n      if (id === undefined) continue\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\n    }\n    for (const [id, remaining] of required.entries()) {\n      if (remaining === 0) {\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\n        shape[replacing] = 5\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\n        shapes.push(shape)\n      }\n    }\n  }\n\n  // Shapes are now calculated and merged, proceed to fill in the sets\n\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\n\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\n\n  function* check(shape: number[]) {\n    const used: Set<ArtifactSetKey> = new Set()\n    let groupped: number[][] = [], rainbows: number[] = []\n    for (const i of shape) {\n      groupped.push([])\n      if (i === 5) rainbows.push(groupped.length - 1)\n      else groupped[i].push(groupped.length - 1)\n    }\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\n    let usableRainbows = rainbows.length\n\n    // Inception.. because js doesn't like functions inside a for-loop\n    function* check(i: number) {\n      if (i === groupped.length)\n        return yield* check_free(0)\n\n      for (const set of artSets) {\n        if (used.has(set)) continue\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\n        let requiredRainbows = 0\n\n        if (allowedSet && !allowedSet.has(length)) {\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\n        }\n\n        used.add(set)\n        counts[set] = groupped[i].length\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\n        usableRainbows -= requiredRainbows\n\n        yield* check(i + 1)\n\n        usableRainbows += requiredRainbows\n        counts[set] = 0\n        used.delete(set)\n      }\n    }\n    // We separate filling rainbow slots from groupped slots because it has an entirely\n    // different set of rules regarding what can be filled and what states to be kept.\n    function* check_free(i: number) {\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\n      let required = 0\n      for (const set of artSets) {\n        const allowedSet = allowedCounts[set], count = counts[set]\n        if (!allowedSet) continue\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\n        else if (!allowedSet.has(count)) {\n          required += [...allowedSet].find(x => x > count)! - count\n          missing.push(set)\n        }\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\n      }\n      if (required > remaining) return\n      if (i === rainbows.length) {\n        yield { ...result }\n        return\n      }\n      if (required === remaining) {\n        for (const set of missing) {\n          counts[set]++\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n          yield* check_free(i + 1)\n          counts[set]--\n        }\n        return\n      }\n      for (const set of [...isolated, ...missing]) {\n        counts[set]++\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\n        yield* check_free(i + 1)\n        counts[set]--\n      }\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\n      yield* check_free(i + 1)\n    }\n    yield* check(0)\n  }\n  for (const shape of shapes) yield* check(shape)\n}\n\nexport type RequestFilter = StrictDict<SlotKey,\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\n  { kind: \"id\", ids: Set<string> }\n>\nexport const emptyfilter: RequestFilter = objectKeyMap(allSlotKeys, _ => ({ kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }));\n\nexport type DynStat = { [key in string]: number }\nexport type ArtifactBuildData = {\n  id: string\n  set?: ArtifactSetKey\n  values: DynStat\n}\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\n\nexport type PlotData = Dict<number, Build>\nexport interface Build {\n  value: number\n  plot?: number\n  artifactIds: string[]\n}\n","import { optimize, precompute } from '../../../../Formula/optimization';\nimport type { NumNode } from '../../../../Formula/type';\nimport { ArtifactSetKey } from '../../../../Types/consts';\nimport type { InterimResult, Setup, SubProblem } from './BackgroundWorker';\nimport { ArtifactsBySlot, Build, countBuilds, DynStat, filterArts, mergePlot, PlotData, pruneAll, RequestFilter } from './common';\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  plotBase: NumNode | undefined\n  threshold: number = -Infinity\n  maxBuilds: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: NumNode[]\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.min = filters.map(x => x.min)\n    this.maxBuilds = maxBuilds\n    this.callback = callback\n    this.nodes = filters.map(x => x.value)\n    this.nodes.push(optimizationTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.plotBase = plotBase\n      this.nodes.push(plotBase)\n    }\n  }\n\n  compute(newThreshold: number, subproblem: SubProblem, dbg = false) {\n    if (this.threshold < newThreshold) this.threshold = newThreshold\n    const { optimizationTarget, constraints, filter, artSetExclusion, depth } = subproblem\n\n    const { interimReport } = this, self = this // `this` in nested functions means different things\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts)\n\n    if (subproblem.cache) {\n      if (subproblem.cachedCompute.maxEst[subproblem.cachedCompute.maxEst.length - 1] < this.threshold) {\n        this.interimReport({ tested: 0, failed: 0, skipped: totalCount })\n        return\n      }\n    }\n\n    let nodes = [...constraints.map(({ value }) => value), optimizationTarget]\n    if (this.plotBase !== undefined) nodes.push(this.plotBase)\n    nodes = optimize(nodes, {}, _ => false);\n    let min = constraints.map(({ min }) => min)\n    // ({ nodes, arts: preArts } = pruneAll(nodes, min, preArts, this.maxBuilds, {}, {\n    //   pruneArtRange: true, pruneNodeRange: true,\n    // }))\n    const [compute, mapping, buffer] = precompute(nodes, f => f.path[1])\n\n    const arts = Object.values(preArts.values)\n      .sort((a, b) => a.length - b.length)\n      .map(arts => arts.map(art => ({\n        id: art.id, set: art.set, values: Object.entries(art.values)\n          .map(([key, value]) => ({ key: mapping[key]!, value, cache: 0 }))\n          .filter(({ key, value }) => key !== undefined && value !== 0)\n      })))\n\n    const ids: string[] = Array(arts.length).fill(\"\")\n    let count = { tested: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\n\n    let maxFound = -Infinity\n\n    function permute(i: number, setKeyCounts: DynStat) {\n      if (i < 0) {\n        const result = compute()\n        maxFound = Math.max(result[constraints.length], maxFound)\n        let passArtExcl = Object.entries(artSetExclusion).every(([setKey, vals]) => !vals.includes(setKeyCounts[setKey]))\n\n        // Check rainbows\n        if (passArtExcl && artSetExclusion['uniqueKey'] !== undefined) {\n          const nRainbow = Object.values(setKeyCounts).reduce((a, b) => a + (b % 2), 0)\n          passArtExcl = !artSetExclusion['uniqueKey'].includes(nRainbow)\n        }\n\n        if (passArtExcl && min.every((m, i) => (m <= result[i]))) {\n          const value = result[min.length], { builds, plotData, threshold } = self\n          let build: Build | undefined\n          if (value >= threshold) {\n            build = { value, artifactIds: [...ids] }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build) build = { value, artifactIds: [...ids] }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        }\n        else count.failed += 1\n        return\n      }\n      arts[i].forEach(art => {\n        ids[i] = art.id\n\n        for (const current of art.values) {\n          const { key, value } = current\n          current.cache = buffer[key]\n          buffer[key] += value\n        }\n\n        setKeyCounts[art.set ?? ''] = 1 + (setKeyCounts[art.set ?? ''] ?? 0)\n        permute(i - 1, setKeyCounts)\n        setKeyCounts[art.set ?? ''] -= 1\n        if (setKeyCounts[art.set ?? ''] === 0) delete setKeyCounts[art.set ?? '']\n\n        for (const { key, cache } of art.values) buffer[key] = cache\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 8192)\n          interimReport(count)\n      }\n    }\n\n    for (const [key, value] of Object.entries(preArts.base)) {\n      const i = mapping[key]\n      if (i !== undefined)\n        buffer[i] = value\n    }\n\n    permute(arts.length - 1, {})\n    if (subproblem.cache) {\n      const cc = subproblem.cachedCompute\n      const maxEst = cc.maxEst[cc.maxEst.length - 1]\n\n      console.log('enumerated', { count: countBuilds(preArts), depth }, this.threshold, { gap: maxEst - maxFound }, { nodes, preArts }, cc)\n    }\n    this.interimReport(count)\n    return this.threshold\n  }\n\n  refresh(force: boolean): void {\n    const { maxBuilds } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    // I need frequent updating of threshold\n    if (true || this.builds.length >= 100000 || force) {\n      this.builds = this.builds\n        .sort((a, b) => b.value - a.value)\n        .slice(0, maxBuilds)\n      this.buildValues = this.builds.map(x => x.value)\n      this.threshold = Math.max(this.threshold, this.buildValues[maxBuilds - 1] ?? -Infinity)\n    }\n  }\n  interimReport = (count: { tested: number, failed: number, skipped: number }) => {\n    this.refresh(false)\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { constant, sum, prod } from \"./utils\"\nimport { ConstantNode, NumNode } from \"./type\"\nimport { allArtifactSets } from \"../Types/consts\"\nimport { cartesian } from '../Util/Util'\nimport { mapFormulas } from \"./internal\"\n\nexport function foldSum(nodes: NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n\n  nodes = nodes.flatMap(n => n.operation === 'add' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv + n.value : pv, 0)\n  nodes = nodes.filter(n => n.operation !== 'const')\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 0) return sum(...nodes)\n  return sum(...nodes, constant(constVal))\n}\n\nexport function foldProd(nodes: NumNode[]) {\n  if (nodes.length === 1) return nodes[0]\n\n  nodes = nodes.flatMap(n => n.operation === 'mul' ? n.operands : n)\n  let constVal = nodes.reduce((pv, n) => n.operation === 'const' ? pv * n.value : pv, 1)\n  nodes = nodes.filter(n => n.operation !== 'const')\n\n  if (nodes.length === 0) return constant(constVal)\n  if (constVal === 1) return prod(...nodes)\n  return prod(...nodes, constant(constVal))\n}\n\n/**\n * Factors damage formula into pure polynomials of each variable.\n * For example:  (1700 * atk_ + atk) * (1 + cr * cd) * (1 + sum_frac(EM))\n *   -> 1700 * atk_ + 1700 * atk_ * cr * cd + 1700 * atk_ * sum_frac(EM) + 1700 * atk_ * cr * cd * sum_frac(EM)\n *            + atk +         atk * cr * cd +         atk * sum_frac(EM) +         atk * cr * cd * sum_frac(EM)\n *\n * For a total of 8 terms, since there are 3 pairs of additions, for 2^3 sum-of-product terms.\n *\n * isVar() is used to check whether any node should be considered a variable on its own.\n */\nexport function expandPoly(node: NumNode, isVar: (n: NumNode) => boolean) {\n  let expanded = mapFormulas([node], n => n, f => {\n    switch (f.operation) {\n      case 'mul':\n        let ops = f.operands.map(n => n.operation === 'add' ? n.operands : [n])\n          .map((ns, i) => {\n            const varExprs = ns.map(n => isVar(n) || (n.operation === 'mul' && n.operands.some(isVar)))\n            let vars = ns.filter((n, i) => varExprs[i])\n            let nonVars = ns.filter((n, i) => !varExprs[i])\n\n            if (nonVars.length === 0) return vars\n            return [...vars, foldSum(nonVars)]\n          })\n        const products = cartesian(...ops).map(ns => foldProd(ns))\n        return foldSum(products)\n      case 'add':\n        let op2 = f.operands.flatMap(n => n.operation === 'add' ? n.operands : n)\n        return foldSum(op2)\n      default:\n        return f\n    }\n  })[0]\n\n  return expanded\n}\n\n/**\n * Assumes we've expanded the damage formula into sum-of-products form.\n * Prunes formulas that are unreachable due to not enough slots.\n */\nexport function productPossible(node: NumNode) {\n  return countSlotUsage(node) <= 5\n}\n\nfunction countSlotUsage(node: NumNode) {\n  if (node.operation === 'add') {\n    return Math.min(...node.operands.map(n => countSlotUsage(n)))\n  }\n  else if (node.operation === 'mul') {\n    return node.operands.map(n => countSlotUsage(n)).reduce((a, b) => a + b)\n  }\n  else if (node.operation === 'threshold') {\n    const branch = node.operands[0]\n    if (branch.operation === 'read' && (allArtifactSets as readonly string[]).includes(branch.path[1])) {\n      let con = node.operands[1] as ConstantNode<number>\n      return con.value\n    }\n  }\n  return 0\n}\n\n// function gatherSumOfProds(products: NumNode[], isVar: (n: NumNode) => boolean): NumNode[] {\n// return products\n// type NodeLinkedList = { n: NumNode, ix: number, next: NodeLinkedList | undefined }\n// let varMap = {} as Dict<number, NodeLinkedList> // my shitty hashmap\n// const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\n// let varCounter = 0\n// function lookup(n: NumNode) {\n//   let hsh = hashNode(n)\n//   let z = varMap[hsh]\n//   while (z !== undefined) {\n//     if (cmpNode(z.n, n)) return BigInt(z.ix)\n//     z = z.next\n//   }\n\n//   const ix = primes[varCounter]\n//   varMap[hsh] = { n, ix, next: varMap[hsh] }\n//   varCounter += 1\n//   return BigInt(ix)\n// }\n\n// let result: { [k: string]: { coeff: number, rhs: NumNode[] } } = {}\n// products.forEach(n => {\n//   if (n.operation === 'const') {\n//     result[1] = { coeff: n.value + (result[1]?.coeff ?? 0), rhs: [] }\n//     return\n//   }\n//   else if (isVar(n)) {\n//     let ix = lookup(n).toString()\n//     result[ix] = { coeff: 1 + (result[ix]?.coeff ?? 0), rhs: [n] }\n//     return\n//   }\n//   else if (n.operation === 'mul') {\n//     const { coeff, ix, ops } = n.operands.reduce(({ coeff, ix, ops }, n) => {\n//       if (n.operation === 'const') return { coeff: coeff * n.value, ix, ops }\n//       ops.push(n)\n//       return { coeff, ix: ix * lookup(n), ops: ops }\n//     }, { coeff: 1, ix: BigInt(1), ops: [] as NumNode[] })\n//     let ix2 = ix.toString()\n//     result[ix2] = { coeff: coeff + (result[ix2]?.coeff ?? 0), rhs: ops }\n//     return\n//   }\n//   console.log(n)\n//   throw Error('Encountered unexpected node in `gatherSumOfProds`')\n// })\n// return Object.entries(result).map(([k, { coeff, rhs }]) => {\n//   return foldProd([...rhs, constant(coeff)])\n// })\n// }\n","function pivot(A: number[][], ij: { i: number, j: number }) {\n  const { i, j } = ij\n  const Aij = A[i][j]\n  return A.map((Ah, h) => Ah.map((Ahk, k) => {\n    if (h === i && k === j) return 1 / Aij;\n    if (h === i) return A[i][k] / Aij;\n    if (k === j) return -A[h][j] / Aij;\n    return Ahk - A[i][k] * A[h][j] / Aij;\n  }))\n}\n\nfunction findPiv1(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let j = 0; j < c - 1; j++) {\n    if (A[r - 1][j] >= 0) continue\n    for (let i = 0; i < r - 1; i++) {\n      if (A[i][j] > 1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('UNBOUNDED FEASIBLE')\n  }\n\n  if (minloc.i < 0) throw Error('NO PIVOTS (done)')\n  return { i: minloc.i, j: minloc.j }\n}\n\nfunction findPiv2(A: number[][]) {\n  const r = A.length, c = A[0].length\n  let minloc = { i: -1, j: -1, cmp: Infinity }\n  for (let i = 0; i < r - 1; i++) {\n    if (A[i][c - 1] >= 0) continue\n    for (let j = 0; j < c - 1; j++) {\n      if (A[i][j] < -1e-5) {\n        const cmp = A[i][c - 1] / A[i][j]\n        if (cmp < minloc.cmp) minloc = { i, j, cmp }\n      }\n    }\n\n    if (minloc.i < 0) throw Error('INFEASIBLE')\n    return { i: minloc.i, j: minloc.j }\n  }\n  throw Error('NO PIVOTS (done)')\n}\n\nfunction backtrack(tableau: number[][], ijTrack: { i: number, j: number }[], targ: number) {\n  let side = 1;  // 0 left, 1 right\n  ijTrack.forEach(({ i, j }) => {\n    if (side === 1 && j === targ) {\n      targ = i\n      side = 0\n    }\n    else if (side === 0 && i === targ) {\n      targ = j\n      side = 1\n    }\n  })\n\n  const ncol = tableau[0].length\n  return side === 0 ? tableau[targ][ncol - 1] : 0\n}\n\n/**\n * Solve a Linear Program defined by:\n *              min  c^T x\n *               x\n *   Subject to:     Ax <= b\n *                    x >= 0\n *\n * Implemented according to:\n *   https://www.math.ucla.edu/~tom/LP.pdf\n *\n * Does not implement any cycle detection, though that *shouldnt* a problem for GO's use\n *   case. This algorithm is fairly numerically unstable though, use with care & always\n *   try to verify the solution. It's also a fair bit slower than it needs to be.\n *\n * @param c        Objective vector\n * @param Ab       Constraints matrix with thresholds. Inputted in block form [A, b]\n * @returns        the optimal solution x\n */\nexport function solveLP(c: number[], Ab: number[][]) {\n  let rows = Ab.length + 1\n  let cols = Ab[0].length\n\n  let tableau = Array(rows).fill(0).map(_ => Array(cols).fill(0))\n  Ab.forEach((Ai, i) => Ai.forEach((Aij, j) => tableau[i][j] = Aij))\n  // b.forEach((bi, i) => tableau[i][cols - 1] = bi)\n  c.forEach((cj, j) => tableau[rows - 1][j] = cj)\n  // console.log('tab', tableau)\n\n  let ijTrack: { i: number, j: number }[] = []\n\n  while (tableau.some((t, i) => i < rows - 1 && t[cols - 1] < 0)) {\n    const ij = findPiv2(tableau)\n    ijTrack.push(ij)\n    tableau = pivot(tableau, ij)\n  }\n\n  while (tableau[rows - 1].some((t, j) => j < cols - 1 && t < 0)) {\n    const ij = findPiv1(tableau)\n    ijTrack.push(ij)\n    tableau = pivot(tableau, ij)\n  }\n\n  return c.map((_, i) => backtrack(tableau, ijTrack, i))\n}\n","import { NumNode, ComputeNode } from \"./type\"\nimport { ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { constant, sum, prod, cmp } from \"./utils\"\nimport { foldSum, foldProd, expandPoly } from './expandPoly'\nimport { precompute, allOperations } from \"./optimization\"\nimport { solveLP } from './solveLP_simplex'\nimport { cartesian } from '../Util/Util'\nimport { mapFormulas } from \"./internal\"\nimport { fillBuffer } from \"./addedUtils\"\n\nexport type LinearForm = {\n  w: DynStat,\n  c: number,\n  err: number\n}\n\nfunction minMax(node: NumNode, lower: DynStat, upper: DynStat) {\n  let [compute, mapping, buffer] = precompute([node], n => n.path[1])\n  fillBuffer(lower, mapping, buffer)\n  const minval = compute()[0]\n  fillBuffer(upper, mapping, buffer)\n  const maxval = compute()[0]\n  return [minval, maxval]\n}\n\n/**\n * `res` is the ONE place where negative arguments & negative slopes are allowed.\n * @param node\n */\nfunction handleResArg(node: { 'operation': 'res', 'operands': NumNode[] }, lower: DynStat, upper: DynStat) {\n  function flipOps(n: NumNode): NumNode {\n    switch (n.operation) {\n      case 'add':\n        return sum(...n.operands.map(n => flipOps(n)))\n      case 'const':\n        return constant(-n.value)\n      case 'threshold':\n        const [branch, bval, ge, lt] = n.operands\n        if (ge.operation === 'const' && lt.operation === 'const') {\n          if (ge.value <= lt.value) {\n            return cmp(branch, bval, -ge.value, lt.value)\n          }\n        }\n        console.log(n)\n        throw Error('(res neg slope): threshold. Something went wrong.')\n      default:\n        console.log(n)\n        throw Error('(res neg slope) Havent written logic to handle this')\n    }\n  }\n\n  const flippedResOp = flipOps(node.operands[0])\n\n  let [a, b] = minMax(flippedResOp, lower, upper)\n  let resf = allOperations['res']\n  let [c, d] = [resf([-a]), resf([-b])]\n\n  if (b > 0 && a > -1.75) {\n    // 1 + x / 2\n    return sum(1, prod(.5, flippedResOp))\n  }\n\n  const intercept = (b * c - a * d) / (b - a)\n  const slope = (c - d) / (b - a)\n  return sum(intercept, prod(slope, flippedResOp))\n}\n\n/**\n * First converts a product of variables (including max, min, sum_frac, threshold, etc.) to\n *   a pure product form consisting of only `read` and `const` nodes, guaranteeing the\n *   product form is an upper bound.\n *\n * Then on the product form, create a linear upper bound using `lub` and return it.\n *\n * @param node The formula to expand\n * @param lower Stat lower bounds\n * @param upper Stat upper bounds\n * @returns\n */\nexport function toLinearUpperBound(node: NumNode, lower: DynStat, upper: DynStat): LinearForm | LinearForm[] {\n  // if (node.operation === 'const')\n  //   return { w: {}, c: node.value, err: 0 }\n  // if (node.operation === 'read')\n  //   return { w: { [node.path[1]]: 1 }, c: 0, err: 0 }\n  // if (node.operation !== 'mul') {\n  //   console.log(node)\n  //   throw Error('toLinearUpperBound should only operate on product forms')\n  // }\n\n  // let l = { ...lower }\n  // let u = { ...upper }\n  let linerr = 0\n\n  // Converts threshold(Glad) * ATK * min(CR, 1) => Glad * ATK * CR\n  // Also updates lower & upper limits to respect min, max, threshold.\n  // TODO: track linearization error for threshold(), min(), max(), sum_frac() nodes\n  function purePolyForm(node: NumNode) {\n    switch (node.operation) {\n      case 'const': case 'read':\n        return node\n      case 'add':\n        return foldSum(node.operands.map(n => purePolyForm(n)))\n      case 'mul':\n        return foldProd(node.operands.map(n => purePolyForm(n)))\n      case 'threshold':\n        const [branch, bval, ge, lt] = node.operands\n        if (branch.operation === 'read'\n          && bval.operation === 'const' && lt.operation === 'const' && ge.operation === 'const') {\n          let key = branch.path[1]\n          if (lower[key] >= bval.value) return constant(ge.value)\n          if (upper[key] < bval.value) return constant(lt.value)\n\n          if (ge.value < lt.value) {\n            console.log(node)\n            throw Error('Not Implemented (threshold must be increasing)')\n          }\n\n          const slope = (ge.value - lt.value) / bval.value\n          // u[key] = bval.value\n          // TODO: update linerr\n          return sum(lt.value, prod(slope, branch))\n        }\n        console.log(node)\n        throw Error('Not Implemented (threshold must branch between constants)')\n      case 'res':\n        let op = handleResArg(node as { 'operation': 'res', 'operands': NumNode[] }, lower, upper)\n        op = expandPoly(op, n => n.operation !== 'const')\n        return purePolyForm(op)\n\n      case 'min':\n        let [rop, cop] = node.operands\n        if (cop.operation !== 'const')\n          [rop, cop] = [cop, rop]  // Assume min(const, read)\n\n        // if (rop.operation === 'read' && cop.operation === 'const') {\n        // if (cop.value < upper[rop.path[1]]) {\n        // TODO: update linerr\n        // u[rop.path[1]] = cop.value\n        // }\n        // return purePolyForm(rop)\n        // }\n\n        // TODO: update linerr\n        // If it's not a simple min() node, returning either value is still UB.\n        return purePolyForm(rop)\n\n      case 'max':\n        let [varop, constop] = node.operands\n        if (constop.operation !== 'const')\n          [varop, constop] = [constop, varop]\n\n        if (cop.operation === 'const') {\n          const thresh = cop.value\n          const [minVal, maxVal] = minMax(varop, lower, upper)\n          if (minVal > thresh) return varop\n          if (thresh > maxVal) return constant(thresh)\n\n          // rescale `varop` to be above thresh.\n          let m = (maxVal - thresh) / (maxVal - minVal)\n          let b = thresh - minVal\n          return sum(prod(m, purePolyForm(varop)), b)\n        }\n        console.log(node)\n        throw Error('Not Implemented (max)')\n\n      case 'sum_frac':\n        const [em, denom] = node.operands\n        if (denom.operation !== 'const') throw Error('Not Implemented (non-constant sum_frac denominator)')\n\n        const [minEM, maxEM] = minMax(em, lower, upper)\n        const k = denom.value\n        // The sum_frac form is concave, so any Taylor expansion of EM / (EM + k) gives an upper bound.\n        // We can solve for the best Taylor approximation location with the following formula.\n        let loc = Math.sqrt((minEM + k) * (maxEM + k)) - k\n        let below = (k + loc) * (k + loc)\n        let slope = k / below\n        let c = loc * loc / below\n\n        // TODO: update linerr\n        return purePolyForm(sum(c, prod(slope, em)))\n      default:\n        console.log(node)\n        throw Error('Not Implemented')\n    }\n  }\n\n  // `lpf` *should* be a product of read() and const() nodes. Maybe a sum of these products.\n  const lpf = expandPoly(purePolyForm(node), n => n.operation !== 'const')\n  if (lpf.operation === 'const')\n    return { w: {} as DynStat, c: lpf.value, err: linerr }\n\n  function toLUB(n: NumNode) {\n    if (n.operation === 'read') {\n      return { w: { [n.path[1]]: 1 }, c: 0, err: 0 }\n    }\n    if (n.operation === 'const') {\n      return { w: {}, c: n.value, err: 0 }\n    }\n    if (n.operation !== 'mul') {\n      console.log(n)\n      throw Error('toLUB takes only mul nodes.')\n    }\n    let coeff = 1\n    // TODO: handle duplicity in the vars\n    const vars = n.operands.reduce((vars, op) => {\n      if (op.operation === 'read') vars.push(op.path[1])\n      if (op.operation === 'const') coeff *= op.value\n      return vars\n    }, [] as string[])\n    const bounds = vars.map(v => ({ lower: lower[v], upper: upper[v] }))\n    const { w, c, err } = lub(bounds)\n\n    const retw = w.reduce((ret, wi, i) => {\n      ret[vars[i]] = wi * coeff + (ret[vars[i]] ?? 0)\n      return ret\n    }, {} as DynStat)\n    return { w: retw, c: c * coeff, err: err * coeff + linerr }\n  }\n\n  if (lpf.operation === 'add') return lpf.operands.map(n => toLUB(n))\n  return toLUB(lpf)\n}\n\n/**\n * Constructs an upper bounding linear form for a function x_1 * x_2 * ... * x_n\n * @param bounds upper and lower bounds for each x_i\n * @returns { w, c, err } with\n */\nfunction lub(bounds: { lower: number, upper: number }[]): { w: number[], c: number, err: number } {\n  if (bounds.length === 0) return { w: [], c: 0, err: 0 }\n  const nVar = bounds.length\n\n  // Re-scale bounds to [0, 1] for numerical stability.\n  const boundScale = bounds.map(({ upper }) => upper)\n  const scaleProd = boundScale.reduce((prod, v) => prod * v, 1)\n  bounds = bounds.map(({ lower, upper }) => ({ lower: lower / upper, upper: 1 }))\n\n  // Setting up the linear program in terms of constraints.\n  let cons = cartesian(...bounds.map(({ lower, upper }) => [lower, upper])).flatMap((coords) => {\n    const prod = coords.reduce((prod, v) => prod * v, 1)\n    return [\n      [...coords.map(v => -v), 1, 0, -prod],\n      [...coords, -1, -1, prod],\n    ]\n  })\n\n  // Force equality at upper & lower corners?\n  // cons.push([...bounds.map(lu => lu.lower), -1, 0, bounds.reduce((prod, { lower }) => prod * lower, 1)])\n  // cons.push([...bounds.map(lu => lu.upper), -1, 0, bounds.reduce((prod, { upper }) => prod * upper, 1)])\n\n  let soln: any\n  const objective = [...bounds.map(_ => 0), 0, 1]\n  try {\n    // TODO: verify solution\n    soln = solveLP(objective, cons)\n  }\n  catch (e) {\n    console.log('ERROR on bounds', bounds)\n    console.log('Possibly numerical instability issue.')\n    throw e\n  }\n  return {\n    w: soln.slice(0, nVar).map((wi, i) => wi * scaleProd / boundScale[i]),\n    c: -scaleProd * soln[nVar],\n    err: scaleProd * soln[nVar + 1]\n  }\n}\n\nexport function maxWeight(a: ArtifactsBySlot, lin: LinearForm) {\n  const baseVal = sparseMatmul([lin], [a.base])[0][0] + lin.c\n\n  return baseVal + Object.entries(a.values).reduce((maxTotVal, [slotKey, slotArts]) => {\n    const wArts = sparseMatmul([lin], slotArts.map(a => a.values)).map(v => v[0])\n    return maxTotVal + Math.max(...wArts)\n  }, 0)\n\n  // const baseVal = Object.entries(lin.w).reduce((dotProd, [statKey, w]) => dotProd + w * a.base[statKey], lin.c)\n  // const maxTot = Object.entries(a.values).reduce((maxTotVal, [slotKey, slotArts]) => {\n  //   const maxSlot = slotArts.reduce((maxArt, art) => {\n  //     const artVal = Object.entries(lin.w).reduce((dotProd, [statkey, w]) => dotProd + w * art.values[statkey], 0)\n  //     return maxArt.v > artVal ? maxArt : { v: artVal, id: art.id }\n  //   }, { v: 0, id: '' })\n  //   maxTotVal.v += maxSlot.v\n  //   maxTotVal.ids.push(maxSlot.id)\n  //   return maxTotVal\n  // }, { v: baseVal, ids: [] as string[] })\n  // return maxTot.v\n}\n\n\n// Implement matrix multiply between row-major w's of LinearForm and col-major DynStats that represent artifacts.\n/**\n * Implements sparse matrix multiplication between A and x\n * @param A A list of row-major w's of some LinearForm\n * @param x A list of col-major DynStats that represent some artifacts\n * @returns A col-major 2d array number[][] with shape (A.length, x.length).\n *          ret[0] is [A1 @ x1, A2 @ x1, ..., An @ x1]\n */\nexport function sparseMatmul(A: LinearForm[], x: DynStat[]) {\n  return x.map(dyn => A.map(({ w }) => Object.entries(w).reduce((a, [k, wk]) => a + wk * (dyn[k] ?? 0), 0)))\n}\n","import { constant, prod, cmp } from \"./utils\"\nimport { NumNode } from \"./type\"\nimport { optimize } from \"./optimization\"\nimport { mapFormulas } from \"./internal\"\nimport { ArtifactBuildData, ArtifactsBySlot, DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\nimport { LinearForm, maxWeight, toLinearUpperBound } from \"./linearUpperBound\"\nimport { expandPoly, productPossible } from \"./expandPoly\"\nimport { ArtifactSetKey } from \"../Types/consts\"\n\nexport function slotUpperLower(a: ArtifactBuildData[]) {\n  let statsMin: DynStat = {}\n  let statsMax: DynStat = {}\n  let sets = new Set<ArtifactSetKey | undefined>()\n  a.forEach(art => {\n    for (const statKey in art.values) {\n      statsMin[statKey] = Math.min(art.values[statKey], statsMin[statKey] ?? Infinity)\n      statsMax[statKey] = Math.max(art.values[statKey], statsMax[statKey] ?? -Infinity)\n    }\n    if (art.set) {\n      statsMax[art.set] = 1\n      statsMin[art.set] = 0\n    }\n    sets.add(art.set)\n  })\n  if (sets.size === 1 && a[0].set) statsMin[a[0].set] = 1\n  return { statsMin, statsMax }\n}\n\nexport function statsUpperLower(a: ArtifactsBySlot) {\n  let statsMin: DynStat = { ...a.base }\n  let statsMax: DynStat = { ...a.base }\n  Object.entries(a.values).forEach(([slotKey, slotArts]) => {\n    const { statsMin: smin, statsMax: smax } = slotUpperLower(slotArts)\n    Object.keys(smin).forEach(sk => {\n      statsMin[sk] = smin[sk] + (statsMin[sk] ?? 0)\n      statsMax[sk] = smax[sk] + (statsMax[sk] ?? 0)\n    })\n  })\n  return { statsMin, statsMax }\n}\n\nexport function reduceFormula(f: NumNode[], lower: DynStat, upper: DynStat) {\n  const fixedStats = Object.keys(lower).filter(statKey => lower[statKey] === upper[statKey])\n  let f2 = mapFormulas(f, n => n, n => {\n    if (n.operation === 'read' && fixedStats.includes(n.path[1])) return constant(lower[n.path[1]])\n    if (n.operation === 'threshold') {\n      const [branch, branchVal, ge, lt] = n.operands\n      if (branch.operation === 'read' && branchVal.operation === 'const') {\n        if (lower[branch.path[1]] >= branchVal.value) return n.operands[2]\n        if (upper[branch.path[1]] < branchVal.value) return n.operands[3]\n      }\n    }\n    return n\n  })\n\n  return optimize(f2, {})\n}\n\nfunction estimateMaximumOnce(func: NumNode, a: ArtifactsBySlot, { statsMin, statsMax }: { statsMin: DynStat, statsMax: DynStat }): { maxEst: number, lin: LinearForm } {\n  // const { statsMin, statsMax } = statsUpperLower(a)\n\n  if (func.operation === 'const') {\n    return { maxEst: func.value, lin: toLinearUpperBound(func, statsMin, statsMax) as LinearForm }\n  }\n  if (func.operation === 'read') {\n    return { maxEst: statsMax[func.path[1]], lin: toLinearUpperBound(func, statsMin, statsMax) as LinearForm }\n  }\n\n  function isVariable(n: NumNode) {\n    switch (n.operation) {\n      case 'read': case 'max': case 'min': case 'sum_frac': case 'threshold': return true\n      default: return false\n    }\n  }\n\n  let expandedFunc = expandPoly(func, isVariable)\n  let products = (expandedFunc.operands as NumNode[]).filter(productPossible)\n  let linUBs = products.flatMap(n => toLinearUpperBound(n, statsMin, statsMax))\n\n  let linUBtot = linUBs.reduce((pv, lin) => {\n    Object.entries(lin.w).forEach(([k, v]) => pv.w[k] = v + (pv.w[k] ?? 0))\n    return { w: pv.w, c: pv.c + lin.c, err: pv.err + lin.err }\n  }, { w: {}, c: 0, err: 0 })\n\n  return { maxEst: maxWeight(a, linUBtot), lin: linUBtot }\n}\n\n/**\n * Estimates maximum value across an array of formulas\n * @param f              Functions to maximize\n * @param a              Artifact set\n * @param cachedCompute  Optional Prior cached compute. If specified, will re-calculate `maxEst` assuming `lin, lower, upper` are correct.\n * @returns              CachedCompute\n */\ntype MaxEstQuery = { f: NumNode[], a: ArtifactsBySlot, cachedCompute: { lower: DynStat, upper: DynStat } }\n  | { f?: undefined, cachedCompute: { lin: LinearForm[], lower: DynStat, upper: DynStat }, a: ArtifactsBySlot }\nexport function estimateMaximum({ f, a, cachedCompute }: MaxEstQuery) {\n  // function estimateMaximum(f: NumNode[], a: ArtifactsBySlot, cachedCompute?: CachedCompute) {\n  if (f !== undefined) {\n    const { lower, upper } = cachedCompute\n    // const { statsMin, statsMax } = statsUpperLower(a)\n    const est = f.map(fi => estimateMaximumOnce(fi, a, { statsMin: lower, statsMax: upper }))\n\n    return {\n      maxEst: est.map(({ maxEst }) => maxEst),\n      lin: est.map(({ lin }) => lin),\n      lower, upper\n    }\n  }\n\n  let { lin, lower, upper } = cachedCompute\n  return {\n    maxEst: lin.map(l => maxWeight(a, l)),\n    lin, lower, upper\n  }\n}\n\nexport function fillBuffer(stats: DynStat, mapping: Dict<string, number>, buffer: Float64Array) {\n  Object.entries(stats)\n    .filter(([k]) => mapping[k] !== undefined)\n    .forEach(([k, v]) => buffer[mapping[k]!] = v)\n}\n","import type { NumNode } from '../../../../Formula/type';\nimport { precompute } from '../../../../Formula/optimization';\nimport { allSlotKeys, ArtifactSetKey } from '../../../../Types/consts';\nimport { estimateMaximum, fillBuffer, reduceFormula, slotUpperLower, statsUpperLower } from '../../../../Formula/addedUtils';\nimport type { ArtSetExclusionFull, CachedCompute, InterimResult, Setup, Split, SplitWork, SubProblem, SubProblemNC, SubProblemWC } from './BackgroundWorker';\nimport { ArtifactBuildData, ArtifactsBySlot, countBuilds, DynStat, filterArts, RequestFilter } from './common';\nimport { cartesian, objectKeyMap, objectKeyValueMap } from '../../../../Util/Util';\nimport { sparseMatmul } from '../../../../Formula/linearUpperBound';\n\nexport class SplitWorker {\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: NumNode[]\n  artSet: Dict<ArtifactSetKey | 'uniqueKey', number[]>\n\n  subproblems: { count: number, heur: number, subproblem: SubProblem }[] = []\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, optimizationTarget, filters, artSetExclusion }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.min = filters.map(x => x.min)\n    this.nodes = filters.map(x => x.value)\n    this.callback = callback\n\n    this.min.push(-Infinity)\n    this.nodes.push(optimizationTarget)\n\n    this.artSet = objectKeyValueMap(Object.entries(artSetExclusion), ([setKey, v]) => {\n      if (setKey === 'rainbow') return ['uniqueKey', v.map(v => v + 1)]\n      return [setKey, v.flatMap(v => (v === 2) ? [2, 3] : [4, 5])]\n    })\n  }\n\n  addSubProblem(subproblem: SubProblem) {\n    const count = countBuilds(filterArts(this.arts, subproblem.filter))\n    if (count === 0) return\n    let maxEst = subproblem.cache ? subproblem.cachedCompute.maxEst[subproblem.cachedCompute.maxEst.length - 1] : 0\n    this.subproblems.push({ count, heur: maxEst, subproblem })\n  }\n\n  /**\n   * Iteratively splits the subproblem (depth-first) into smaller chunks until it is small enough,\n   *   as determined by `minCount`. Repeat up to `maxIter` times before returning control to the main thread.\n   * @param minCount\n   * @param maxIter\n   * @returns Either ONE [subproblem] of size `minCount` or ZERO [] subproblems.\n   */\n  split({ threshold, minCount, maxIter, subproblem }: Split): SubProblem[] {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n    const initialProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n\n    // console.log('split', this.min[this.min.length - 1], {\n    //   todo: this.subproblems.length, buildsleft: this.subproblems.reduce((a, { count }) => a + count, 0)\n    // }, this.subproblems)\n\n    let n = 0\n    while (n < maxIter && this.subproblems.length) {\n      n += 1\n      const { count, subproblem } = this.subproblems.pop()!\n      if (count <= minCount) {\n        const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0) + count\n        this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n        return [subproblem]\n      }\n\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n    }\n    const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n    this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n    return []\n  }\n\n  popOne() {\n    // Yield largest subproblem (requests => level-order / prio queue order)\n    if (this.subproblems.length === 0) return undefined\n    let ret = { i: -1, heur: -Infinity }\n    for (let i = 1; i < this.subproblems.length; i++) {\n      const { heur, subproblem } = this.subproblems[i]\n      if (heur > ret.heur) ret = { i, heur }\n    }\n    if (ret.i < 0) return undefined\n    return this.subproblems.splice(ret.i, 1)[0].subproblem\n  }\n\n  /**\n   * Iteratively splits the subproblem (breadth-first) into many many chunks to better distribute the B&B workload\n   *   between the workers. There is some danger of over-fracturing the chunks.\n   * @returns A list of [subproblems] with length `numSplits`\n   */\n  splitWork({ threshold, numSplits, subproblem }: SplitWork) {\n    if (threshold > this.min[this.min.length - 1]) this.min[this.min.length - 1] = threshold\n    if (subproblem) this.addSubProblem(subproblem)\n    const initialProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n\n    console.log('splitWork', this.min[this.min.length - 1], {\n      todo: this.subproblems.length, buildsleft: this.subproblems.reduce((a, { count }) => a + count, 0)\n    })\n\n    while (this.subproblems.length > 0 && this.subproblems.length <= numSplits) {\n      const { subproblem } = this.subproblems.shift()!\n      this.splitBNB(this.min[this.min.length - 1], subproblem).forEach(subp => this.addSubProblem(subp))\n    }\n    const newProblemTotal = this.subproblems.reduce((a, { count }) => a + count, 0)\n    this.callback({ command: 'interim', tested: 0, failed: 0, skipped: initialProblemTotal - newProblemTotal, buildValues: undefined })\n    console.log('exit splitWork. Filters pre-exit', this.subproblems)\n    return this.subproblems.splice(0, numSplits).map(({ subproblem }) => subproblem)\n  }\n\n  /**\n   * splitBNB takes a SubProblem and tries to perform Branch and Bound (BnB) pruning to solve for the\n   *   optimal damage value. As the name states, there are two main phases: Branching and Bounding.\n   *   The bounding is handled by an `estimateMaximum()` function call, and the branching is done by `pickBranch()`.\n   *\n   * @param threshold  Objective function lower bound threshold\n   * @param subproblem The subproblem to split\n   * @returns An array of up to 32 splits of the input subproblem.\n   */\n  splitBNB(threshold: number, subproblem: SubProblem) {\n    const a = filterArts(this.arts, subproblem.filter)\n\n    // 1. check constraints & simplify formula.\n    if (subproblem.cache === false) {\n      const { statsMin, statsMax } = statsUpperLower(a)\n\n      // 1a. Simplify formula, cut off always-satisfied constraints, and validate setExclusion stuff.\n      let sub2 = reduceSubProblem(subproblem, statsMin, statsMax)\n      if (sub2 === undefined) return []\n\n      // 1b. Check that remaining constraints are satisfiable\n      let f = [...sub2.constraints.map(({ value }) => value), sub2.optimizationTarget]\n      const cachedCompute = estimateMaximum({ f, a, cachedCompute: { lower: statsMin, upper: statsMax } })\n      if (sub2.constraints.some(({ min }, i) => cachedCompute.maxEst[i] < min)) return []\n      if (cachedCompute.maxEst[cachedCompute.maxEst.length - 1] < threshold) return []\n\n      subproblem = { ...sub2, cache: true, cachedCompute }\n    }\n    // 1c. A cached subproblem skips most of the above constraint checking, but `threshold` may change\n    //     between iterations.\n    const { cachedCompute } = subproblem\n    if (cachedCompute.maxEst[cachedCompute.maxEst.length - 1] < threshold) return []\n\n    // console.log(subproblem)\n\n    // 2. Pick branching parameter\n    let numBuilds = Object.values(a.values).reduce((tot, arts) => tot * arts.length, 1)\n    const { k } = pickBranch(a, threshold, subproblem)\n    const branchVals = Object.fromEntries(Object.entries(a.values).map(([slotKey, arts]) => {\n      const vals = arts.map(a => a.values[k])\n      return [slotKey, (Math.min(...vals) + Math.max(...vals)) / 2]\n    }))\n    const branchArts = Object.fromEntries(Object.entries(a.values).map(([slotKey, arts]) => {\n      const above = arts.filter(art => art.values[k] < branchVals[slotKey] ? true : false)\n      const below = arts.filter(art => art.values[k] < branchVals[slotKey] ? false : true)\n      return [slotKey, [{ arts: below, ...slotUpperLower(below) }, { arts: above, ...slotUpperLower(above) }]]\n    }))\n\n    // 3. Perform branching. Check bounding during the branching phase as well.\n    let branches = [] as { numBuilds: number, heur: number, subproblem: SubProblemWC }[]\n    cartesian([0, 1], [0, 1], [0, 1], [0, 1], [0, 1]).forEach(([s1, s2, s3, s4, s5]) => {\n      let selected = {\n        flower: branchArts.flower[s1],\n        plume: branchArts.plume[s2],\n        sands: branchArts.sands[s3],\n        goblet: branchArts.goblet[s4],\n        circlet: branchArts.circlet[s5],\n      }\n\n      let z: ArtifactsBySlot = {\n        base: { ...a.base },\n        values: objectKeyValueMap(Object.entries(selected), ([k, { arts }]) => [k, arts])\n      }\n\n      let numBuilds = Object.values(z.values).reduce((tot, arts) => tot * arts.length, 1)\n      if (numBuilds === 0) return;\n\n      let statsMin = { ...a.base }\n      let statsMax = { ...a.base }\n      Object.entries(selected).forEach(([slotKey, { statsMin: smin, statsMax: smax }]) => {\n        Object.entries(smin).forEach(([k, v]) => statsMin[k] = v + (statsMin[k] ?? 0))\n        Object.entries(smax).forEach(([k, v]) => statsMax[k] = v + (statsMax[k] ?? 0))\n      })\n\n      // 1a. Simplify formula, cut off always-satisfied constraints, and validate setExclusion stuff.\n      let sub2 = reduceSubProblem(subproblem, statsMin, statsMax)\n      if (sub2 === undefined) return;\n\n      // 1b. (fast) Check that existing constraints are satisfiable\n      let { maxEst } = estimateMaximum({ a: z, cachedCompute })\n      if (sub2.constraints.some(({ min }, i) => maxEst[i] < min)) return;\n      if (maxEst[maxEst.length - 1] < threshold) return;\n\n      // 1b. (slow) Check that existing constraints are satisfiable\n      let f = [...sub2.constraints.map(({ value }) => value), sub2.optimizationTarget]\n      let cc2 = estimateMaximum({ a: z, f, cachedCompute: { lower: statsMin, upper: statsMax } })\n      if (sub2.constraints.some(({ min }, i) => cc2.maxEst[i] < min)) return;\n      if (cc2.maxEst[cc2.maxEst.length - 1] < threshold) return;\n\n      let newFilter: RequestFilter = objectKeyMap(allSlotKeys, slot => ({ kind: 'id' as 'id', ids: new Set(z.values[slot].map(art => art.id)) }))\n      branches.push({\n        numBuilds,\n        heur: cc2.maxEst[cc2.maxEst.length - 1],\n        subproblem: {\n          ...sub2,\n          filter: newFilter,\n          cache: true,\n          cachedCompute: cc2,\n          depth: sub2.depth + 1\n        }\n      })\n    })\n    branches.sort((a, b) => b.numBuilds - a.numBuilds)\n    return branches.map(({ subproblem }) => subproblem)\n  }\n}\n\n/**\n * Takes a Subproblem and reduces whatever formulas it can. Also deletes any constraint equations that are always active\n *   (and therefore have no contribution)\n *\n * @param sub          Subproblem to reduce/simplify.\n * @param statsMinMax  Reduction is based on the range of valid stats.\n * @returns  A new subproblem that should be identical to the previous one, but with fewer components.\n *           If the subproblem is unsatisfiable, return `undefined`\n */\nfunction reduceSubProblem({ optimizationTarget, constraints, artSetExclusion, filter, depth }: SubProblem, statsMin: DynStat, statsMax: DynStat, debug = false): SubProblemNC | undefined {\n  // const { optimizationTarget, constraints, artSetExclusion } = sub\n  let subnodes = [...constraints.map(({ value }) => value), optimizationTarget]\n  const submin = constraints.map(({ min }) => min)\n\n  subnodes = reduceFormula(subnodes, statsMin, statsMax)\n\n  // 1. Check for always-feasible constraints.\n  const [compute, mapping, buffer] = precompute(subnodes, n => n.path[1])\n  fillBuffer(statsMin, mapping, buffer)\n  const result = compute()\n\n  const newOptTarget = subnodes.pop()!\n  const active = submin.map((m, i) => m > result[i])\n  const newConstraints = subnodes.map((value, i) => ({ value, min: submin[i] })).filter((_, i) => active[i])\n  if (debug) console.log('reduceSubP', { statsMin, subnodes, submin, result, active })\n\n  // 2. Check for never-active and always-active ArtSetExcl constraints.\n  let newArtExcl = {} as ArtSetExclusionFull\n  for (const [setKey, exclude] of Object.entries(artSetExclusion)) {\n    if (setKey === 'uniqueKey') {\n      // let minSets = Object.fromEntries(Object.entries(statsMin).filter(([statKey, v]) => v > 0 && allArtifactSets.includes(statKey as any)))\n      // let numSets = Object.keys(minSets).length\n      // let numSlotsUsed = Object.values(minSets).reduce((a, b) => a + b)\n\n      // TODO: Check and exclude rainbow bullshit.\n      newArtExcl[setKey] = exclude\n      continue\n    }\n    const reducedExcl = exclude.filter(n => statsMin[setKey] <= n && n <= statsMax[setKey])        // Cut away never-active\n    if (reducedExcl.includes(statsMin[setKey]) && reducedExcl.includes(statsMax[setKey])) return;  // Always active.\n    if (reducedExcl.length > 0) newArtExcl[setKey] = reducedExcl\n  }\n\n  return {\n    cache: false,\n    optimizationTarget: newOptTarget,\n    constraints: newConstraints,\n    artSetExclusion: newArtExcl,\n\n    filter, depth\n  }\n}\n\n/**\n * Decides how to split between different branches.\n * TODO: Branch values should also be calculated & returned here\n * @param a     Artifact set\n * @param lin   Linear form from compute\n * @returns     The key to branch on.\n */\nfunction pickBranch(a: ArtifactsBySlot, threshold: number, subproblem: SubProblemWC) {\n  const { constraints, cachedCompute: { lin }, artSetExclusion } = subproblem\n  let wMins = sparseMatmul(lin, [a.base])[0]\n  let wMaxs = sparseMatmul(lin, [a.base])[0]\n  Object.entries(a.values).forEach(([slotKey, arts]) => {\n    const matmul = sparseMatmul(lin, arts.map(({ values }) => values))\n    wMins.forEach((_, i) => {\n      wMaxs[i] += Math.max(...matmul.map(row => row[i]))\n      wMins[i] += Math.min(...matmul.map(row => row[i]))\n    })\n  })\n\n  const thr = [...constraints.map(({ min }) => min), threshold]\n  // Consider this the \"probability\" a randomly chosen set of 5 artifacts will violate\n  //   the constraints; assuming the marginal distribution of the values are uniform on\n  //   their ranges. Honestly it's a really wacky heuristic but it does a good job\n  //   at telling the algorithm to branch targeting a constraint when that constraint\n  //   becomes difficult to satsify. (>50% chance to violate)\n  const decisionHeur = thr.map((th, i) => (th - wMins[i]) / (wMaxs[i] - wMins[i])).map(v => v < .5 ? -1 : v)\n  decisionHeur[decisionHeur.length - 1] = Math.max(decisionHeur[decisionHeur.length - 1], 0)\n  const argMax = decisionHeur.reduce((m, c, i) => c > decisionHeur[m] ? i : m, 0)\n\n  // TODO: figure out a heuristic for when to branch on artSetExclusion\n\n  let linToConsider = lin[argMax]\n  // let linToConsider = lin[lin.length - 1]\n  let keysToConsider = Object.keys(linToConsider.w)\n  // let keysToConsider = [...Object.keys(linToConsider.w), ...Object.keys(artSetExclusion).filter(k => k !== 'uniqueKey')]\n\n  let shatterOn = { k: '', heur: -1 }\n  keysToConsider.forEach(k => {\n    const postShatterRangeReduction = Object.entries(a.values).reduce((rangeReduc, [slot, arts]) => {\n      const vals = arts.map(a => a.values[k])\n      const minv = Math.min(...vals)\n      const maxv = Math.max(...vals)\n      if (minv === maxv) return rangeReduc\n\n      const branchVal = (minv + maxv) / 2\n      const glb = Math.max(...vals.filter(v => v <= branchVal))\n      const lub = Math.min(...vals.filter(v => v > branchVal))\n      return rangeReduc + Math.min(maxv - glb, lub - minv)\n    }, 0)\n    const heur = linToConsider.w[k] * postShatterRangeReduction\n    // console.log('old', { k, heur })\n    if (heur > shatterOn.heur) shatterOn = { k, heur }\n  })\n\n  if (shatterOn.k === '') {\n    console.log(subproblem, reduceSubProblem(subproblem, subproblem.cachedCompute.lower, subproblem.cachedCompute.upper, true))\n    console.log('===================== SHATTER BROKE ====================', lin, a)\n    throw Error('Shatter broke...')\n  }\n  return shatterOn\n}\n","import { LinearForm } from '../../../../Formula/linearUpperBound'\nimport { NumNode } from '../../../../Formula/type'\nimport { ArtifactSetKey } from '../../../../Types/consts'\nimport { assertUnreachable } from '../../../../Util/Util'\nimport { ArtSetExclusion } from './BuildSetting'\nimport { ArtifactsBySlot, artSetPerm, Build, countBuilds, DynStat, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\nimport { ComputeWorker } from \"./ComputeWorker\"\nimport { SplitWorker } from \"./SplitWorker\"\n\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\n\nonmessage = ({ data }: { data: WorkerCommand }) => {\n  const command = data.command\n  let result: WorkerResult\n  switch (command) {\n    case \"setup\":\n      id = data.id\n      const callback = (interim: InterimResult) => postMessage({ id, ...interim })\n      splitWorker = new SplitWorker(data, callback)\n      computeWorker = new ComputeWorker(data, callback)\n      result = { command: \"iterate\" }\n      break\n    case \"split\":\n      result = { command: \"split\", subproblems: splitWorker.split(data), ready: splitWorker.subproblems.length === 0 }\n      break\n    case \"splitwork\":\n      result = { command: 'split', subproblems: splitWorker.splitWork(data), ready: splitWorker.subproblems.length === 0 }\n      break\n    case \"iterate\":\n      const { threshold, subproblem } = data\n      computeWorker.compute(threshold, subproblem)\n      result = { command: \"iterate\" }\n      break\n    case \"finalize\":\n      computeWorker.refresh(true)\n      const { builds, plotData } = computeWorker\n      result = { command: \"finalize\", builds, plotData }\n      break\n    // case \"count\":\n    //   {\n    //     const { exclusion } = data, arts = computeWorker.arts\n    //     const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\n    //     let counts = data.arts.map(_ => 0)\n    //     for (const perm of setPerm)\n    //       data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\n    //     result = { command: \"count\", counts }\n    //     break\n    //   }\n    case \"share\":\n      const oo = splitWorker.popOne()\n      result = { command: 'share', subproblem: oo, sender: data.sender }\n      break\n    default: assertUnreachable(command)\n  }\n  postMessage({ id, ...result });\n}\n\n\nexport type ArtSetExclusionFull = Dict<Exclude<ArtifactSetKey, \"PrayersForDestiny\" | \"PrayersForIllumination\" | \"PrayersForWisdom\" | \"PrayersToSpringtime\"> | \"uniqueKey\", number[]>\nexport type SubProblem = SubProblemNC | SubProblemWC\nexport type SubProblemNC = {\n  cache: false,\n  optimizationTarget: NumNode,\n  constraints: { value: NumNode, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filter: RequestFilter,\n  depth: number,\n}\nexport type SubProblemWC = {\n  cache: true,\n  optimizationTarget: NumNode,\n  constraints: { value: NumNode, min: number }[],\n  artSetExclusion: ArtSetExclusionFull,\n\n  filter: RequestFilter,\n  cachedCompute: CachedCompute,\n  depth: number,\n}\nexport type CachedCompute = {\n  maxEst: number[],\n  lin: LinearForm[],\n  lower: DynStat,\n  upper: DynStat\n}\n\nexport type WorkerCommand = Setup | Split | SplitWork | Iterate | Finalize | Share\n// export type WorkerResult = InterimResult | SplitResult | IterateResult | FinalizeResult | CountResult\nexport type WorkerResult = InterimResult | SplitResult | IterateResult | FinalizeResult | ShareResult\n\nexport interface Setup {\n  command: \"setup\"\n\n  id: number\n  arts: ArtifactsBySlot\n\n  optimizationTarget: NumNode\n  filters: { value: NumNode, min: number }[]\n  artSetExclusion: ArtSetExclusion\n  plotBase: NumNode | undefined,\n  maxBuilds: number\n}\nexport interface Split {\n  command: \"split\"\n  threshold: number\n  minCount: number\n  maxIter: number\n\n  subproblem?: SubProblem\n}\nexport interface SplitWork {\n  command: \"splitwork\"\n  threshold: number\n  numSplits: number\n\n  subproblem?: SubProblem\n}\nexport interface Iterate {\n  command: \"iterate\"\n  threshold: number\n\n  subproblem: SubProblem\n}\nexport interface Finalize {\n  command: \"finalize\"\n}\nexport interface Share {\n  command: \"share\"\n  sender: number\n}\n\n\n// export interface Count {\n//   command: \"count\"\n//   arts: ArtifactsBySlot[]\n//   exclusion: ArtSetExclusion\n// }\n\nexport interface InterimResult {\n  command: \"interim\"\n  buildValues: number[] | undefined\n  /** The number of builds since last report, including failed builds */\n  tested: number\n  /** The number of builds that does not meet the min-filter requirement since last report */\n  failed: number\n  skipped: number\n}\nexport interface IterateResult {\n  command: \"iterate\"\n}\nexport interface SplitResult {\n  command: \"split\"\n  ready: boolean\n  subproblems: SubProblem[]\n}\nexport interface FinalizeResult {\n  command: \"finalize\"\n  builds: Build[]\n  plotData?: PlotData\n}\nexport interface CountResult {\n  command: \"count\"\n  counts: number[]\n}\nexport interface ShareResult {\n  command: \"share\"\n  subproblem?: SubProblem\n  sender: number\n}\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","name","from","test","isArray","iter","Symbol","iterator","TypeError","_i","_s","_e","_arr","_n","_d","next","done","err","objPathValue","console","error","reduce","a","k","objectKeyMap","map","fromEntries","objectKeyValueMap","items","t","assertUnreachable","Error","cartesian","q","b","flatMap","d","e","flat","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","_e2","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","constant","NaN","percent","info","operation","operands","Number","MAX_VALUE","Infinity","sum","values","intoOps","prod","intoV","mapFormulas","formulas","topDownMap","bottomUpMap","visiting","Set","topDownMapped","Map","bottomUpMapped","check","formula","topDown","get","bottomUp","has","add","arrayEqual","traverse","delete","set","result","undefined","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","precompute","binding","uniqueReadStrings","uniqueNumbers","mapping","visited","forEachNodes","_","type","accu","ins","op","locations","readStrings","readOffset","constValues","computations","str","offset","ref","node","out","buff","fill","buffer","Float64Array","number","copyList","src","copyFormula","dst","j","flattened","dep","elementCounts","array","wrap","common","counts","factored","count","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","entries","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","origin","data","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","smallest","v1","v2","match","unmatch","list","path","reset","nextContext","allSlotKeys","allArtifactSets","filterArts","arts","filters","base","slot","kind","art","ids","id","sets","countBuilds","_count","ComputeWorker","callback","optimizationTarget","plotBase","maxBuilds","builds","buildValues","plotData","nodes","interimReport","refresh","command","tested","failed","skipped","this","newThreshold","subproblem","constraints","artSetExclusion","depth","self","preArts","totalCount","cache","cachedCompute","maxEst","compute","sort","maxFound","permute","cc","log","gap","setKeyCounts","passArtExcl","setKey","includes","nRainbow","m","build","artifactIds","plot","current","force","plots","scale","v","round","size","mergePlot","foldSum","constVal","pv","foldProd","expandPoly","isVar","ops","ns","varExprs","some","vars","nonVars","productPossible","countSlotUsage","branch","pivot","A","ij","Aij","Ah","h","Ahk","findPiv1","r","c","minloc","cmp","findPiv2","minMax","lower","upper","fillBuffer","minval","handleResArg","flippedResOp","flipOps","bval","ge","lt","resf","toLinearUpperBound","lpf","purePolyForm","slope","rop","cop","varop","constop","thresh","minVal","maxVal","em","denom","minEM","maxEM","loc","sqrt","below","w","toLUB","coeff","bounds","nVar","boundScale","scaleProd","soln","cons","coords","objective","Ab","rows","cols","tableau","Ai","cj","ijTrack","targ","side","ncol","backtrack","solveLP","wi","lub","ret","maxWeight","lin","sparseMatmul","maxTotVal","slotArts","wArts","dyn","slotUpperLower","statsMin","statsMax","statKey","reduceFormula","fixedStats","branchVal","estimateMaximum","est","fi","func","linUBtot","estimateMaximumOnce","l","stats","splitWorker","computeWorker","SplitWorker","artSet","subproblems","heur","minCount","maxIter","addSubProblem","initialProblemTotal","pop","newProblemTotal","splitBNB","subp","splice","numSplits","todo","buildsleft","shift","smin","smax","sk","statsUpperLower","sub2","reduceSubProblem","tot","wMins","wMaxs","matmul","row","decisionHeur","th","argMax","linToConsider","keysToConsider","shatterOn","postShatterRangeReduction","rangeReduc","vals","minv","maxv","glb","pickBranch","branchVals","slotKey","branchArts","above","branches","s1","s2","s3","s4","s5","flower","plume","sands","goblet","circlet","z","numBuilds","cc2","newFilter","debug","subnodes","submin","newOptTarget","active","newConstraints","newArtExcl","exclude","reducedExcl","onmessage","interim","postMessage","split","ready","splitWork","popOne","sender"],"sourceRoot":""}